"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
const decimal_js_1 = require("decimal.js");
const ethers_1 = require("ethers");
const hardhat_1 = require("hardhat");
const hardhat_network_helpers_1 = require("@nomicfoundation/hardhat-network-helpers");
const expect_1 = require("./shared/expect");
const fixtures_1 = require("./shared/fixtures");
const format_1 = require("./shared/format");
const utilities_1 = require("./shared/utilities");
decimal_js_1.Decimal.config({ toExpNeg: -500, toExpPos: 500 });
function swapCaseToDescription(testCase) {
    const priceClause = testCase?.sqrtPriceLimit ? ` to price ${(0, format_1.formatPrice)(testCase.sqrtPriceLimit)}` : '';
    if ('exactOut' in testCase) {
        if (testCase.exactOut) {
            if (testCase.zeroToOne) {
                return `swap token0 for exactly ${(0, format_1.formatTokenAmount)(testCase.amount1)} token1${priceClause}`;
            }
            else {
                return `swap token1 for exactly ${(0, format_1.formatTokenAmount)(testCase.amount0)} token0${priceClause}`;
            }
        }
        else {
            let title = '';
            if (testCase.comissionOnTransaction) {
                title = 'Token with commission ';
            }
            if (testCase.zeroToOne) {
                return `${title}swap exactly ${(0, format_1.formatTokenAmount)(testCase.amount0)} token0 for token1${priceClause}`;
            }
            else {
                return `${title}swap exactly ${(0, format_1.formatTokenAmount)(testCase.amount1)} token1 for token0${priceClause}`;
            }
        }
    }
    else {
        if ('sqrtPriceLimit' in testCase) {
            if (testCase.zeroToOne) {
                return `swap token0 for token1${priceClause}`;
            }
            else {
                return `swap token1 for token0${priceClause}`;
            }
        }
        else {
            if (testCase.zeroToOne) {
                return `swap token0 for token1 to tick ${testCase.targetTick}`;
            }
            else {
                return `swap token1 for token0 to tick ${testCase.targetTick}`;
            }
        }
    }
}
// can't use address zero because the ERC20 token does not allow it
const SWAP_RECIPIENT_ADDRESS = ethers_1.ZeroAddress.slice(0, -1) + '1';
const POSITION_PROCEEDS_OUTPUT_ADDRESS = ethers_1.ZeroAddress.slice(0, -1) + '2';
async function executeSwap(testCase, poolFunctions, testCallee) {
    let swap;
    if ('exactOut' in testCase) {
        if (testCase.exactOut) {
            if (testCase.zeroToOne) {
                swap = await poolFunctions.swap0ForExact1(testCase.amount1, SWAP_RECIPIENT_ADDRESS, testCase.sqrtPriceLimit);
            }
            else {
                swap = await poolFunctions.swap1ForExact0(testCase.amount0, SWAP_RECIPIENT_ADDRESS, testCase.sqrtPriceLimit);
            }
        }
        else {
            if (testCase.zeroToOne) {
                if (testCase.comissionOnTransaction) {
                    swap = await poolFunctions.swapExact0For1SupportingFee(testCase.amount0, SWAP_RECIPIENT_ADDRESS, testCase.sqrtPriceLimit);
                }
                else {
                    swap = await poolFunctions.swapExact0For1(testCase.amount0, SWAP_RECIPIENT_ADDRESS, testCase.sqrtPriceLimit);
                }
            }
            else {
                if (testCase.comissionOnTransaction) {
                    swap = await poolFunctions.swapExact1For0SupportingFee(testCase.amount1, SWAP_RECIPIENT_ADDRESS, testCase.sqrtPriceLimit);
                }
                else {
                    swap = await poolFunctions.swapExact1For0(testCase.amount1, SWAP_RECIPIENT_ADDRESS, testCase.sqrtPriceLimit);
                }
            }
        }
    }
    else {
        let targetPrice;
        if ('sqrtPriceLimit' in testCase) {
            targetPrice = testCase.sqrtPriceLimit;
        }
        else {
            if (testCase.targetTick === undefined)
                throw new Error('Invalid target tick');
            targetPrice = await testCallee.getPriceAtTick(testCase.targetTick);
        }
        if (testCase.zeroToOne) {
            if (targetPrice === undefined)
                throw new Error('Invalid target price');
            swap = await poolFunctions.swapToLowerPrice(targetPrice, SWAP_RECIPIENT_ADDRESS);
        }
        else {
            if (targetPrice === undefined)
                throw new Error('Invalid target price');
            swap = await poolFunctions.swapToHigherPrice(targetPrice, SWAP_RECIPIENT_ADDRESS);
        }
    }
    return swap;
}
const DEFAULT_POOL_SWAP_TESTS = [
    // swap large amounts in/out
    {
        zeroToOne: true,
        exactOut: false,
        amount0: (0, utilities_1.expandTo18Decimals)(1),
        comissionOnTransaction: false,
    },
    {
        zeroToOne: true,
        exactOut: false,
        amount0: (0, utilities_1.expandTo18Decimals)(1),
        comissionOnTransaction: true,
    },
    {
        zeroToOne: false,
        exactOut: false,
        amount1: (0, utilities_1.expandTo18Decimals)(1),
        comissionOnTransaction: false,
    },
    {
        zeroToOne: false,
        exactOut: false,
        amount1: (0, utilities_1.expandTo18Decimals)(1),
        comissionOnTransaction: true,
    },
    {
        zeroToOne: true,
        exactOut: true,
        amount1: (0, utilities_1.expandTo18Decimals)(1),
    },
    {
        zeroToOne: false,
        exactOut: true,
        amount0: (0, utilities_1.expandTo18Decimals)(1),
    },
    // swap large amounts in/out with a price limit
    {
        zeroToOne: true,
        exactOut: false,
        amount0: (0, utilities_1.expandTo18Decimals)(1),
        sqrtPriceLimit: (0, utilities_1.encodePriceSqrt)(50, 100),
    },
    {
        zeroToOne: false,
        exactOut: false,
        amount1: (0, utilities_1.expandTo18Decimals)(1),
        sqrtPriceLimit: (0, utilities_1.encodePriceSqrt)(200, 100),
    },
    {
        zeroToOne: true,
        exactOut: true,
        amount1: (0, utilities_1.expandTo18Decimals)(1),
        sqrtPriceLimit: (0, utilities_1.encodePriceSqrt)(50, 100),
    },
    {
        zeroToOne: false,
        exactOut: true,
        amount0: (0, utilities_1.expandTo18Decimals)(1),
        sqrtPriceLimit: (0, utilities_1.encodePriceSqrt)(200, 100),
    },
    {
        zeroToOne: false,
        exactOut: false,
        amount1: 2n ** 128n - 1n,
        sqrtPriceLimit: 0n,
    },
    {
        zeroToOne: false,
        exactOut: false,
        amount1: 2n ** 256n - 1n,
        sqrtPriceLimit: 0n,
    },
    // swap small amounts in/out
    {
        zeroToOne: true,
        exactOut: false,
        amount0: 1000n,
        comissionOnTransaction: false,
    },
    {
        zeroToOne: true,
        exactOut: false,
        amount0: 1000n,
        comissionOnTransaction: true,
    },
    {
        zeroToOne: true,
        exactOut: false,
        amount0: 1n,
        comissionOnTransaction: true,
    },
    {
        zeroToOne: false,
        exactOut: false,
        amount1: 1000n,
        comissionOnTransaction: false,
    },
    {
        zeroToOne: false,
        exactOut: false,
        amount1: 1n,
        comissionOnTransaction: false,
    },
    {
        zeroToOne: false,
        exactOut: false,
        amount1: 1000n,
        comissionOnTransaction: true,
    },
    {
        zeroToOne: true,
        exactOut: true,
        amount1: 1000n,
    },
    {
        zeroToOne: false,
        exactOut: true,
        amount0: 1000n,
    },
    // swap arbitrary input to price
    {
        sqrtPriceLimit: (0, utilities_1.encodePriceSqrt)(5, 2),
        zeroToOne: false,
    },
    {
        sqrtPriceLimit: (0, utilities_1.encodePriceSqrt)(2, 5),
        zeroToOne: true,
    },
    {
        sqrtPriceLimit: (0, utilities_1.encodePriceSqrt)(5, 2),
        zeroToOne: true,
    },
    {
        sqrtPriceLimit: (0, utilities_1.encodePriceSqrt)(2, 5),
        zeroToOne: false,
    },
    // swap with incorrect limit price
    {
        sqrtPriceLimit: utilities_1.MAX_SQRT_RATIO,
        zeroToOne: false,
    },
    {
        sqrtPriceLimit: utilities_1.MIN_SQRT_RATIO,
        zeroToOne: true,
    },
    // swap to tick using priceLimit
    {
        targetTick: (0, utilities_1.getMinTick)(utilities_1.TICK_SPACINGS[utilities_1.FeeAmount.MEDIUM]),
        zeroToOne: true,
    },
    {
        targetTick: (0, utilities_1.getMaxTick)(utilities_1.TICK_SPACINGS[utilities_1.FeeAmount.MEDIUM]),
        zeroToOne: false,
    },
];
const TEST_POOLS = [
    {
        description: '1:1 price, 2e18 max range liquidity',
        feeAmount: utilities_1.FeeAmount.MEDIUM,
        tickSpacing: utilities_1.TICK_SPACINGS[utilities_1.FeeAmount.MEDIUM],
        startingPrice: (0, utilities_1.encodePriceSqrt)(1, 1),
        positions: [
            {
                bottomTick: (0, utilities_1.getMinTick)(utilities_1.TICK_SPACINGS[utilities_1.FeeAmount.MEDIUM]),
                topTick: (0, utilities_1.getMaxTick)(utilities_1.TICK_SPACINGS[utilities_1.FeeAmount.MEDIUM]),
                liquidity: (0, utilities_1.expandTo18Decimals)(2),
            },
        ],
    },
    {
        description: '10:1 price, 2e18 max range liquidity',
        feeAmount: utilities_1.FeeAmount.MEDIUM,
        tickSpacing: utilities_1.TICK_SPACINGS[utilities_1.FeeAmount.MEDIUM],
        startingPrice: (0, utilities_1.encodePriceSqrt)(10, 1),
        positions: [
            {
                bottomTick: (0, utilities_1.getMinTick)(utilities_1.TICK_SPACINGS[utilities_1.FeeAmount.MEDIUM]),
                topTick: (0, utilities_1.getMaxTick)(utilities_1.TICK_SPACINGS[utilities_1.FeeAmount.MEDIUM]),
                liquidity: (0, utilities_1.expandTo18Decimals)(2),
            },
        ],
    },
    {
        description: '1:10 price, 2e18 max range liquidity',
        feeAmount: utilities_1.FeeAmount.MEDIUM,
        tickSpacing: utilities_1.TICK_SPACINGS[utilities_1.FeeAmount.MEDIUM],
        startingPrice: (0, utilities_1.encodePriceSqrt)(1, 10),
        positions: [
            {
                bottomTick: (0, utilities_1.getMinTick)(utilities_1.TICK_SPACINGS[utilities_1.FeeAmount.MEDIUM]),
                topTick: (0, utilities_1.getMaxTick)(utilities_1.TICK_SPACINGS[utilities_1.FeeAmount.MEDIUM]),
                liquidity: (0, utilities_1.expandTo18Decimals)(2),
            },
        ],
    },
    {
        description: '1:1 price, 0 liquidity, all liquidity around current price',
        feeAmount: utilities_1.FeeAmount.MEDIUM,
        tickSpacing: utilities_1.TICK_SPACINGS[utilities_1.FeeAmount.MEDIUM],
        startingPrice: (0, utilities_1.encodePriceSqrt)(1, 1),
        positions: [
            {
                bottomTick: (0, utilities_1.getMinTick)(utilities_1.TICK_SPACINGS[utilities_1.FeeAmount.MEDIUM]),
                topTick: -utilities_1.TICK_SPACINGS[utilities_1.FeeAmount.MEDIUM],
                liquidity: (0, utilities_1.expandTo18Decimals)(2),
            },
            {
                bottomTick: utilities_1.TICK_SPACINGS[utilities_1.FeeAmount.MEDIUM],
                topTick: (0, utilities_1.getMaxTick)(utilities_1.TICK_SPACINGS[utilities_1.FeeAmount.MEDIUM]),
                liquidity: (0, utilities_1.expandTo18Decimals)(2),
            },
        ],
    },
    {
        description: '1:1 price, additional liquidity around current price',
        feeAmount: utilities_1.FeeAmount.MEDIUM,
        tickSpacing: utilities_1.TICK_SPACINGS[utilities_1.FeeAmount.MEDIUM],
        startingPrice: (0, utilities_1.encodePriceSqrt)(1, 1),
        positions: [
            {
                bottomTick: (0, utilities_1.getMinTick)(utilities_1.TICK_SPACINGS[utilities_1.FeeAmount.MEDIUM]),
                topTick: (0, utilities_1.getMaxTick)(utilities_1.TICK_SPACINGS[utilities_1.FeeAmount.MEDIUM]),
                liquidity: (0, utilities_1.expandTo18Decimals)(2),
            },
            {
                bottomTick: (0, utilities_1.getMinTick)(utilities_1.TICK_SPACINGS[utilities_1.FeeAmount.MEDIUM]),
                topTick: -utilities_1.TICK_SPACINGS[utilities_1.FeeAmount.MEDIUM],
                liquidity: (0, utilities_1.expandTo18Decimals)(2),
            },
            {
                bottomTick: utilities_1.TICK_SPACINGS[utilities_1.FeeAmount.MEDIUM],
                topTick: (0, utilities_1.getMaxTick)(utilities_1.TICK_SPACINGS[utilities_1.FeeAmount.MEDIUM]),
                liquidity: (0, utilities_1.expandTo18Decimals)(2),
            },
        ],
    },
    {
        description: 'large liquidity around current price (stable swap)',
        feeAmount: utilities_1.FeeAmount.LOW,
        tickSpacing: utilities_1.TICK_SPACINGS[utilities_1.FeeAmount.LOW],
        startingPrice: (0, utilities_1.encodePriceSqrt)(1, 1),
        positions: [
            {
                bottomTick: -utilities_1.TICK_SPACINGS[utilities_1.FeeAmount.LOW],
                topTick: utilities_1.TICK_SPACINGS[utilities_1.FeeAmount.LOW],
                liquidity: (0, utilities_1.expandTo18Decimals)(2),
            },
        ],
    },
    {
        description: 'token0 liquidity only',
        feeAmount: utilities_1.FeeAmount.MEDIUM,
        tickSpacing: utilities_1.TICK_SPACINGS[utilities_1.FeeAmount.MEDIUM],
        startingPrice: (0, utilities_1.encodePriceSqrt)(1, 1),
        positions: [
            {
                bottomTick: 0,
                topTick: 2000 * utilities_1.TICK_SPACINGS[utilities_1.FeeAmount.MEDIUM],
                liquidity: (0, utilities_1.expandTo18Decimals)(2),
            },
        ],
    },
    {
        description: 'token1 liquidity only',
        feeAmount: utilities_1.FeeAmount.MEDIUM,
        tickSpacing: utilities_1.TICK_SPACINGS[utilities_1.FeeAmount.MEDIUM],
        startingPrice: (0, utilities_1.encodePriceSqrt)(1, 1),
        positions: [
            {
                bottomTick: -2000 * utilities_1.TICK_SPACINGS[utilities_1.FeeAmount.MEDIUM],
                topTick: 0,
                liquidity: (0, utilities_1.expandTo18Decimals)(2),
            },
        ],
    },
    {
        description: 'close to max price',
        feeAmount: utilities_1.FeeAmount.MEDIUM,
        tickSpacing: utilities_1.TICK_SPACINGS[utilities_1.FeeAmount.MEDIUM],
        startingPrice: (0, utilities_1.encodePriceSqrt)(2n ** 127n, 1),
        positions: [
            {
                bottomTick: (0, utilities_1.getMinTick)(utilities_1.TICK_SPACINGS[utilities_1.FeeAmount.MEDIUM]),
                topTick: (0, utilities_1.getMaxTick)(utilities_1.TICK_SPACINGS[utilities_1.FeeAmount.MEDIUM]),
                liquidity: (0, utilities_1.expandTo18Decimals)(2),
            },
        ],
    },
    {
        description: 'close to min price',
        feeAmount: utilities_1.FeeAmount.MEDIUM,
        tickSpacing: utilities_1.TICK_SPACINGS[utilities_1.FeeAmount.MEDIUM],
        startingPrice: (0, utilities_1.encodePriceSqrt)(1, 2n ** 127n),
        positions: [
            {
                bottomTick: (0, utilities_1.getMinTick)(utilities_1.TICK_SPACINGS[utilities_1.FeeAmount.MEDIUM]),
                topTick: (0, utilities_1.getMaxTick)(utilities_1.TICK_SPACINGS[utilities_1.FeeAmount.MEDIUM]),
                liquidity: (0, utilities_1.expandTo18Decimals)(2),
            },
        ],
    },
    {
        description: 'max full range liquidity at 1:1 price with default fee',
        feeAmount: utilities_1.FeeAmount.MEDIUM,
        tickSpacing: utilities_1.TICK_SPACINGS[utilities_1.FeeAmount.MEDIUM],
        startingPrice: (0, utilities_1.encodePriceSqrt)(1, 1),
        positions: [
            {
                bottomTick: (0, utilities_1.getMinTick)(utilities_1.TICK_SPACINGS[utilities_1.FeeAmount.MEDIUM]),
                topTick: (0, utilities_1.getMaxTick)(utilities_1.TICK_SPACINGS[utilities_1.FeeAmount.MEDIUM]),
                liquidity: BigInt('40564824043007195767232224305152'),
            },
        ],
    },
    {
        description: 'initialized at the max ratio',
        feeAmount: utilities_1.FeeAmount.MEDIUM,
        tickSpacing: utilities_1.TICK_SPACINGS[utilities_1.FeeAmount.MEDIUM],
        startingPrice: utilities_1.MAX_SQRT_RATIO - 1n,
        positions: [
            {
                bottomTick: (0, utilities_1.getMinTick)(utilities_1.TICK_SPACINGS[utilities_1.FeeAmount.MEDIUM]),
                topTick: (0, utilities_1.getMaxTick)(utilities_1.TICK_SPACINGS[utilities_1.FeeAmount.MEDIUM]),
                liquidity: (0, utilities_1.expandTo18Decimals)(2),
            },
        ],
    },
    {
        description: 'initialized at the min ratio',
        feeAmount: utilities_1.FeeAmount.MEDIUM,
        tickSpacing: utilities_1.TICK_SPACINGS[utilities_1.FeeAmount.MEDIUM],
        startingPrice: utilities_1.MIN_SQRT_RATIO,
        positions: [
            {
                bottomTick: (0, utilities_1.getMinTick)(utilities_1.TICK_SPACINGS[utilities_1.FeeAmount.MEDIUM]),
                topTick: (0, utilities_1.getMaxTick)(utilities_1.TICK_SPACINGS[utilities_1.FeeAmount.MEDIUM]),
                liquidity: (0, utilities_1.expandTo18Decimals)(2),
            },
        ],
    },
];
describe('AlgebraPool swap tests', () => {
    let wallet, other;
    const fixture = async () => {
        const { createPool, token0, token1, swapTargetCallee: swapTarget } = await (0, hardhat_network_helpers_1.loadFixture)(fixtures_1.poolFixture);
        const pool = await createPool();
        const poolFunctions = (0, utilities_1.createPoolFunctions)({
            swapTarget,
            token0,
            token1,
            pool,
        });
        return {
            token0,
            token1,
            swapTarget,
            pool,
            poolFunctions,
        };
    };
    before('get signers', async () => {
        [wallet, other] = await hardhat_1.ethers.getSigners();
    });
    for (const poolCase of TEST_POOLS) {
        const poolCaseFixture = async () => {
            const { token0, token1, swapTarget, pool, poolFunctions } = await (0, hardhat_network_helpers_1.loadFixture)(fixture);
            await pool.initialize(poolCase.startingPrice);
            if (poolCase.tickSpacing != 60)
                await pool.setTickSpacing(poolCase.tickSpacing);
            await pool.setFee(poolCase.feeAmount);
            // mint all positions
            let _positions = [];
            for (const position of poolCase.positions) {
                let _position = { ...position };
                let tx = await poolFunctions.mint(wallet.address, position.bottomTick, position.topTick, position.liquidity);
                let receipt = await tx.wait();
                if (!receipt?.logs)
                    continue;
                for (let log of receipt.logs) {
                    if (!('eventName' in log))
                        continue;
                    if (log.eventName == 'MintResult') {
                        if (log.args) {
                            _position.liquidity = log.args[2];
                        }
                        break;
                    }
                }
                _positions.push(_position);
            }
            const [poolBalance0, poolBalance1] = await Promise.all([
                token0.balanceOf(pool),
                token1.balanceOf(pool),
            ]);
            return {
                token0,
                token1,
                pool,
                poolFunctions,
                poolBalance0,
                poolBalance1,
                swapTarget,
                _positions,
            };
        };
        describe(poolCase.description, () => {
            const setupPool = async (isDefl, zeroToOne) => {
                const { token0, token1, pool, poolFunctions, poolBalance0, poolBalance1, swapTarget, _positions } = await (0, hardhat_network_helpers_1.loadFixture)(poolCaseFixture);
                if (isDefl) {
                    if (zeroToOne)
                        await token0.setDefl();
                    else
                        await token1.setDefl();
                }
                return {
                    token0,
                    token1,
                    pool,
                    poolFunctions,
                    poolBalance0,
                    poolBalance1,
                    swapTarget,
                    _positions,
                };
            };
            let token0;
            let token1;
            let poolBalance0;
            let poolBalance1;
            let pool;
            let swapTarget;
            let poolFunctions;
            let _positions;
            afterEach('check can burn positions', async () => {
                for (const { liquidity, topTick, bottomTick } of _positions) {
                    await pool.burn(bottomTick, topTick, liquidity, '0x');
                    await pool.collect(POSITION_PROCEEDS_OUTPUT_ADDRESS, bottomTick, topTick, utilities_1.MaxUint128, utilities_1.MaxUint128);
                }
            });
            for (const testCase of poolCase.swapTests ?? DEFAULT_POOL_SWAP_TESTS) {
                it(swapCaseToDescription(testCase), async () => {
                    let withComission = 'comissionOnTransaction' in testCase && testCase.comissionOnTransaction;
                    ({ token0, token1, pool, poolFunctions, poolBalance0, poolBalance1, swapTarget, _positions } =
                        await setupPool(withComission, testCase.zeroToOne));
                    const globalState = await pool.globalState();
                    const tx = executeSwap(testCase, poolFunctions, swapTarget);
                    try {
                        await tx;
                    }
                    catch (error) {
                        (0, expect_1.expect)({
                            swapError: error.message,
                            poolBalance0: poolBalance0.toString(),
                            poolBalance1: poolBalance1.toString(),
                            poolPriceBefore: (0, format_1.formatPrice)(globalState.price),
                            tickBefore: globalState.tick,
                        }).to.matchSnapshot('swap error');
                        return;
                    }
                    const [poolBalance0After, poolBalance1After, globalStateAfter, liquidityAfter, totalFeeGrowth0Token, totalFeeGrowth1Token,] = await Promise.all([
                        token0.balanceOf(pool),
                        token1.balanceOf(pool),
                        pool.globalState(),
                        pool.liquidity(),
                        pool.totalFeeGrowth0Token(),
                        pool.totalFeeGrowth1Token(),
                    ]);
                    const poolBalance0Delta = poolBalance0After - poolBalance0;
                    const poolBalance1Delta = poolBalance1After - poolBalance1;
                    // check all the events were emitted corresponding to balance changes
                    if (!withComission) {
                        if (poolBalance0Delta == 0n)
                            await (0, expect_1.expect)(tx).to.not.emit(token0, 'Transfer');
                        else if (poolBalance0Delta < 0n)
                            await (0, expect_1.expect)(tx)
                                .to.emit(token0, 'Transfer')
                                .withArgs(await pool.getAddress(), SWAP_RECIPIENT_ADDRESS, poolBalance0Delta * -1n);
                        else
                            await (0, expect_1.expect)(tx).to.emit(token0, 'Transfer').withArgs(wallet.address, await pool.getAddress(), poolBalance0Delta);
                        if (poolBalance1Delta == 0n)
                            await (0, expect_1.expect)(tx).to.not.emit(token1, 'Transfer');
                        else if (poolBalance1Delta < 0n)
                            await (0, expect_1.expect)(tx)
                                .to.emit(token1, 'Transfer')
                                .withArgs(await pool.getAddress(), SWAP_RECIPIENT_ADDRESS, poolBalance1Delta * -1n);
                        else
                            await (0, expect_1.expect)(tx).to.emit(token1, 'Transfer').withArgs(wallet.address, await pool.getAddress(), poolBalance1Delta);
                    }
                    // check that the swap event was emitted too
                    await (0, expect_1.expect)(tx)
                        .to.emit(pool, 'Swap')
                        .withArgs(await swapTarget.getAddress(), SWAP_RECIPIENT_ADDRESS, poolBalance0Delta, poolBalance1Delta, globalStateAfter.price, liquidityAfter, globalStateAfter.tick);
                    const executionPrice = new decimal_js_1.Decimal(poolBalance1Delta.toString()).div(poolBalance0Delta.toString()).mul(-1);
                    (0, expect_1.expect)({
                        amount0Before: poolBalance0.toString(),
                        amount1Before: poolBalance1.toString(),
                        amount0Delta: poolBalance0Delta.toString(),
                        amount1Delta: poolBalance1Delta.toString(),
                        totalFeeGrowth0TokenDelta: totalFeeGrowth0Token.toString(),
                        totalFeeGrowth1TokenDelta: totalFeeGrowth1Token.toString(),
                        tickBefore: globalState.tick,
                        poolPriceBefore: (0, format_1.formatPrice)(globalState.price),
                        tickAfter: globalStateAfter.tick,
                        poolPriceAfter: (0, format_1.formatPrice)(globalStateAfter.price),
                        executionPrice: executionPrice.toPrecision(5),
                    }).to.matchSnapshot('balances');
                });
            }
        });
    }
});
