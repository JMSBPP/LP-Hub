"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
const ethers_1 = require("ethers");
const hardhat_1 = require("hardhat");
const hardhat_network_helpers_1 = require("@nomicfoundation/hardhat-network-helpers");
const expect_1 = require("./shared/expect");
describe('AlgebraCommunityVault', () => {
    let wallet, other, third;
    let factory;
    let poolDeployer;
    let vault;
    let token0;
    let token1;
    const AMOUNT = 10n ** 18n;
    const fixture = async () => {
        const [deployer] = await hardhat_1.ethers.getSigners();
        // precompute
        const poolDeployerAddress = (0, ethers_1.getCreateAddress)({
            from: deployer.address,
            nonce: (await hardhat_1.ethers.provider.getTransactionCount(deployer.address)) + 1,
        });
        const factoryFactory = await hardhat_1.ethers.getContractFactory('AlgebraFactory');
        const _factory = (await factoryFactory.deploy(poolDeployerAddress));
        const poolDeployerFactory = await hardhat_1.ethers.getContractFactory('AlgebraPoolDeployer');
        poolDeployer = (await poolDeployerFactory.deploy(_factory));
        const vaultFactory = await hardhat_1.ethers.getContractFactory('AlgebraCommunityVault');
        vault = (await vaultFactory.deploy(_factory, deployer.address));
        const vaultFactoryStubFactory = await hardhat_1.ethers.getContractFactory('AlgebraVaultFactoryStub');
        const vaultFactoryStub = await vaultFactoryStubFactory.deploy(vault);
        await _factory.setVaultFactory(vaultFactoryStub);
        const tokenFactory = await hardhat_1.ethers.getContractFactory('TestERC20');
        token0 = (await tokenFactory.deploy(2n ** 255n));
        token1 = (await tokenFactory.deploy(2n ** 255n));
        return _factory;
    };
    before('create fixture loader', async () => {
        [wallet, other, third] = await hardhat_1.ethers.getSigners();
    });
    beforeEach('add tokens to vault', async () => {
        factory = await (0, hardhat_network_helpers_1.loadFixture)(fixture);
        await token0.transfer(vault, AMOUNT);
        await token1.transfer(vault, AMOUNT);
    });
    describe('#Withdraw', async () => {
        describe('successful cases', async () => {
            let communityFeeReceiver;
            beforeEach('set communityFee receiver', async () => {
                communityFeeReceiver = wallet.address;
                await vault.changeCommunityFeeReceiver(communityFeeReceiver);
                await vault.transferAlgebraFeeManagerRole(other.address);
                await vault.connect(other).acceptAlgebraFeeManagerRole();
            });
            describe('Algebra fee off', async () => {
                it('withdraw works', async () => {
                    let balanceBefore = await token0.balanceOf(communityFeeReceiver);
                    await vault.withdraw(token0, AMOUNT);
                    let balanceAfter = await token0.balanceOf(communityFeeReceiver);
                    (0, expect_1.expect)(balanceAfter - balanceBefore).to.eq(AMOUNT);
                });
                it('algebra fee manager can withdraw', async () => {
                    let balanceBefore = await token0.balanceOf(communityFeeReceiver);
                    const _vault = vault.connect(third);
                    await (0, expect_1.expect)(_vault.withdraw(token0, AMOUNT)).to.be.reverted;
                    await _vault.connect(other).withdraw(token0, AMOUNT);
                    let balanceAfter = await token0.balanceOf(communityFeeReceiver);
                    (0, expect_1.expect)(balanceAfter - balanceBefore).to.eq(AMOUNT);
                });
                it('withdrawTokens works', async () => {
                    let balance0Before = await token0.balanceOf(communityFeeReceiver);
                    let balance1Before = await token1.balanceOf(communityFeeReceiver);
                    await vault.withdrawTokens([
                        {
                            token: token0,
                            amount: AMOUNT,
                        },
                        {
                            token: token1,
                            amount: AMOUNT,
                        },
                    ]);
                    let balance0After = await token0.balanceOf(communityFeeReceiver);
                    let balance1After = await token1.balanceOf(communityFeeReceiver);
                    (0, expect_1.expect)(balance0After - balance0Before).to.eq(AMOUNT);
                    (0, expect_1.expect)(balance1After - balance1Before).to.eq(AMOUNT);
                });
            });
            describe('Algebra fee on', async () => {
                let algebraFeeReceiver;
                const ALGEBRA_FEE = 100n; // 10%
                beforeEach('turn on algebra fee', async () => {
                    algebraFeeReceiver = other.address;
                    await vault.connect(other).changeAlgebraFeeReceiver(algebraFeeReceiver);
                    await vault.connect(other).proposeAlgebraFeeChange(ALGEBRA_FEE);
                    await vault.acceptAlgebraFeeChangeProposal(ALGEBRA_FEE);
                });
                it('withdraw works', async () => {
                    let balanceBefore = await token0.balanceOf(communityFeeReceiver);
                    let balanceAlgebraBefore = await token0.balanceOf(algebraFeeReceiver);
                    await vault.withdraw(token0, AMOUNT);
                    let balanceAfter = await token0.balanceOf(communityFeeReceiver);
                    let balanceAlgebraAfter = await token0.balanceOf(algebraFeeReceiver);
                    (0, expect_1.expect)(balanceAfter - balanceBefore).to.eq(AMOUNT - (AMOUNT * ALGEBRA_FEE) / 1000n);
                    (0, expect_1.expect)(balanceAlgebraAfter - balanceAlgebraBefore).to.eq((AMOUNT * ALGEBRA_FEE) / 1000n);
                });
                it('algebra fee manager can withdraw', async () => {
                    let balanceBefore = await token0.balanceOf(communityFeeReceiver);
                    let balanceAlgebraBefore = await token0.balanceOf(algebraFeeReceiver);
                    const _vault = vault.connect(third);
                    await (0, expect_1.expect)(_vault.withdraw(token0, AMOUNT)).to.be.reverted;
                    await _vault.connect(other).withdraw(token0, AMOUNT);
                    let balanceAfter = await token0.balanceOf(communityFeeReceiver);
                    let balanceAlgebraAfter = await token0.balanceOf(algebraFeeReceiver);
                    (0, expect_1.expect)(balanceAfter - balanceBefore).to.eq(AMOUNT - (AMOUNT * ALGEBRA_FEE) / 1000n);
                    (0, expect_1.expect)(balanceAlgebraAfter - balanceAlgebraBefore).to.eq((AMOUNT * ALGEBRA_FEE) / 1000n);
                });
                it('withdrawTokens works', async () => {
                    let balance0Before = await token0.balanceOf(communityFeeReceiver);
                    let balance1Before = await token1.balanceOf(communityFeeReceiver);
                    let balance0AlgebraBefore = await token0.balanceOf(algebraFeeReceiver);
                    let balance1AlgebraBefore = await token1.balanceOf(algebraFeeReceiver);
                    await vault.withdrawTokens([
                        {
                            token: token0,
                            amount: AMOUNT,
                        },
                        {
                            token: token1,
                            amount: AMOUNT,
                        },
                    ]);
                    let balance0After = await token0.balanceOf(communityFeeReceiver);
                    let balance1After = await token1.balanceOf(communityFeeReceiver);
                    let balance0AlgebraAfter = await token0.balanceOf(algebraFeeReceiver);
                    let balance1AlgebraAfter = await token1.balanceOf(algebraFeeReceiver);
                    (0, expect_1.expect)(balance0After - balance0Before).to.eq(AMOUNT - (AMOUNT * ALGEBRA_FEE) / 1000n);
                    (0, expect_1.expect)(balance1After - balance1Before).to.eq(AMOUNT - (AMOUNT * ALGEBRA_FEE) / 1000n);
                    (0, expect_1.expect)(balance0AlgebraAfter - balance0AlgebraBefore).to.eq((AMOUNT * ALGEBRA_FEE) / 1000n);
                    (0, expect_1.expect)(balance1AlgebraAfter - balance1AlgebraBefore).to.eq((AMOUNT * ALGEBRA_FEE) / 1000n);
                });
            });
        });
        describe('failing cases', async () => {
            it('withdraw onlyWithdrawer', async () => {
                await vault.changeCommunityFeeReceiver(wallet.address);
                (0, expect_1.expect)(await vault.communityFeeReceiver()).to.be.eq(wallet.address);
                await (0, expect_1.expect)(vault.connect(other).withdraw(token0, AMOUNT)).to.be.revertedWith('only withdrawer');
            });
            it('cannot withdraw without communityFeeReceiver', async () => {
                await (0, expect_1.expect)(vault.withdraw(token0, AMOUNT)).to.be.revertedWith('invalid receiver');
            });
            it('withdrawTokens onlyWithdrawer', async () => {
                await vault.changeCommunityFeeReceiver(wallet.address);
                (0, expect_1.expect)(await vault.communityFeeReceiver()).to.be.eq(wallet.address);
                await (0, expect_1.expect)(vault.connect(other).withdrawTokens([
                    {
                        token: token0,
                        amount: AMOUNT,
                    },
                ])).to.be.reverted;
            });
            it('cannot withdrawTokens without communityFeeReceiver', async () => {
                await (0, expect_1.expect)(vault.withdrawTokens([
                    {
                        token: token0,
                        amount: AMOUNT,
                    },
                ])).to.be.revertedWith('invalid receiver');
            });
            describe('Algebra fee on', async () => {
                const ALGEBRA_FEE = 100n; // 10%
                beforeEach('turn on algebra fee', async () => {
                    await vault.proposeAlgebraFeeChange(ALGEBRA_FEE);
                    await vault.acceptAlgebraFeeChangeProposal(ALGEBRA_FEE);
                });
                it('cannot withdraw without algebraFeeReceiver', async () => {
                    await vault.changeCommunityFeeReceiver(wallet.address);
                    (0, expect_1.expect)(await vault.communityFeeReceiver()).to.be.eq(wallet.address);
                    await (0, expect_1.expect)(vault.withdraw(token0, AMOUNT)).to.be.revertedWith('invalid algebra fee receiver');
                });
                it('cannot withdrawTokens without algebraFeeReceiver', async () => {
                    await vault.changeCommunityFeeReceiver(wallet.address);
                    (0, expect_1.expect)(await vault.communityFeeReceiver()).to.be.eq(wallet.address);
                    await (0, expect_1.expect)(vault.withdrawTokens([
                        {
                            token: token0,
                            amount: AMOUNT,
                        },
                    ])).to.be.revertedWith('invalid algebra fee receiver');
                });
            });
        });
    });
    describe('#FactoryOwner permissioned actions', async () => {
        const ALGEBRA_FEE = 100n; // 10%
        it('can accept fee change proposal', async () => {
            await vault.proposeAlgebraFeeChange(ALGEBRA_FEE);
            await vault.acceptAlgebraFeeChangeProposal(ALGEBRA_FEE);
            (0, expect_1.expect)(await vault.algebraFee()).to.be.eq(ALGEBRA_FEE);
            (0, expect_1.expect)(await vault.hasNewAlgebraFeeProposal()).to.be.eq(false);
        });
        it('only community vault administrator can accept fee change proposal', async () => {
            await vault.proposeAlgebraFeeChange(ALGEBRA_FEE);
            await (0, expect_1.expect)(vault.connect(other).acceptAlgebraFeeChangeProposal(ALGEBRA_FEE)).to.be.revertedWith('only administrator');
            await (0, expect_1.expect)(vault.acceptAlgebraFeeChangeProposal(ALGEBRA_FEE)).to.not.be.reverted;
        });
        it('can not accept invalid fee change proposal', async () => {
            await vault.proposeAlgebraFeeChange(ALGEBRA_FEE);
            await (0, expect_1.expect)(vault.acceptAlgebraFeeChangeProposal(ALGEBRA_FEE - 1n)).to.be.revertedWith('invalid new fee');
        });
        it('can not accept fee if nothing proposed', async () => {
            await (0, expect_1.expect)(vault.acceptAlgebraFeeChangeProposal(ALGEBRA_FEE)).to.be.revertedWith('not proposed');
        });
        it('can change communityFeeReceiver', async () => {
            await vault.changeCommunityFeeReceiver(other.address);
            (0, expect_1.expect)(await vault.communityFeeReceiver()).to.be.eq(other.address);
        });
        it('can not change communityFeeReceiver to zero address', async () => {
            await (0, expect_1.expect)(vault.changeCommunityFeeReceiver(ethers_1.ZeroAddress)).to.be.reverted;
        });
        it('can not change communityFeeReceiver to same address', async () => {
            await vault.changeCommunityFeeReceiver(other.address);
            await (0, expect_1.expect)(vault.changeCommunityFeeReceiver(other.address)).to.be.reverted;
        });
        it('only administrator can change communityFeeReceiver', async () => {
            await (0, expect_1.expect)(vault.connect(other).changeCommunityFeeReceiver(other.address)).to.be.revertedWith('only administrator');
        });
    });
    describe('#AlgebraFeeManager permissioned actions', async () => {
        const ALGEBRA_FEE = 100n; // 10%
        it('can transfer AlgebraFeeManager role', async () => {
            await vault.transferAlgebraFeeManagerRole(other.address);
            await vault.connect(other).acceptAlgebraFeeManagerRole();
            (0, expect_1.expect)(await vault.algebraFeeManager()).to.be.eq(other.address);
        });
        it('only pending newAlgebraFeeManager can accept AlgebraFeeManager role', async () => {
            await vault.transferAlgebraFeeManagerRole(other.address);
            await (0, expect_1.expect)(vault.acceptAlgebraFeeManagerRole()).to.be.reverted;
            await (0, expect_1.expect)(vault.connect(other).acceptAlgebraFeeManagerRole()).to.not.be.reverted;
        });
        it('only AlgebraFeeManager can transfer AlgebraFeeManager role', async () => {
            await (0, expect_1.expect)(vault.connect(other).transferAlgebraFeeManagerRole(other.address)).to.be.revertedWith('only algebra fee manager');
        });
        it('can change AlgebraFeeReceiver', async () => {
            await (0, expect_1.expect)(vault.connect(other).changeAlgebraFeeReceiver(other.address)).to.be.revertedWith('only algebra fee manager');
            await (0, expect_1.expect)(vault.changeAlgebraFeeReceiver(ethers_1.ZeroAddress)).to.be.reverted;
            await vault.changeAlgebraFeeReceiver(other.address);
            (0, expect_1.expect)(await vault.algebraFeeReceiver()).to.be.eq(other.address);
            await (0, expect_1.expect)(vault.changeAlgebraFeeReceiver(other.address)).to.be.reverted;
        });
        it('can propose new fee and cancel proposal', async () => {
            (0, expect_1.expect)(await vault.proposedNewAlgebraFee()).to.be.eq(0);
            (0, expect_1.expect)(await vault.hasNewAlgebraFeeProposal()).to.be.eq(false);
            await (0, expect_1.expect)(vault.connect(other).proposeAlgebraFeeChange(ALGEBRA_FEE)).to.be.revertedWith('only algebra fee manager');
            await (0, expect_1.expect)(vault.proposeAlgebraFeeChange(1001)).to.be.reverted;
            await vault.proposeAlgebraFeeChange(ALGEBRA_FEE);
            await (0, expect_1.expect)(vault.proposeAlgebraFeeChange(ALGEBRA_FEE)).to.be.reverted;
            (0, expect_1.expect)(await vault.proposedNewAlgebraFee()).to.be.eq(ALGEBRA_FEE);
            (0, expect_1.expect)(await vault.hasNewAlgebraFeeProposal()).to.be.eq(true);
            await (0, expect_1.expect)(vault.connect(other).cancelAlgebraFeeChangeProposal()).to.be.revertedWith('only algebra fee manager');
            await vault.cancelAlgebraFeeChangeProposal();
            (0, expect_1.expect)(await vault.proposedNewAlgebraFee()).to.be.eq(0);
            (0, expect_1.expect)(await vault.hasNewAlgebraFeeProposal()).to.be.eq(false);
            await vault.proposeAlgebraFeeChange(ALGEBRA_FEE);
            await vault.acceptAlgebraFeeChangeProposal(ALGEBRA_FEE);
            await (0, expect_1.expect)(vault.proposeAlgebraFeeChange(ALGEBRA_FEE)).to.be.reverted;
        });
    });
});
