"use strict";
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
const ethers_1 = require("ethers");
const hardhat_1 = require("hardhat");
const hardhat_network_helpers_1 = require("@nomicfoundation/hardhat-network-helpers");
const expect_1 = require("./shared/expect");
const fixtures_1 = require("./shared/fixtures");
const snapshotGasCost_1 = __importDefault(require("./shared/snapshotGasCost"));
const utilities_1 = require("./shared/utilities");
const TEST_ADDRESSES = [
    '0x1000000000000000000000000000000000000000',
    '0x2000000000000000000000000000000000000000',
    '0x3000000000000000000000000000000000000000',
];
describe('AlgebraFactory', () => {
    let wallet, other;
    let factory;
    let poolDeployer;
    let poolBytecode;
    let defaultPluginFactory;
    const fixture = async () => {
        const [deployer] = await hardhat_1.ethers.getSigners();
        // precompute
        const poolDeployerAddress = (0, ethers_1.getCreateAddress)({
            from: deployer.address,
            nonce: (await hardhat_1.ethers.provider.getTransactionCount(deployer.address)) + 1,
        });
        const factoryFactory = await hardhat_1.ethers.getContractFactory('AlgebraFactory');
        const factory = (await factoryFactory.deploy(poolDeployerAddress));
        const poolDeployerFactory = await hardhat_1.ethers.getContractFactory('AlgebraPoolDeployer');
        const poolDeployer = (await poolDeployerFactory.deploy(factory));
        const vaultFactory = await hardhat_1.ethers.getContractFactory('AlgebraCommunityVault');
        const vault = await vaultFactory.deploy(factory, deployer.address);
        const vaultFactoryStubFactory = await hardhat_1.ethers.getContractFactory('AlgebraVaultFactoryStub');
        const vaultFactoryStub = await vaultFactoryStubFactory.deploy(vault);
        await factory.setVaultFactory(vaultFactoryStub);
        const defaultPluginFactoryFactory = await hardhat_1.ethers.getContractFactory('MockDefaultPluginFactory');
        const defaultPluginFactory = (await defaultPluginFactoryFactory.deploy());
        return { factory, poolDeployer, defaultPluginFactory };
    };
    before('create fixture loader', async () => {
        [wallet, other] = await hardhat_1.ethers.getSigners();
    });
    before('load pool bytecode', async () => {
        poolBytecode = (await hardhat_1.ethers.getContractFactory('AlgebraPool')).bytecode;
    });
    beforeEach('deploy factory', async () => {
        ({ factory, poolDeployer, defaultPluginFactory } = await (0, hardhat_network_helpers_1.loadFixture)(fixture));
    });
    it('cannot create invalid vault factory stub', async () => {
        const vaultFactoryStubFactory = await hardhat_1.ethers.getContractFactory('AlgebraVaultFactoryStub');
        (0, expect_1.expect)(vaultFactoryStubFactory.deploy(ethers_1.ZeroAddress)).to.be.revertedWithoutReason;
    });
    it('owner is deployer', async () => {
        (0, expect_1.expect)(await factory.owner()).to.eq(wallet.address);
    });
    it('has POOL_INIT_CODE_HASH', async () => {
        (0, expect_1.expect)(await factory.POOL_INIT_CODE_HASH()).to.be.not.eq('0x0000000000000000000000000000000000000000000000000000000000000000');
    });
    it('has POOLS_ADMINISTRATOR_ROLE', async () => {
        (0, expect_1.expect)(await factory.POOLS_ADMINISTRATOR_ROLE()).to.be.eq('0xb73ce166ead2f8e9add217713a7989e4edfba9625f71dfd2516204bb67ad3442');
    });
    it('has correct POOL_INIT_CODE_HASH [ @skip-on-coverage ]', async () => {
        (0, expect_1.expect)(await factory.POOL_INIT_CODE_HASH()).to.be.eq((0, ethers_1.keccak256)(poolBytecode));
    });
    it('cannot deploy factory with incorrect poolDeployer', async () => {
        const factoryFactory = await hardhat_1.ethers.getContractFactory('AlgebraFactory');
        (0, expect_1.expect)(factoryFactory.deploy(ethers_1.ZeroAddress)).to.be.revertedWithoutReason;
    });
    it('factory bytecode size  [ @skip-on-coverage ]', async () => {
        (0, expect_1.expect)(((await hardhat_1.ethers.provider.getCode(factory)).length - 2) / 2).to.matchSnapshot();
    });
    it('pool bytecode size  [ @skip-on-coverage ]', async () => {
        await factory.createPool(TEST_ADDRESSES[0], TEST_ADDRESSES[1], '0x');
        const poolAddress = (0, utilities_1.getCreate2Address)(await poolDeployer.getAddress(), [TEST_ADDRESSES[0], TEST_ADDRESSES[1]], poolBytecode);
        (0, expect_1.expect)(((await hardhat_1.ethers.provider.getCode(poolAddress)).length - 2) / 2).to.matchSnapshot();
    });
    async function createAndCheckPool(tokens) {
        const create2Address = (0, utilities_1.getCreate2Address)(await poolDeployer.getAddress(), tokens, poolBytecode);
        const create = factory.createPool(tokens[0], tokens[1], '0x');
        await (0, expect_1.expect)(create).to.emit(factory, 'Pool');
        await (0, expect_1.expect)(factory.createPool(tokens[0], tokens[1], '0x')).to.be.reverted;
        await (0, expect_1.expect)(factory.createPool(tokens[1], tokens[0], '0x')).to.be.reverted;
        (0, expect_1.expect)(await factory.poolByPair(tokens[0], tokens[1]), 'getPool in order').to.eq(create2Address);
        (0, expect_1.expect)(await factory.poolByPair(tokens[1], tokens[0]), 'getPool in reverse').to.eq(create2Address);
        const poolContractFactory = await hardhat_1.ethers.getContractFactory('AlgebraPool');
        const pool = poolContractFactory.attach(create2Address);
        (0, expect_1.expect)(await pool.factory(), 'pool factory address').to.eq(await factory.getAddress());
        (0, expect_1.expect)(await pool.token0(), 'pool token0').to.eq(TEST_ADDRESSES[0]);
        (0, expect_1.expect)(await pool.token1(), 'pool token1').to.eq(TEST_ADDRESSES[1]);
    }
    describe('#createPool', () => {
        it('succeeds for pool', async () => {
            await createAndCheckPool([TEST_ADDRESSES[0], TEST_ADDRESSES[1]]);
        });
        it('succeeds if tokens are passed in reverse', async () => {
            await createAndCheckPool([TEST_ADDRESSES[1], TEST_ADDRESSES[0]]);
        });
        it('correctly computes pool address [ @skip-on-coverage ]', async () => {
            await factory.setDefaultPluginFactory(defaultPluginFactory);
            await createAndCheckPool([TEST_ADDRESSES[0], TEST_ADDRESSES[1]]);
            let poolAddress = await factory.poolByPair(TEST_ADDRESSES[0], TEST_ADDRESSES[1]);
            const addressCalculatedByFactory = await factory.computePoolAddress(TEST_ADDRESSES[0], TEST_ADDRESSES[1]);
            (0, expect_1.expect)(addressCalculatedByFactory).to.be.eq(poolAddress);
        });
        it('succeeds if defaultPluginFactory set [ @skip-on-coverage ]', async () => {
            await factory.setDefaultPluginFactory(defaultPluginFactory);
            await createAndCheckPool([TEST_ADDRESSES[0], TEST_ADDRESSES[1]]);
            let poolAddress = await factory.poolByPair(TEST_ADDRESSES[0], TEST_ADDRESSES[1]);
            let pluginAddress = await defaultPluginFactory.pluginsForPools(poolAddress);
            const poolContractFactory = await hardhat_1.ethers.getContractFactory('AlgebraPool');
            let pool = poolContractFactory.attach(poolAddress);
            (0, expect_1.expect)(await pool.plugin()).to.be.eq(pluginAddress);
        });
        it('creates plugin in defaultPluginFactory', async () => {
            await factory.setDefaultPluginFactory(defaultPluginFactory);
            await createAndCheckPool([TEST_ADDRESSES[0], TEST_ADDRESSES[1]]);
            let poolAddress = await factory.poolByPair(TEST_ADDRESSES[0], TEST_ADDRESSES[1]);
            // in coverage mode bytecode hash can be different from specified in factory
            let pluginAddress = await defaultPluginFactory.pluginsForPools(await factory.computePoolAddress(TEST_ADDRESSES[0], TEST_ADDRESSES[1]));
            const poolContractFactory = await hardhat_1.ethers.getContractFactory('AlgebraPool');
            let pool = poolContractFactory.attach(poolAddress);
            (0, expect_1.expect)(await pool.plugin()).to.be.eq(pluginAddress);
        });
        it('data passed to defaultPluginFactory', async () => {
            await factory.setDefaultPluginFactory(defaultPluginFactory);
            const create = factory.createPool(TEST_ADDRESSES[0], TEST_ADDRESSES[1], '0x0200');
            await (0, expect_1.expect)(create).to.emit(defaultPluginFactory, 'DataOnPoolCreation').withArgs('0x0200');
        });
        it('sets vault in pool', async () => {
            await createAndCheckPool([TEST_ADDRESSES[0], TEST_ADDRESSES[1]]);
            let poolAddress = await factory.poolByPair(TEST_ADDRESSES[0], TEST_ADDRESSES[1]);
            const poolContractFactory = await hardhat_1.ethers.getContractFactory('AlgebraPool');
            let pool = poolContractFactory.attach(poolAddress);
            await pool.initialize((0, utilities_1.encodePriceSqrt)(1, 1));
            (0, expect_1.expect)(await pool.communityVault()).to.not.eq(ethers_1.ZeroAddress);
        });
        it('works without community vault factory', async () => {
            await factory.setVaultFactory(ethers_1.ZeroAddress);
            await createAndCheckPool([TEST_ADDRESSES[0], TEST_ADDRESSES[1]]);
            let poolAddress = await factory.poolByPair(TEST_ADDRESSES[0], TEST_ADDRESSES[1]);
            const poolContractFactory = await hardhat_1.ethers.getContractFactory('AlgebraPool');
            let pool = poolContractFactory.attach(poolAddress);
            await pool.initialize((0, utilities_1.encodePriceSqrt)(1, 1));
            (0, expect_1.expect)(await pool.communityVault()).to.eq(ethers_1.ZeroAddress);
        });
        it('fails if trying to create via pool deployer directly', async () => {
            await (0, expect_1.expect)(poolDeployer.deploy(TEST_ADDRESSES[0], TEST_ADDRESSES[0], TEST_ADDRESSES[0], TEST_ADDRESSES[0])).to
                .be.reverted;
        });
        it('fails if token a == token b', async () => {
            await (0, expect_1.expect)(factory.createPool(TEST_ADDRESSES[0], TEST_ADDRESSES[0], '0x')).to.be.reverted;
        });
        it('fails if token a is 0 or token b is 0', async () => {
            await (0, expect_1.expect)(factory.createPool(TEST_ADDRESSES[0], ethers_1.ZeroAddress, '0x')).to.be.reverted;
            await (0, expect_1.expect)(factory.createPool(ethers_1.ZeroAddress, TEST_ADDRESSES[0], '0x')).to.be.reverted;
            (0, expect_1.expect)(factory.createPool(ethers_1.ZeroAddress, ethers_1.ZeroAddress, '0x')).to.be.revertedWithoutReason;
        });
        it('gas [ @skip-on-coverage ]', async () => {
            await (0, snapshotGasCost_1.default)(factory.createPool(TEST_ADDRESSES[0], TEST_ADDRESSES[1], '0x'));
        });
        it('gas for second pool [ @skip-on-coverage ]', async () => {
            await factory.createPool(TEST_ADDRESSES[0], TEST_ADDRESSES[1], '0x');
            await (0, snapshotGasCost_1.default)(factory.createPool(TEST_ADDRESSES[0], TEST_ADDRESSES[2], '0x'));
        });
    });
    describe('#createCustomPool', () => {
        let customPoolCreator;
        async function createAndCheckCustomPool(_factory, tokens, data = '0x') {
            const create2Address = (0, utilities_1.getCreate2CustomAddress)(await poolDeployer.getAddress(), await customPoolCreator.getAddress(), tokens, poolBytecode);
            const create = customPoolCreator.createCustomPool(_factory, tokens[0], tokens[1], data);
            await (0, expect_1.expect)(create).to.emit(_factory, 'CustomPool');
            await (0, expect_1.expect)(create).to.emit(customPoolCreator, 'BeforeCreateHook');
            await (0, expect_1.expect)(customPoolCreator.createCustomPool(_factory, tokens[0], tokens[1], data)).to.be.reverted;
            await (0, expect_1.expect)(customPoolCreator.createCustomPool(_factory, tokens[1], tokens[0], data)).to.be.reverted;
            (0, expect_1.expect)(await _factory.customPoolByPair(customPoolCreator, tokens[0], tokens[1]), 'getPool in order').to.eq(create2Address);
            (0, expect_1.expect)(await _factory.customPoolByPair(customPoolCreator, tokens[1], tokens[0]), 'getPool in reverse').to.eq(create2Address);
            const poolContractFactory = await hardhat_1.ethers.getContractFactory('AlgebraPool');
            const pool = poolContractFactory.attach(create2Address);
            (0, expect_1.expect)(await pool.factory(), 'pool factory address').to.eq(await factory.getAddress());
            (0, expect_1.expect)(await pool.token0(), 'pool token0').to.eq(TEST_ADDRESSES[0]);
            (0, expect_1.expect)(await pool.token1(), 'pool token1').to.eq(TEST_ADDRESSES[1]);
        }
        beforeEach('Deploy CustomPoolCreator', async () => {
            const CustomPoolCreator = await hardhat_1.ethers.getContractFactory('MockCustomPoolCreator');
            customPoolCreator = await CustomPoolCreator.deploy();
            const CUSTOM_POOL_DEPLOYER = await factory.CUSTOM_POOL_DEPLOYER();
            await factory.grantRole(CUSTOM_POOL_DEPLOYER, customPoolCreator);
        });
        it('succeeds for pool', async () => {
            await createAndCheckCustomPool(factory, [TEST_ADDRESSES[0], TEST_ADDRESSES[1]]);
        });
        it('succeeds if tokens are passed in reverse', async () => {
            await createAndCheckCustomPool(factory, [TEST_ADDRESSES[1], TEST_ADDRESSES[0]]);
        });
        it('correctly computes pool address [ @skip-on-coverage ]', async () => {
            await createAndCheckCustomPool(factory, [TEST_ADDRESSES[0], TEST_ADDRESSES[1]]);
            let poolAddress = await factory.customPoolByPair(customPoolCreator, TEST_ADDRESSES[0], TEST_ADDRESSES[1]);
            const addressCalculatedByFactory = await factory.computeCustomPoolAddress(customPoolCreator, TEST_ADDRESSES[0], TEST_ADDRESSES[1]);
            (0, expect_1.expect)(addressCalculatedByFactory).to.be.eq(poolAddress);
        });
        it('cannot reenter from custom pool deployer', async () => {
            const reentrant = (await (await hardhat_1.ethers.getContractFactory('TestAlgebraReentrantCallee')).deploy());
            const CUSTOM_POOL_DEPLOYER = await factory.CUSTOM_POOL_DEPLOYER();
            await factory.grantRole(CUSTOM_POOL_DEPLOYER, await reentrant.getAddress());
            // the tests happen in solidity
            await (0, expect_1.expect)(reentrant.createCustomPool(factory, TEST_ADDRESSES[1], TEST_ADDRESSES[2], '0x')).to.be.revertedWith('ReentrancyGuard: reentrant call');
        });
        it('sets vault in pool', async () => {
            await createAndCheckCustomPool(factory, [TEST_ADDRESSES[0], TEST_ADDRESSES[1]]);
            let poolAddress = await factory.customPoolByPair(customPoolCreator, TEST_ADDRESSES[0], TEST_ADDRESSES[1]);
            const poolContractFactory = await hardhat_1.ethers.getContractFactory('AlgebraPool');
            let pool = poolContractFactory.attach(poolAddress);
            await pool.initialize((0, utilities_1.encodePriceSqrt)(1, 1));
            (0, expect_1.expect)(await pool.communityVault()).to.not.eq(ethers_1.ZeroAddress);
        });
        it('works without community vault factory', async () => {
            await factory.setVaultFactory(ethers_1.ZeroAddress);
            await createAndCheckCustomPool(factory, [TEST_ADDRESSES[0], TEST_ADDRESSES[1]]);
            let poolAddress = await factory.customPoolByPair(customPoolCreator, TEST_ADDRESSES[0], TEST_ADDRESSES[1]);
            const poolContractFactory = await hardhat_1.ethers.getContractFactory('AlgebraPool');
            let pool = poolContractFactory.attach(poolAddress);
            await pool.initialize((0, utilities_1.encodePriceSqrt)(1, 1));
            (0, expect_1.expect)(await pool.communityVault()).to.eq(ethers_1.ZeroAddress);
        });
        it('fails if trying to create via pool deployer directly', async () => {
            await (0, expect_1.expect)(poolDeployer.deploy(TEST_ADDRESSES[0], TEST_ADDRESSES[0], TEST_ADDRESSES[0], customPoolCreator)).to
                .be.reverted;
        });
        it('fails if token a == token b', async () => {
            await (0, expect_1.expect)(customPoolCreator.createCustomPool(factory, TEST_ADDRESSES[0], TEST_ADDRESSES[0], '0x')).to.be
                .reverted;
        });
        it('fails if token a is 0 or token b is 0', async () => {
            await (0, expect_1.expect)(customPoolCreator.createCustomPool(factory, TEST_ADDRESSES[0], ethers_1.ZeroAddress, '0x')).to.be.reverted;
            await (0, expect_1.expect)(customPoolCreator.createCustomPool(factory, ethers_1.ZeroAddress, TEST_ADDRESSES[0], '0x')).to.be.reverted;
            (0, expect_1.expect)(customPoolCreator.createCustomPool(factory, ethers_1.ZeroAddress, ethers_1.ZeroAddress, '0x')).to.be.revertedWithoutReason;
        });
        it('fails if called by address without a role', async () => {
            await (0, expect_1.expect)(factory.createCustomPool(customPoolCreator, ethers_1.ZeroAddress, TEST_ADDRESSES[0], TEST_ADDRESSES[1], '0x')).to.be.revertedWith('Can`t create custom pools');
        });
        it('gas [ @skip-on-coverage ]', async () => {
            await (0, snapshotGasCost_1.default)(customPoolCreator.createCustomPool(factory, TEST_ADDRESSES[0], TEST_ADDRESSES[1], '0x'));
        });
        it('gas for second pool [ @skip-on-coverage ]', async () => {
            await customPoolCreator.createCustomPool(factory, TEST_ADDRESSES[0], TEST_ADDRESSES[1], '0x');
            await (0, snapshotGasCost_1.default)(customPoolCreator.createCustomPool(factory, TEST_ADDRESSES[0], TEST_ADDRESSES[2], '0x'));
        });
    });
    describe('Pool deployer', () => {
        it('cannot set zero address as factory', async () => {
            const poolDeployerFactory = await hardhat_1.ethers.getContractFactory('AlgebraPoolDeployer');
            await (0, expect_1.expect)(poolDeployerFactory.deploy(ethers_1.ZeroAddress)).to.be.reverted;
        });
    });
    describe('#transferOwnership', () => {
        it('fails if caller is not owner', async () => {
            await (0, expect_1.expect)(factory.connect(other).transferOwnership(wallet.address)).to.be.reverted;
            await (0, expect_1.expect)(factory.connect(other).startRenounceOwnership()).to.be.reverted;
            await (0, expect_1.expect)(factory.connect(other).renounceOwnership()).to.be.reverted;
            await (0, expect_1.expect)(factory.connect(other).stopRenounceOwnership()).to.be.reverted;
        });
        it('updates owner', async () => {
            await factory.transferOwnership(other.address);
            await factory.connect(other).acceptOwnership();
            (0, expect_1.expect)(await factory.owner()).to.eq(other.address);
        });
        it('emits event', async () => {
            await factory.transferOwnership(other.address);
            await (0, expect_1.expect)(factory.connect(other).acceptOwnership())
                .to.emit(factory, 'OwnershipTransferred')
                .withArgs(wallet.address, other.address);
        });
        it('cannot be called by original owner', async () => {
            await factory.transferOwnership(other.address);
            await factory.connect(other).acceptOwnership();
            await (0, expect_1.expect)(factory.transferOwnership(wallet.address)).to.be.reverted;
        });
        it('renounceOwner works correct', async () => {
            await factory.startRenounceOwnership();
            await hardhat_1.ethers.provider.send('evm_increaseTime', [86500]);
            await factory.renounceOwnership();
            (0, expect_1.expect)(await factory.owner()).to.eq('0x0000000000000000000000000000000000000000');
        });
        it('renounceOwner cannot be used before delay', async () => {
            await factory.startRenounceOwnership();
            await (0, expect_1.expect)(factory.renounceOwnership()).to.be.reverted;
        });
        it('startRenounceOwner cannot be used twice in a row', async () => {
            await factory.startRenounceOwnership();
            await (0, expect_1.expect)(factory.startRenounceOwnership()).to.be.reverted;
        });
        it('stopRenounceOwnership works correct', async () => {
            await factory.startRenounceOwnership();
            await factory.stopRenounceOwnership();
            (0, expect_1.expect)(await factory.renounceOwnershipStartTimestamp()).to.eq(0);
        });
        it('stopRenounceOwnership does not works without start', async () => {
            await (0, expect_1.expect)(factory.stopRenounceOwnership()).to.be.reverted;
        });
        it('stopRenounceOwnership emits event', async () => {
            await factory.startRenounceOwnership();
            await (0, expect_1.expect)(factory.stopRenounceOwnership()).to.emit(factory, 'RenounceOwnershipStop');
        });
        it('renounceOwnership does not works without start', async () => {
            await (0, expect_1.expect)(factory.renounceOwnership()).to.be.reverted;
        });
        it('renounceOwner set owner to zero address', async () => {
            await factory.startRenounceOwnership();
            await hardhat_network_helpers_1.time.increase(60 * 60 * 24 * 2);
            await factory.renounceOwnership();
            (0, expect_1.expect)(await factory.owner()).to.be.eq(fixtures_1.ZERO_ADDRESS);
        });
        it('renounceOwner set pending to zero address', async () => {
            await factory.transferOwnership(other.address);
            await factory.startRenounceOwnership();
            await hardhat_network_helpers_1.time.increase(60 * 60 * 24 * 2);
            await factory.renounceOwnership();
            (0, expect_1.expect)(await factory.owner()).to.be.eq(fixtures_1.ZERO_ADDRESS);
            (0, expect_1.expect)(await factory.pendingOwner()).to.be.eq(fixtures_1.ZERO_ADDRESS);
        });
    });
    describe('#setDefaultCommunityFee', () => {
        it('fails if caller is not owner', async () => {
            await (0, expect_1.expect)(factory.connect(other).setDefaultCommunityFee(30)).to.be.reverted;
        });
        it('fails if new community fee greater than max fee', async () => {
            await (0, expect_1.expect)(factory.setDefaultCommunityFee(1100)).to.be.reverted;
        });
        it('fails if new community fee eq current', async () => {
            await (0, expect_1.expect)(factory.setDefaultCommunityFee(0)).to.be.reverted;
        });
        it('fails if community vault factory is zero address', async () => {
            await factory.setVaultFactory(ethers_1.ZeroAddress);
            await (0, expect_1.expect)(factory.setDefaultCommunityFee(60)).to.be.reverted;
        });
        it('works correct', async () => {
            await factory.setDefaultCommunityFee(60);
            (0, expect_1.expect)(await factory.defaultCommunityFee()).to.eq(60);
        });
        it('can set to zero', async () => {
            await factory.setDefaultCommunityFee(60);
            await factory.setDefaultCommunityFee(0);
            (0, expect_1.expect)(await factory.defaultCommunityFee()).to.eq(0);
        });
        it('emits event', async () => {
            await (0, expect_1.expect)(factory.setDefaultCommunityFee(60)).to.emit(factory, 'DefaultCommunityFee').withArgs(60);
        });
        it('emits event when changes to zero', async () => {
            await factory.setDefaultCommunityFee(60);
            await (0, expect_1.expect)(factory.setDefaultCommunityFee(0)).to.emit(factory, 'DefaultCommunityFee').withArgs(0);
        });
    });
    describe('#setDefaultFee', () => {
        it('fails if caller is not owner', async () => {
            await (0, expect_1.expect)(factory.connect(other).setDefaultFee(200)).to.be.reverted;
        });
        it('fails if new default fee greater than max fee', async () => {
            await (0, expect_1.expect)(factory.setDefaultFee(51000)).to.be.reverted;
        });
        it('fails if new default fee eq current', async () => {
            const fee = await factory.defaultFee();
            await (0, expect_1.expect)(factory.setDefaultFee(fee)).to.be.reverted;
        });
        it('works correct', async () => {
            await factory.setDefaultFee(60);
            (0, expect_1.expect)(await factory.defaultFee()).to.eq(60);
        });
        it('emits event', async () => {
            await (0, expect_1.expect)(factory.setDefaultFee(60)).to.emit(factory, 'DefaultFee').withArgs(60);
        });
    });
    describe('#setDefaultTickspacing', () => {
        it('fails if caller is not owner', async () => {
            await (0, expect_1.expect)(factory.connect(other).setDefaultTickspacing(30)).to.be.reverted;
        });
        it('fails if new default tickspacing greater than max & lt min', async () => {
            await (0, expect_1.expect)(factory.setDefaultTickspacing(1100)).to.be.reverted;
            await (0, expect_1.expect)(factory.setDefaultTickspacing(-1100)).to.be.reverted;
        });
        it('fails if new default tickspacing eq current', async () => {
            await (0, expect_1.expect)(factory.setDefaultTickspacing(60)).to.be.reverted;
        });
        it('works correct', async () => {
            await factory.setDefaultTickspacing(50);
            (0, expect_1.expect)(await factory.defaultTickspacing()).to.eq(50);
        });
        it('emits event', async () => {
            await (0, expect_1.expect)(factory.setDefaultTickspacing(50)).to.emit(factory, 'DefaultTickspacing').withArgs(50);
        });
    });
    describe('#setDefaultPluginFactory', () => {
        it('fails if caller is not owner', async () => {
            await (0, expect_1.expect)(factory.connect(other).setDefaultPluginFactory(other.address)).to.be.reverted;
        });
        it('fails if equals current value', async () => {
            await (0, expect_1.expect)(factory.setDefaultPluginFactory(ethers_1.ZeroAddress)).to.be.reverted;
        });
        it('emits event', async () => {
            await (0, expect_1.expect)(factory.setDefaultPluginFactory(other.address))
                .to.emit(factory, 'DefaultPluginFactory')
                .withArgs(other.address);
        });
    });
    describe('#setVaultFactory', () => {
        it('fails if caller is not owner', async () => {
            await (0, expect_1.expect)(factory.connect(other).setVaultFactory(other.address)).to.be.reverted;
        });
        it('fails if equals current value', async () => {
            const vaultFactoryAddress = await factory.vaultFactory();
            await (0, expect_1.expect)(factory.setVaultFactory(vaultFactoryAddress)).to.be.reverted;
        });
        it('fails if tries to set to zero with nonzero default community fee', async () => {
            await factory.setDefaultCommunityFee(60);
            await (0, expect_1.expect)(factory.setVaultFactory(ethers_1.ZeroAddress)).to.be.reverted;
        });
        it('emits event', async () => {
            await (0, expect_1.expect)(factory.setVaultFactory(other.address)).to.emit(factory, 'VaultFactory').withArgs(other.address);
        });
    });
    it('hasRoleOrOwner', async () => {
        (0, expect_1.expect)(await factory.hasRoleOrOwner('0x0000000000000000000000000000000000000000000000000000000000000000', wallet.address)).to.eq(true);
        (0, expect_1.expect)(await factory.hasRoleOrOwner('0x0000000000000000000000000000000000000000000000000000000000000000', other.address)).to.eq(false);
        await factory.grantRole('0x0000000000000000000000000000000000000000000000000000000000000001', other.address);
        (0, expect_1.expect)(await factory.hasRoleOrOwner('0x0000000000000000000000000000000000000000000000000000000000000001', other.address)).to.eq(true);
    });
    it('defaultConfigurationForPool', async () => {
        const { communityFee, tickSpacing, fee } = await factory.defaultConfigurationForPool();
        (0, expect_1.expect)(communityFee).to.eq(0);
        (0, expect_1.expect)(tickSpacing).to.eq(60);
        (0, expect_1.expect)(fee).to.eq(500);
    });
    it('defaultConfigurationForPool works without vault factory', async () => {
        await factory.setVaultFactory(ethers_1.ZeroAddress);
        const { communityFee, tickSpacing, fee } = await factory.defaultConfigurationForPool();
        (0, expect_1.expect)(communityFee).to.eq(0);
        (0, expect_1.expect)(tickSpacing).to.eq(60);
        (0, expect_1.expect)(fee).to.eq(500);
    });
});
