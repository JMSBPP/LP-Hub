"use strict";
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
const hardhat_1 = require("hardhat");
const hardhat_network_helpers_1 = require("@nomicfoundation/hardhat-network-helpers");
const expect_1 = require("./shared/expect");
const fixtures_1 = require("./shared/fixtures");
const snapshotGasCost_1 = __importDefault(require("./shared/snapshotGasCost"));
const utilities_1 = require("./shared/utilities");
describe('AlgebraPool gas tests [ @skip-on-coverage ]', () => {
    let wallet, other;
    before('create fixture loader', async () => {
        [wallet, other] = await hardhat_1.ethers.getSigners();
    });
    describe('#setFee', () => {
        let pool;
        beforeEach('load fixture', async () => {
            const fix = await (0, fixtures_1.poolFixture)();
            pool = await fix.createPool();
            await pool.initialize((0, utilities_1.encodePriceSqrt)(100001, 100000));
        });
        it('by owner', async () => {
            await (0, snapshotGasCost_1.default)(pool.setFee(220));
        });
    });
    for (const communityFee of [0, 500]) {
        describe(communityFee > 0 ? 'fee is on' : 'fee is off', () => {
            const startingPrice = (0, utilities_1.encodePriceSqrt)(100001, 100000);
            const startingTick = 0;
            const tickSpacing = utilities_1.TICK_SPACINGS[utilities_1.FeeAmount.MEDIUM];
            const minTick = (0, utilities_1.getMinTick)(tickSpacing);
            const maxTick = (0, utilities_1.getMaxTick)(tickSpacing);
            const gasTestFixture = async () => {
                const fix = await (0, fixtures_1.poolFixture)();
                const pool = await fix.createPool();
                const { swapExact0For1, swapExact1For0, swapToHigherPrice, mint, swapToLowerPrice } = (0, utilities_1.createPoolFunctions)({
                    swapTarget: fix.swapTargetCallee,
                    token0: fix.token0,
                    token1: fix.token1,
                    pool,
                });
                await pool.initialize((0, utilities_1.encodePriceSqrt)(1, 1));
                if (communityFee != 0)
                    await pool.setCommunityFee(communityFee);
                await pool.advanceTime(1);
                await mint(wallet.address, minTick, maxTick, (0, utilities_1.expandTo18Decimals)(2));
                await swapExact0For1((0, utilities_1.expandTo18Decimals)(1), wallet.address);
                await pool.advanceTime(1);
                await swapToHigherPrice(startingPrice, wallet.address);
                await pool.advanceTime(1);
                (0, expect_1.expect)((await pool.globalState()).tick).to.eq(startingTick);
                (0, expect_1.expect)((await pool.globalState()).price).to.eq(startingPrice);
                return {
                    pool,
                    swapExact0For1,
                    swapExact1For0,
                    mint,
                    swapToHigherPrice,
                    swapToLowerPrice,
                };
            };
            let swapExact0For1;
            let swapExact1For0;
            let swapToHigherPrice;
            let swapToLowerPrice;
            let poolPlugin;
            let pool;
            let mint;
            beforeEach('load the fixture', async () => {
                ({ swapExact0For1, swapExact1For0, pool, mint, swapToHigherPrice, swapToLowerPrice } = await (0, hardhat_network_helpers_1.loadFixture)(gasTestFixture));
            });
            describe('#swapExact1For0', () => {
                it('first swap in block with no tick movement', async () => {
                    await (0, snapshotGasCost_1.default)(swapExact1For0(4000, wallet.address));
                    (0, expect_1.expect)((await pool.globalState()).price).to.not.eq(startingPrice);
                    (0, expect_1.expect)((await pool.globalState()).tick).to.eq(startingTick);
                });
                it('first swap in block moves tick, no initialized crossings', async () => {
                    await (0, snapshotGasCost_1.default)(swapExact1For0((0, utilities_1.expandTo18Decimals)(1) / 10000n, wallet.address));
                    (0, expect_1.expect)((await pool.globalState()).tick).to.eq(startingTick + 1);
                });
                it('second swap in block with no tick movement', async () => {
                    await swapExact1For0((0, utilities_1.expandTo18Decimals)(1) / 10000n, wallet.address);
                    (0, expect_1.expect)((await pool.globalState()).tick).to.eq(startingTick + 1);
                    await (0, snapshotGasCost_1.default)(swapExact1For0(2000, wallet.address));
                    (0, expect_1.expect)((await pool.globalState()).tick).to.eq(startingTick + 1);
                });
            });
            describe('#swapExact1For0 with plugin fee on', () => {
                beforeEach('load the fixture', async () => {
                    const MockPoolPluginFactory = await hardhat_1.ethers.getContractFactory('MockPoolPlugin');
                    poolPlugin = (await MockPoolPluginFactory.deploy(await pool.getAddress()));
                    await poolPlugin.setPluginFees(0, 1000);
                    await pool.setPlugin(poolPlugin);
                    await pool.setPluginConfig(255);
                    await pool.advanceTime(86400);
                    await swapExact0For1((0, utilities_1.expandTo18Decimals)(1), wallet.address);
                    await pool.advanceTime(1);
                    await swapToHigherPrice(startingPrice, wallet.address);
                    (0, expect_1.expect)((await pool.globalState()).tick).to.eq(startingTick);
                    (0, expect_1.expect)((await pool.globalState()).price).to.eq(startingPrice);
                });
                it('first swap in block with no tick movement, without transfer', async () => {
                    await swapExact1For0(10000, wallet.address);
                    await pool.advanceTime(1);
                    await (0, snapshotGasCost_1.default)(swapExact1For0(10000, wallet.address));
                    (0, expect_1.expect)((await pool.globalState()).price).to.not.eq(startingPrice);
                    (0, expect_1.expect)((await pool.globalState()).tick).to.eq(startingTick);
                    (0, expect_1.expect)((await pool.getPluginFeePending())[1]).to.be.gt(0);
                });
                it('first swap in block with no tick movement, with transfer', async () => {
                    await pool.advanceTime(86400);
                    await (0, snapshotGasCost_1.default)(swapExact1For0(10000, wallet.address));
                    (0, expect_1.expect)((await pool.globalState()).price).to.not.eq(startingPrice);
                    (0, expect_1.expect)((await pool.globalState()).tick).to.eq(startingTick);
                });
                it('first swap in block moves tick, no initialized crossings, with transfer', async () => {
                    await pool.advanceTime(86400);
                    await (0, snapshotGasCost_1.default)(swapExact1For0((0, utilities_1.expandTo18Decimals)(1) / 10000n, wallet.address));
                    (0, expect_1.expect)((await pool.getPluginFeePending())[1]).to.be.eq(0);
                    (0, expect_1.expect)((await pool.globalState()).tick).to.eq(startingTick + 1);
                });
            });
            describe('#swapExact0For1', () => {
                it('first swap in block with no tick movement', async () => {
                    await (0, snapshotGasCost_1.default)(swapExact0For1(4000, wallet.address));
                    (0, expect_1.expect)((await pool.globalState()).price).to.not.eq(startingPrice);
                    (0, expect_1.expect)((await pool.globalState()).tick).to.eq(startingTick);
                });
                it('first swap in block moves tick, no initialized crossings', async () => {
                    await (0, snapshotGasCost_1.default)(swapExact0For1((0, utilities_1.expandTo18Decimals)(1) / 10000n, wallet.address));
                    (0, expect_1.expect)((await pool.globalState()).tick).to.eq(startingTick - 1);
                });
                it('second swap in block with no tick movement', async () => {
                    await swapExact0For1((0, utilities_1.expandTo18Decimals)(1) / 10000n, wallet.address);
                    (0, expect_1.expect)((await pool.globalState()).tick).to.eq(startingTick - 1);
                    await (0, snapshotGasCost_1.default)(swapExact0For1(2000, wallet.address));
                    (0, expect_1.expect)((await pool.globalState()).tick).to.eq(startingTick - 1);
                });
                it('second swap in block moves tick, no initialized crossings', async () => {
                    await swapExact0For1(1000, wallet.address);
                    (0, expect_1.expect)((await pool.globalState()).tick).to.eq(startingTick);
                    await (0, snapshotGasCost_1.default)(swapExact0For1((0, utilities_1.expandTo18Decimals)(1) / 10000n, wallet.address));
                    (0, expect_1.expect)((await pool.globalState()).tick).to.eq(startingTick - 1);
                });
                it('first swap in block, large swap, no initialized crossings', async () => {
                    await (0, snapshotGasCost_1.default)(swapExact0For1((0, utilities_1.expandTo18Decimals)(10), wallet.address));
                    (0, expect_1.expect)((await pool.globalState()).tick).to.eq(-35829);
                });
                it('first swap in block, large swap crossing several initialized ticks', async () => {
                    await mint(wallet.address, startingTick - 3 * tickSpacing, startingTick - tickSpacing, (0, utilities_1.expandTo18Decimals)(1));
                    await mint(wallet.address, startingTick - 4 * tickSpacing, startingTick - 2 * tickSpacing, (0, utilities_1.expandTo18Decimals)(1));
                    (0, expect_1.expect)((await pool.globalState()).tick).to.eq(startingTick);
                    await (0, snapshotGasCost_1.default)(swapExact0For1((0, utilities_1.expandTo18Decimals)(1), wallet.address));
                    (0, expect_1.expect)((await pool.globalState()).tick).to.be.lt(startingTick - 4 * tickSpacing); // we crossed the last tick
                });
                it('several large swaps with pauses', async () => {
                    await mint(wallet.address, startingTick - 3 * tickSpacing, startingTick - tickSpacing, (0, utilities_1.expandTo18Decimals)(1));
                    await mint(wallet.address, startingTick - 4 * tickSpacing, startingTick - 2 * tickSpacing, (0, utilities_1.expandTo18Decimals)(1));
                    (0, expect_1.expect)((await pool.globalState()).tick).to.eq(startingTick);
                    await swapExact0For1((0, utilities_1.expandTo18Decimals)(1) / 10000n, wallet.address);
                    await pool.advanceTime(60);
                    await swapExact0For1((0, utilities_1.expandTo18Decimals)(1) / 10000n, wallet.address);
                    await pool.advanceTime(60 * 60);
                    await swapExact1For0((0, utilities_1.expandTo18Decimals)(1) / 10000n, wallet.address);
                    await pool.advanceTime(60 * 60);
                    await swapExact0For1((0, utilities_1.expandTo18Decimals)(1) / 10000n, wallet.address);
                    await pool.advanceTime(5 * 60 * 60);
                    await swapExact1For0((0, utilities_1.expandTo18Decimals)(1) / 10000n, wallet.address);
                    await pool.advanceTime(19 * 60 * 60);
                    await swapExact1For0((0, utilities_1.expandTo18Decimals)(1) / 10000n, wallet.address);
                    await pool.advanceTime(60);
                    await (0, snapshotGasCost_1.default)(swapExact0For1((0, utilities_1.expandTo18Decimals)(1), wallet.address));
                    (0, expect_1.expect)((await pool.globalState()).tick).to.be.lt(startingTick - 4 * tickSpacing); // we crossed the last tick
                });
                it('small swap after several large swaps with pauses', async () => {
                    await mint(wallet.address, startingTick - 3 * tickSpacing, startingTick - tickSpacing, (0, utilities_1.expandTo18Decimals)(1));
                    await mint(wallet.address, startingTick - 4 * tickSpacing, startingTick - 2 * tickSpacing, (0, utilities_1.expandTo18Decimals)(1));
                    (0, expect_1.expect)((await pool.globalState()).tick).to.eq(startingTick);
                    await swapExact0For1((0, utilities_1.expandTo18Decimals)(1) / 10000n, wallet.address);
                    await pool.advanceTime(60);
                    await swapExact0For1((0, utilities_1.expandTo18Decimals)(1) / 10000n, wallet.address);
                    await pool.advanceTime(60 * 60);
                    await swapExact1For0((0, utilities_1.expandTo18Decimals)(1) / 10000n, wallet.address);
                    await pool.advanceTime(60 * 60);
                    await swapExact0For1((0, utilities_1.expandTo18Decimals)(1) / 10000n, wallet.address);
                    await pool.advanceTime(5 * 60 * 60);
                    await swapExact1For0((0, utilities_1.expandTo18Decimals)(1) / 10000n, wallet.address);
                    await pool.advanceTime(19 * 60 * 60);
                    await swapExact0For1((0, utilities_1.expandTo18Decimals)(1) / 10000n, wallet.address);
                    await pool.advanceTime(60);
                    await (0, snapshotGasCost_1.default)(swapExact0For1(1000, wallet.address));
                    (0, expect_1.expect)((await pool.globalState()).tick).to.be.lt(0);
                });
                it('small swap with filled dataStorage', async () => {
                    await mint(wallet.address, startingTick - 3 * tickSpacing, startingTick - tickSpacing, (0, utilities_1.expandTo18Decimals)(1));
                    await mint(wallet.address, startingTick - 4 * tickSpacing, startingTick - 2 * tickSpacing, (0, utilities_1.expandTo18Decimals)(1));
                    (0, expect_1.expect)((await pool.globalState()).tick).to.eq(startingTick);
                    for (let i = 0; i < 100; i++) {
                        if (i % 2 == 0) {
                            await swapExact0For1((0, utilities_1.expandTo18Decimals)(1) / 10000n, wallet.address);
                        }
                        else {
                            await swapExact1For0((0, utilities_1.expandTo18Decimals)(1) / 10000n, wallet.address);
                        }
                        await pool.advanceTime(60 * 60);
                    }
                    await (0, snapshotGasCost_1.default)(swapExact0For1(1000, wallet.address));
                });
                it('first swap in block, large swap crossing a single initialized tick', async () => {
                    await mint(wallet.address, minTick, startingTick - 2 * tickSpacing, (0, utilities_1.expandTo18Decimals)(1));
                    await (0, snapshotGasCost_1.default)(swapExact0For1((0, utilities_1.expandTo18Decimals)(1), wallet.address));
                    (0, expect_1.expect)((await pool.globalState()).tick).to.be.lt(startingTick - 2 * tickSpacing); // we crossed the last tick
                });
                it('second swap in block, large swap crossing several initialized ticks', async () => {
                    await mint(wallet.address, startingTick - 3 * tickSpacing, startingTick - tickSpacing, (0, utilities_1.expandTo18Decimals)(1));
                    await mint(wallet.address, startingTick - 4 * tickSpacing, startingTick - 2 * tickSpacing, (0, utilities_1.expandTo18Decimals)(1));
                    await swapExact0For1((0, utilities_1.expandTo18Decimals)(1) / 10000n, wallet.address);
                    await (0, snapshotGasCost_1.default)(swapExact0For1((0, utilities_1.expandTo18Decimals)(1), wallet.address));
                    (0, expect_1.expect)((await pool.globalState()).tick).to.be.lt(startingTick - 4 * tickSpacing);
                });
                it('second swap in block, large swap crossing a single initialized tick', async () => {
                    await mint(wallet.address, minTick, startingTick - 2 * tickSpacing, (0, utilities_1.expandTo18Decimals)(1));
                    await swapExact0For1((0, utilities_1.expandTo18Decimals)(1) / 10000n, wallet.address);
                    (0, expect_1.expect)((await pool.globalState()).tick).to.be.gt(startingTick - 2 * tickSpacing); // we didn't cross the initialized tick
                    await (0, snapshotGasCost_1.default)(swapExact0For1((0, utilities_1.expandTo18Decimals)(1), wallet.address));
                    (0, expect_1.expect)((await pool.globalState()).tick).to.be.lt(startingTick - 2 * tickSpacing); // we crossed the last tick
                });
                it('large swap crossing several initialized ticks after some time passes', async () => {
                    await mint(wallet.address, startingTick - 3 * tickSpacing, startingTick - tickSpacing, (0, utilities_1.expandTo18Decimals)(1));
                    await mint(wallet.address, startingTick - 4 * tickSpacing, startingTick - 2 * tickSpacing, (0, utilities_1.expandTo18Decimals)(1));
                    await swapExact0For1(2, wallet.address);
                    await pool.advanceTime(1);
                    await (0, snapshotGasCost_1.default)(swapExact0For1((0, utilities_1.expandTo18Decimals)(1), wallet.address));
                    (0, expect_1.expect)((await pool.globalState()).tick).to.be.lt(startingTick - 4 * tickSpacing);
                });
                it('large swap crossing several initialized ticks second time after some time passes', async () => {
                    await mint(wallet.address, startingTick - 3 * tickSpacing, startingTick - tickSpacing, (0, utilities_1.expandTo18Decimals)(1));
                    await mint(wallet.address, startingTick - 4 * tickSpacing, startingTick - 2 * tickSpacing, (0, utilities_1.expandTo18Decimals)(1));
                    await swapExact0For1((0, utilities_1.expandTo18Decimals)(1), wallet.address);
                    await swapToHigherPrice(startingPrice, wallet.address);
                    await pool.advanceTime(1);
                    await (0, snapshotGasCost_1.default)(swapExact0For1((0, utilities_1.expandTo18Decimals)(1), wallet.address));
                    (0, expect_1.expect)((await pool.globalState()).tick).to.be.lt(tickSpacing * -4);
                });
            });
            describe('#mint', () => {
                for (const { description, bottomTick, topTick } of [
                    {
                        description: 'around current price',
                        bottomTick: startingTick - tickSpacing,
                        topTick: startingTick + tickSpacing,
                    },
                    {
                        description: 'below current price',
                        bottomTick: startingTick - 2 * tickSpacing,
                        topTick: startingTick - tickSpacing,
                    },
                    {
                        description: 'above current price',
                        bottomTick: startingTick + tickSpacing,
                        topTick: startingTick + 2 * tickSpacing,
                    },
                ]) {
                    describe(description, () => {
                        it('new position mint first in range', async () => {
                            await (0, snapshotGasCost_1.default)(mint(wallet.address, bottomTick, topTick, (0, utilities_1.expandTo18Decimals)(1)));
                        });
                        it('add to position existing', async () => {
                            await mint(wallet.address, bottomTick, topTick, (0, utilities_1.expandTo18Decimals)(1));
                            await (0, snapshotGasCost_1.default)(mint(wallet.address, bottomTick, topTick, (0, utilities_1.expandTo18Decimals)(1)));
                        });
                        it('second position in same range', async () => {
                            await mint(wallet.address, bottomTick, topTick, (0, utilities_1.expandTo18Decimals)(1));
                            await (0, snapshotGasCost_1.default)(mint(other.address, bottomTick, topTick, (0, utilities_1.expandTo18Decimals)(1)));
                        });
                        it('add to position after some time passes', async () => {
                            await mint(wallet.address, bottomTick, topTick, (0, utilities_1.expandTo18Decimals)(1));
                            await pool.advanceTime(1);
                            await (0, snapshotGasCost_1.default)(mint(wallet.address, bottomTick, topTick, (0, utilities_1.expandTo18Decimals)(1)));
                        });
                    });
                }
            });
            describe('#burn', () => {
                for (const { description, bottomTick, topTick } of [
                    {
                        description: 'around current price',
                        bottomTick: startingTick - tickSpacing,
                        topTick: startingTick + tickSpacing,
                    },
                    {
                        description: 'below current price',
                        bottomTick: startingTick - 2 * tickSpacing,
                        topTick: startingTick - tickSpacing,
                    },
                    {
                        description: 'above current price',
                        bottomTick: startingTick + tickSpacing,
                        topTick: startingTick + 2 * tickSpacing,
                    },
                ]) {
                    describe(description, () => {
                        const liquidityAmount = (0, utilities_1.expandTo18Decimals)(1);
                        beforeEach('mint a position', async () => {
                            await mint(wallet.address, bottomTick, topTick, liquidityAmount);
                        });
                        it('burn when only position using ticks', async () => {
                            await (0, snapshotGasCost_1.default)(pool.burn(bottomTick, topTick, (0, utilities_1.expandTo18Decimals)(1), '0x'));
                        });
                        it('partial position burn', async () => {
                            await (0, snapshotGasCost_1.default)(pool.burn(bottomTick, topTick, (0, utilities_1.expandTo18Decimals)(1) / 2n, '0x'));
                        });
                        it('entire position burn but other positions are using the ticks', async () => {
                            await mint(other.address, bottomTick, topTick, (0, utilities_1.expandTo18Decimals)(1));
                            await (0, snapshotGasCost_1.default)(pool.burn(bottomTick, topTick, (0, utilities_1.expandTo18Decimals)(1), '0x'));
                        });
                        it('burn entire position after some time passes', async () => {
                            await pool.advanceTime(1);
                            await (0, snapshotGasCost_1.default)(pool.burn(bottomTick, topTick, (0, utilities_1.expandTo18Decimals)(1), '0x'));
                        });
                    });
                }
            });
            describe('#poke', () => {
                const bottomTick = startingTick - tickSpacing;
                const topTick = startingTick + tickSpacing;
                it('best case', async () => {
                    await mint(wallet.address, bottomTick, topTick, (0, utilities_1.expandTo18Decimals)(1));
                    await swapExact0For1((0, utilities_1.expandTo18Decimals)(1) / 100n, wallet.address);
                    await pool.burn(bottomTick, topTick, 0, '0x');
                    await swapExact0For1((0, utilities_1.expandTo18Decimals)(1) / 100n, wallet.address);
                    await (0, snapshotGasCost_1.default)(pool.burn(bottomTick, topTick, 0, '0x'));
                });
            });
            describe('#collect', () => {
                const bottomTick = startingTick - tickSpacing;
                const topTick = startingTick + tickSpacing;
                it('close to worst case', async () => {
                    await mint(wallet.address, bottomTick, topTick, (0, utilities_1.expandTo18Decimals)(1));
                    await swapExact0For1((0, utilities_1.expandTo18Decimals)(1) / 100n, wallet.address);
                    await pool.burn(bottomTick, topTick, 0, '0x'); // poke to accumulate fees
                    await (0, snapshotGasCost_1.default)(pool.collect(wallet.address, bottomTick, topTick, utilities_1.MaxUint128, utilities_1.MaxUint128));
                });
                it('close to worst case, two tokens', async () => {
                    await mint(wallet.address, bottomTick, topTick, (0, utilities_1.expandTo18Decimals)(1));
                    await swapExact0For1((0, utilities_1.expandTo18Decimals)(1) / 100n, wallet.address);
                    await swapExact1For0((0, utilities_1.expandTo18Decimals)(1) / 100n, wallet.address);
                    await pool.burn(bottomTick, topTick, 0, '0x'); // poke to accumulate fees
                    await (0, snapshotGasCost_1.default)(pool.collect(wallet.address, bottomTick, topTick, utilities_1.MaxUint128, utilities_1.MaxUint128));
                });
            });
        });
    }
});
