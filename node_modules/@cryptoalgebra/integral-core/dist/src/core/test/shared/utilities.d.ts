import { BigNumberish, ContractTransactionResponse, Wallet } from 'ethers';
import { TestAlgebraCallee, TestAlgebraRouter, MockTimeAlgebraPool, TestERC20 } from '../../typechain';
export declare const MaxUint128: bigint;
export declare const MIN_TICK = -887272;
export declare const MAX_TICK: number;
export declare const getMinTick: (tickSpacing: number) => number;
export declare const getMaxTick: (tickSpacing: number) => number;
export declare const getMaxLiquidityPerTick: (tickSpacing: number) => bigint;
export declare const MIN_SQRT_RATIO: bigint;
export declare const MAX_SQRT_RATIO: bigint;
export declare enum FeeAmount {
    LOW = 500,
    MEDIUM = 3000,
    HIGH = 10000
}
export declare const TICK_SPACINGS: {
    [amount in FeeAmount]: number;
};
export declare function expandTo18Decimals(n: number): bigint;
export declare function getCreate2Address(poolDeployerAddress: string, [tokenA, tokenB]: [string, string], bytecode: string): string;
export declare function getCreate2CustomAddress(poolDeployerAddress: string, customDeployerAddress: string, [tokenA, tokenB]: [string, string], bytecode: string): string;
export declare function encodeCallback(address: string, paid0?: bigint, paid1?: bigint): string;
export declare function encodePriceSqrt(reserve1: BigNumberish, reserve0: BigNumberish): bigint;
export declare function getPositionKey(address: string, bottomTick: number, topTick: number, pool: MockTimeAlgebraPool): Promise<string>;
export declare function getLimitPositionKey(address: string, tick: number, pool: MockTimeAlgebraPool): Promise<string>;
export type SwapFunction = (amount: BigNumberish, to: Wallet | string, limitSqrtPrice?: BigNumberish) => Promise<ContractTransactionResponse>;
export type SwapToPriceFunction = (price: BigNumberish, to: Wallet | string) => Promise<ContractTransactionResponse>;
export type FlashFunction = (amount0: BigNumberish, amount1: BigNumberish, to: Wallet | string, pay0?: BigNumberish, pay1?: BigNumberish) => Promise<ContractTransactionResponse>;
export type AddLimitFunction = (recipient: string, tick: number, amount: BigNumberish) => Promise<ContractTransactionResponse>;
export type MintFunction = (recipient: string, bottomTick: BigNumberish, topTick: BigNumberish, liquidity: BigNumberish) => Promise<ContractTransactionResponse>;
export interface PoolFunctions {
    swapToLowerPrice: SwapToPriceFunction;
    swapToHigherPrice: SwapToPriceFunction;
    swapExact0For1: SwapFunction;
    swapExact0For1SupportingFee: SwapFunction;
    swap0ForExact1: SwapFunction;
    swapExact1For0: SwapFunction;
    swapExact1For0SupportingFee: SwapFunction;
    swap1ForExact0: SwapFunction;
    flash: FlashFunction;
    mint: MintFunction;
}
export declare function createPoolFunctions({ swapTarget, token0, token1, pool, }: {
    swapTarget: TestAlgebraCallee;
    token0: TestERC20;
    token1: TestERC20;
    pool: MockTimeAlgebraPool;
}): PoolFunctions;
export interface MultiPoolFunctions {
    swapForExact0Multi: SwapFunction;
    swapForExact1Multi: SwapFunction;
}
export declare function createMultiPoolFunctions({ inputToken, swapTarget, poolInput, poolOutput, }: {
    inputToken: TestERC20;
    swapTarget: TestAlgebraRouter;
    poolInput: MockTimeAlgebraPool;
    poolOutput: MockTimeAlgebraPool;
}): MultiPoolFunctions;
