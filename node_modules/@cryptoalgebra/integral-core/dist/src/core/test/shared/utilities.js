"use strict";
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.createMultiPoolFunctions = exports.createPoolFunctions = exports.getLimitPositionKey = exports.getPositionKey = exports.encodePriceSqrt = exports.encodeCallback = exports.getCreate2CustomAddress = exports.getCreate2Address = exports.expandTo18Decimals = exports.TICK_SPACINGS = exports.FeeAmount = exports.MAX_SQRT_RATIO = exports.MIN_SQRT_RATIO = exports.getMaxLiquidityPerTick = exports.getMaxTick = exports.getMinTick = exports.MAX_TICK = exports.MIN_TICK = exports.MaxUint128 = void 0;
const bignumber_js_1 = __importDefault(require("bignumber.js"));
const ethers_1 = require("ethers");
exports.MaxUint128 = 2n ** 128n - 1n;
exports.MIN_TICK = -887272;
exports.MAX_TICK = -exports.MIN_TICK;
const getMinTick = (tickSpacing) => Math.ceil(-887272 / tickSpacing) * tickSpacing;
exports.getMinTick = getMinTick;
const getMaxTick = (tickSpacing) => Math.floor(887272 / tickSpacing) * tickSpacing;
exports.getMaxTick = getMaxTick;
const getMaxLiquidityPerTick = (tickSpacing) => (2n ** 128n - 1n) / (BigInt((0, exports.getMaxTick)(tickSpacing) - (0, exports.getMinTick)(tickSpacing)) / BigInt(tickSpacing) + 1n);
exports.getMaxLiquidityPerTick = getMaxLiquidityPerTick;
exports.MIN_SQRT_RATIO = BigInt('4295128739');
exports.MAX_SQRT_RATIO = BigInt('1461446703485210103287273052203988822378723970342');
var FeeAmount;
(function (FeeAmount) {
    FeeAmount[FeeAmount["LOW"] = 500] = "LOW";
    FeeAmount[FeeAmount["MEDIUM"] = 3000] = "MEDIUM";
    FeeAmount[FeeAmount["HIGH"] = 10000] = "HIGH";
})(FeeAmount || (exports.FeeAmount = FeeAmount = {}));
exports.TICK_SPACINGS = {
    [FeeAmount.LOW]: 10,
    [FeeAmount.MEDIUM]: 60,
    [FeeAmount.HIGH]: 100,
};
function expandTo18Decimals(n) {
    return BigInt(n) * 10n ** 18n;
}
exports.expandTo18Decimals = expandTo18Decimals;
function getCreate2Address(poolDeployerAddress, [tokenA, tokenB], bytecode) {
    const [token0, token1] = tokenA.toLowerCase() < tokenB.toLowerCase() ? [tokenA, tokenB] : [tokenB, tokenA];
    const constructorArgumentsEncoded = ethers_1.AbiCoder.defaultAbiCoder().encode(['address', 'address'], [token0, token1]);
    const create2Inputs = [
        '0xff',
        poolDeployerAddress,
        // salt
        (0, ethers_1.keccak256)(constructorArgumentsEncoded),
        // init code. bytecode + constructor arguments
        (0, ethers_1.keccak256)(bytecode),
    ];
    const sanitizedInputs = `0x${create2Inputs.map((i) => i.slice(2)).join('')}`;
    return (0, ethers_1.getAddress)(`0x${(0, ethers_1.keccak256)(sanitizedInputs).slice(-40)}`);
}
exports.getCreate2Address = getCreate2Address;
function getCreate2CustomAddress(poolDeployerAddress, customDeployerAddress, [tokenA, tokenB], bytecode) {
    const [token0, token1] = tokenA.toLowerCase() < tokenB.toLowerCase() ? [tokenA, tokenB] : [tokenB, tokenA];
    const constructorArgumentsEncoded = ethers_1.AbiCoder.defaultAbiCoder().encode(['address', 'address', 'address'], [customDeployerAddress, token0, token1]);
    const create2Inputs = [
        '0xff',
        poolDeployerAddress,
        // salt
        (0, ethers_1.keccak256)(constructorArgumentsEncoded),
        // init code. bytecode + constructor arguments
        (0, ethers_1.keccak256)(bytecode),
    ];
    const sanitizedInputs = `0x${create2Inputs.map((i) => i.slice(2)).join('')}`;
    return (0, ethers_1.getAddress)(`0x${(0, ethers_1.keccak256)(sanitizedInputs).slice(-40)}`);
}
exports.getCreate2CustomAddress = getCreate2CustomAddress;
function encodeCallback(address, paid0, paid1) {
    if (paid0)
        return ethers_1.AbiCoder.defaultAbiCoder().encode(['address', 'uint256', 'uint256'], [address, paid0, paid1]);
    return ethers_1.AbiCoder.defaultAbiCoder().encode(['address'], [address]);
}
exports.encodeCallback = encodeCallback;
bignumber_js_1.default.config({ EXPONENTIAL_AT: 999999, DECIMAL_PLACES: 40 });
// returns the sqrt price as a 64x96
function encodePriceSqrt(reserve1, reserve0) {
    return BigInt(new bignumber_js_1.default(reserve1.toString())
        .div(reserve0.toString())
        .sqrt()
        .multipliedBy(new bignumber_js_1.default(2).pow(96))
        .integerValue(3)
        .toString());
}
exports.encodePriceSqrt = encodePriceSqrt;
function getPositionKey(address, bottomTick, topTick, pool) {
    return pool.getKeyForPosition(address, bottomTick, topTick);
}
exports.getPositionKey = getPositionKey;
function getLimitPositionKey(address, tick, pool) {
    return pool.getKeyForLimitPosition(address, tick);
}
exports.getLimitPositionKey = getLimitPositionKey;
function createPoolFunctions({ swapTarget, token0, token1, pool, }) {
    async function swapToSqrtPrice(inputToken, targetPrice, to) {
        const method = inputToken === token0 ? swapTarget.swapToLowerSqrtPrice : swapTarget.swapToHigherSqrtPrice;
        await inputToken.approve(swapTarget, ethers_1.MaxUint256);
        const toAddress = typeof to === 'string' ? to : to.address;
        return method(pool, targetPrice, toAddress);
    }
    async function swap(inputToken, [amountIn, amountOut], to, limitSqrtPrice, supportingFee) {
        const exactInput = amountOut === 0;
        const method = inputToken === token0
            ? exactInput
                ? supportingFee
                    ? swapTarget.swapExact0For1SupportingFee
                    : swapTarget.swapExact0For1
                : swapTarget.swap0ForExact1
            : exactInput
                ? supportingFee
                    ? swapTarget.swapExact1For0SupportingFee
                    : swapTarget.swapExact1For0
                : swapTarget.swap1ForExact0;
        if (typeof limitSqrtPrice === 'undefined') {
            if (inputToken === token0) {
                limitSqrtPrice = exports.MIN_SQRT_RATIO + 1n;
            }
            else {
                limitSqrtPrice = exports.MAX_SQRT_RATIO - 1n;
            }
        }
        await inputToken.approve(swapTarget, ethers_1.MaxUint256);
        const toAddress = typeof to === 'string' ? to : to.address;
        return method(pool, exactInput ? amountIn : amountOut, toAddress, limitSqrtPrice);
    }
    const swapToLowerPrice = (price, to) => {
        return swapToSqrtPrice(token0, price, to);
    };
    const swapToHigherPrice = (price, to) => {
        return swapToSqrtPrice(token1, price, to);
    };
    const swapExact0For1 = (amount, to, limitSqrtPrice) => {
        return swap(token0, [amount, 0], to, limitSqrtPrice);
    };
    const swapExact0For1SupportingFee = (amount, to, limitSqrtPrice) => {
        return swap(token0, [amount, 0], to, limitSqrtPrice, true);
    };
    const swap0ForExact1 = (amount, to, limitSqrtPrice) => {
        return swap(token0, [0, amount], to, limitSqrtPrice);
    };
    const swapExact1For0 = (amount, to, limitSqrtPrice) => {
        return swap(token1, [amount, 0], to, limitSqrtPrice);
    };
    const swapExact1For0SupportingFee = (amount, to, limitSqrtPrice) => {
        return swap(token1, [amount, 0], to, limitSqrtPrice, true);
    };
    const swap1ForExact0 = (amount, to, limitSqrtPrice) => {
        return swap(token1, [0, amount], to, limitSqrtPrice);
    };
    const mint = async (recipient, bottomTick, topTick, liquidity) => {
        await token0.approve(swapTarget, ethers_1.MaxUint256);
        await token1.approve(swapTarget, ethers_1.MaxUint256);
        return swapTarget.mint(pool, recipient, bottomTick, topTick, liquidity);
    };
    const flash = async (amount0, amount1, to, pay0, pay1) => {
        const fee = 100;
        if (typeof pay0 === 'undefined') {
            pay0 = (BigInt(amount0) * BigInt(fee) + BigInt(1e6 - 1)) / BigInt(1e6) + BigInt(amount0);
        }
        if (typeof pay1 === 'undefined') {
            pay1 = (BigInt(amount1) * BigInt(fee) + BigInt(1e6 - 1)) / BigInt(1e6) + BigInt(amount1);
        }
        return swapTarget.flash(pool, typeof to === 'string' ? to : to.address, amount0, amount1, pay0, pay1);
    };
    return {
        swapToLowerPrice,
        swapToHigherPrice,
        swapExact0For1,
        swapExact0For1SupportingFee,
        swap0ForExact1,
        swapExact1For0,
        swapExact1For0SupportingFee,
        swap1ForExact0,
        mint,
        flash,
    };
}
exports.createPoolFunctions = createPoolFunctions;
function createMultiPoolFunctions({ inputToken, swapTarget, poolInput, poolOutput, }) {
    async function swapForExact0Multi(amountOut, to) {
        const method = swapTarget.swapForExact0Multi;
        await inputToken.approve(swapTarget, ethers_1.MaxUint256);
        const toAddress = typeof to === 'string' ? to : to.address;
        return method(toAddress, poolInput, poolOutput, amountOut);
    }
    async function swapForExact1Multi(amountOut, to) {
        const method = swapTarget.swapForExact1Multi;
        await inputToken.approve(swapTarget, ethers_1.MaxUint256);
        const toAddress = typeof to === 'string' ? to : to.address;
        return method(toAddress, poolInput, poolOutput, amountOut);
    }
    return {
        swapForExact0Multi,
        swapForExact1Multi,
    };
}
exports.createMultiPoolFunctions = createMultiPoolFunctions;
