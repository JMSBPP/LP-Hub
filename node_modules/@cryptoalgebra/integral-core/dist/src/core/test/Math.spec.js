"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
const hardhat_1 = require("hardhat");
const ethers_1 = require("ethers");
const expect_1 = require("./shared/expect");
const decimal_js_1 = require("decimal.js");
const Q128 = 2n ** 128n;
decimal_js_1.Decimal.config({ toExpNeg: -500, toExpPos: 500 });
describe('SafeMath', () => {
    let safeMath;
    before('deploy FullMathTest', async () => {
        const factory = await hardhat_1.ethers.getContractFactory('SafeMathTest');
        safeMath = (await factory.deploy());
    });
    it('#add', async () => {
        await (0, expect_1.expect)(safeMath.add(ethers_1.MaxUint256, 1)).to.be.reverted;
    });
    it('#sub', async () => {
        await (0, expect_1.expect)(safeMath.sub(Q128 - 1n, Q128)).to.be.reverted;
        (0, expect_1.expect)(await safeMath.sub(Q128, Q128 - 1n)).to.be.eq(1);
    });
    it('#mul', async () => {
        await (0, expect_1.expect)(safeMath.mul(Q128, Q128)).to.be.reverted;
    });
    it('#addInt', async () => {
        await (0, expect_1.expect)(safeMath.addInt(2n ** 255n - 1n, 1)).to.be.reverted;
    });
    it('#subInt', async () => {
        await (0, expect_1.expect)(safeMath.subInt(100, (2n ** 255n - 1n) * (-1n))).to.be.reverted;
        await (0, expect_1.expect)(safeMath.subInt(2n ** 255n - 1n, -100)).to.be.reverted;
    });
    it('#add128', async () => {
        await (0, expect_1.expect)(safeMath.add128(Q128 - 10n, 15)).to.be.reverted;
        (0, expect_1.expect)(await safeMath.add128(10, 10)).to.be.eq(20);
    });
    it('#toUint160', async () => {
        await (0, expect_1.expect)(safeMath.toUint160(2n ** 255n - 1n)).to.be.reverted;
    });
    it('#toUint128', async () => {
        await (0, expect_1.expect)(safeMath.toUint128(2n ** 255n - 1n)).to.be.reverted;
    });
    it('#toInt128', async () => {
        await (0, expect_1.expect)(safeMath.toInt128(2n ** 255n - 1n)).to.be.reverted;
        (0, expect_1.expect)(await safeMath.toInt128(2n ** 127n - 1n)).to.be.eq(2n ** 127n - 1n);
        await (0, expect_1.expect)(safeMath.toInt128U(2n ** 128n - 1n)).to.be.reverted;
    });
    it('#toInt256', async () => {
        await (0, expect_1.expect)(safeMath.toInt256(ethers_1.MaxUint256)).to.be.reverted;
    });
});
describe('FullMath', () => {
    let fullMath;
    before('deploy FullMathTest', async () => {
        const factory = await hardhat_1.ethers.getContractFactory('FullMathTest');
        fullMath = (await factory.deploy());
    });
    describe('#mulDiv', () => {
        it('reverts if denominator is 0', async () => {
            await (0, expect_1.expect)(fullMath.mulDiv(Q128, 5, 0)).to.be.reverted;
        });
        it('reverts if denominator is 0 and numerator overflows', async () => {
            await (0, expect_1.expect)(fullMath.mulDiv(Q128, Q128, 0)).to.be.reverted;
        });
        it('reverts if output overflows uint256', async () => {
            await (0, expect_1.expect)(fullMath.mulDiv(Q128, Q128, 1)).to.be.reverted;
        });
        it('reverts on overflow with all max inputs', async () => {
            await (0, expect_1.expect)(fullMath.mulDiv(ethers_1.MaxUint256, ethers_1.MaxUint256, ethers_1.MaxUint256 - 1n)).to.be.reverted;
        });
        it('all max inputs', async () => {
            (0, expect_1.expect)(await fullMath.mulDiv(ethers_1.MaxUint256, ethers_1.MaxUint256, ethers_1.MaxUint256)).to.eq(ethers_1.MaxUint256);
        });
        it('accurate without phantom overflow', async () => {
            const result = Q128 / 3n;
            (0, expect_1.expect)(await fullMath.mulDiv(Q128, 
            /**0.5=*/ 50n * Q128 / 100n, 
            /**1.5=*/ 150n * Q128 / 100n)).to.eq(result);
        });
        it('accurate with phantom overflow', async () => {
            const result = 4375n * Q128 / 1000n;
            (0, expect_1.expect)(await fullMath.mulDiv(Q128, 35n * Q128, 8n * Q128)).to.eq(result);
        });
        it('accurate with phantom overflow and repeating decimal', async () => {
            const result = Q128 / 3n;
            (0, expect_1.expect)(await fullMath.mulDiv(Q128, 1000n * Q128, 3000n * Q128)).to.eq(result);
        });
    });
    describe('#mulDivRoundingUp', () => {
        it('reverts if denominator is 0', async () => {
            await (0, expect_1.expect)(fullMath.mulDivRoundingUp(Q128, 5, 0)).to.be.reverted;
        });
        it('reverts if denominator is 0 and numerator overflows', async () => {
            await (0, expect_1.expect)(fullMath.mulDivRoundingUp(Q128, Q128, 0)).to.be.reverted;
        });
        it('reverts if output overflows uint256', async () => {
            await (0, expect_1.expect)(fullMath.mulDivRoundingUp(Q128, Q128, 1)).to.be.reverted;
        });
        it('reverts on overflow with all max inputs', async () => {
            await (0, expect_1.expect)(fullMath.mulDivRoundingUp(ethers_1.MaxUint256, ethers_1.MaxUint256, ethers_1.MaxUint256 - 1n)).to.be.reverted;
        });
        it('reverts if mulDiv overflows 256 bits after rounding up', async () => {
            await (0, expect_1.expect)(fullMath.mulDivRoundingUp('535006138814359', '432862656469423142931042426214547535783388063929571229938474969', '2')).to.be.reverted;
        });
        it('reverts if mulDiv overflows 256 bits after rounding up case 2', async () => {
            await (0, expect_1.expect)(fullMath.mulDivRoundingUp('115792089237316195423570985008687907853269984659341747863450311749907997002549', '115792089237316195423570985008687907853269984659341747863450311749907997002550', '115792089237316195423570985008687907853269984653042931687443039491902864365164')).to.be.reverted;
        });
        it('all max inputs', async () => {
            (0, expect_1.expect)(await fullMath.mulDivRoundingUp(ethers_1.MaxUint256, ethers_1.MaxUint256, ethers_1.MaxUint256)).to.eq(ethers_1.MaxUint256);
        });
        it('accurate without phantom overflow', async () => {
            const result = Q128 / 3n + 1n;
            (0, expect_1.expect)(await fullMath.mulDivRoundingUp(Q128, 
            /**0.5=*/ 50n * Q128 / 100n, 
            /**1.5=*/ 150n * Q128 / 100n)).to.eq(result);
        });
        it('accurate with phantom overflow', async () => {
            const result = 4375n * Q128 / 1000n;
            (0, expect_1.expect)(await fullMath.mulDivRoundingUp(Q128, 35n * Q128, 8n * Q128)).to.eq(result);
        });
        it('accurate with phantom overflow and repeating decimal', async () => {
            const result = Q128 / 3n + 1n;
            (0, expect_1.expect)(await fullMath.mulDivRoundingUp(Q128, 1000n * Q128, 3000n * Q128)).to.eq(result);
        });
    });
    function pseudoRandomBigNumber() {
        return BigInt(new decimal_js_1.Decimal(ethers_1.MaxUint256.toString()).mul(Math.random().toString()).round().toString());
    }
});
