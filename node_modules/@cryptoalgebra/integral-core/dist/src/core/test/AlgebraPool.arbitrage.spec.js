"use strict";
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
const decimal_js_1 = __importDefault(require("decimal.js"));
const ethers_1 = require("ethers");
const hardhat_1 = require("hardhat");
const hardhat_network_helpers_1 = require("@nomicfoundation/hardhat-network-helpers");
const expect_1 = require("./shared/expect");
const fixtures_1 = require("./shared/fixtures");
const format_1 = require("./shared/format");
const utilities_1 = require("./shared/utilities");
decimal_js_1.default.config({ toExpNeg: -500, toExpPos: 500 });
function applySqrtRatioBipsHundredthsDelta(sqrtRatio, bipsHundredths) {
    return BigInt(new decimal_js_1.default(((sqrtRatio * sqrtRatio * BigInt(1e6 + bipsHundredths)) / BigInt(1e6)).toString())
        .sqrt()
        .floor()
        .toString());
}
describe('AlgebraPool arbitrage tests', () => {
    let wallet, arbitrageur;
    before('create fixture loader', async () => {
        [wallet, arbitrageur] = await hardhat_1.ethers.getSigners();
    });
    for (const communityFee of [0, 170]) {
        describe(`community fee = ${communityFee};`, () => {
            const startingPrice = (0, utilities_1.encodePriceSqrt)(1, 1);
            const startingTick = 0;
            const feeAmount = utilities_1.FeeAmount.MEDIUM;
            const tickSpacing = utilities_1.TICK_SPACINGS[feeAmount];
            const minTick = (0, utilities_1.getMinTick)(tickSpacing);
            const maxTick = (0, utilities_1.getMaxTick)(tickSpacing);
            for (const passiveLiquidity of [
                (0, utilities_1.expandTo18Decimals)(1) / 100n,
                (0, utilities_1.expandTo18Decimals)(1),
                (0, utilities_1.expandTo18Decimals)(10),
                (0, utilities_1.expandTo18Decimals)(100),
            ]) {
                describe(`passive liquidity of ${(0, format_1.formatTokenAmount)(passiveLiquidity)}`, () => {
                    const arbTestFixture = async () => {
                        const fix = await (0, fixtures_1.poolFixture)();
                        const pool = await fix.createPool();
                        await fix.token0.transfer(arbitrageur.address, 2n ** 254n);
                        await fix.token1.transfer(arbitrageur.address, 2n ** 254n);
                        const { swapExact0For1, swapToHigherPrice, swapToLowerPrice, swapExact1For0, mint } = (0, utilities_1.createPoolFunctions)({
                            swapTarget: fix.swapTargetCallee,
                            token0: fix.token0,
                            token1: fix.token1,
                            pool,
                        });
                        const testerFactory = await hardhat_1.ethers.getContractFactory('AlgebraPoolSwapTest');
                        const tester = (await testerFactory.deploy());
                        const tickMathFactory = await hardhat_1.ethers.getContractFactory('TickMathTest');
                        const tickMath = (await tickMathFactory.deploy());
                        await fix.token0.approve(tester, ethers_1.MaxUint256);
                        await fix.token1.approve(tester, ethers_1.MaxUint256);
                        await pool.initialize(startingPrice);
                        await pool.setFee(feeAmount);
                        if (tickSpacing != 60)
                            await pool.setTickSpacing(tickSpacing);
                        if (communityFee != 0)
                            await pool.setCommunityFee(communityFee);
                        await mint(wallet.address, minTick, maxTick, passiveLiquidity);
                        (0, expect_1.expect)((await pool.globalState()).tick).to.eq(startingTick);
                        (0, expect_1.expect)((await pool.globalState()).price).to.eq(startingPrice);
                        return {
                            pool,
                            swapExact0For1,
                            mint,
                            swapToHigherPrice,
                            swapToLowerPrice,
                            swapExact1For0,
                            tester,
                            tickMath,
                        };
                    };
                    let swapExact0For1;
                    let swapToHigherPrice;
                    let swapToLowerPrice;
                    let swapExact1For0;
                    let pool;
                    let mint;
                    let tester;
                    let tickMath;
                    beforeEach('load the fixture', async () => {
                        ({ swapExact0For1, pool, mint, swapToHigherPrice, swapToLowerPrice, swapExact1For0, tester, tickMath } =
                            await (0, hardhat_network_helpers_1.loadFixture)(arbTestFixture));
                    });
                    async function simulateSwap(zeroToOne, amountSpecified, limitSqrtPrice) {
                        const { amount0Delta, amount1Delta, nextSqrtRatio } = await tester.getSwapResult.staticCall(pool, zeroToOne, amountSpecified, limitSqrtPrice ?? (zeroToOne ? utilities_1.MIN_SQRT_RATIO + 1n : utilities_1.MAX_SQRT_RATIO - 1n));
                        const executionPrice = zeroToOne
                            ? (0, utilities_1.encodePriceSqrt)(amount1Delta, amount0Delta * -1n)
                            : (0, utilities_1.encodePriceSqrt)(amount1Delta * -1n, amount0Delta);
                        return {
                            executionPrice,
                            nextSqrtRatio,
                            amount0Delta,
                            amount1Delta,
                        };
                    }
                    for (const { zeroToOne, assumedTruePriceAfterSwap, inputAmount, description } of [
                        {
                            description: 'exact input of 10e18 token0 with starting price of 1.0 and true price of 0.98',
                            zeroToOne: true,
                            inputAmount: (0, utilities_1.expandTo18Decimals)(10),
                            assumedTruePriceAfterSwap: (0, utilities_1.encodePriceSqrt)(98, 100),
                        },
                        {
                            description: 'exact input of 10e18 token0 with starting price of 1.0 and true price of 1.01',
                            zeroToOne: true,
                            inputAmount: (0, utilities_1.expandTo18Decimals)(10),
                            assumedTruePriceAfterSwap: (0, utilities_1.encodePriceSqrt)(101, 100),
                        },
                    ]) {
                        describe(description, () => {
                            function valueToken1(arbBalance0, arbBalance1) {
                                return (assumedTruePriceAfterSwap * assumedTruePriceAfterSwap * arbBalance0) / (2n ** 192n) + arbBalance1;
                            }
                            it('not sandwiched', async () => {
                                const { executionPrice, amount1Delta, amount0Delta } = await simulateSwap(zeroToOne, inputAmount);
                                zeroToOne
                                    ? await swapExact0For1(inputAmount, wallet.address)
                                    : await swapExact1For0(inputAmount, wallet.address);
                                (0, expect_1.expect)({
                                    executionPrice: (0, format_1.formatPrice)(executionPrice),
                                    amount0Delta: (0, format_1.formatTokenAmount)(amount0Delta),
                                    amount1Delta: (0, format_1.formatTokenAmount)(amount1Delta),
                                    priceAfter: (0, format_1.formatPrice)((await pool.globalState()).price),
                                }).to.matchSnapshot();
                            });
                            it('sandwiched with swap to execution price then mint max liquidity/target/burn max liquidity', async () => {
                                const { executionPrice } = await simulateSwap(zeroToOne, inputAmount);
                                const firstTickAboveMarginalPrice = zeroToOne
                                    ? Math.ceil(Number(await tickMath.getTickAtSqrtRatio(applySqrtRatioBipsHundredthsDelta(BigInt(executionPrice), feeAmount))) / tickSpacing) * tickSpacing
                                    : Math.floor(Number(await tickMath.getTickAtSqrtRatio(applySqrtRatioBipsHundredthsDelta(BigInt(executionPrice), -feeAmount))) / tickSpacing) * tickSpacing;
                                const tickAfterFirstTickAboveMarginPrice = zeroToOne
                                    ? firstTickAboveMarginalPrice - tickSpacing
                                    : firstTickAboveMarginalPrice + tickSpacing;
                                const priceSwapStart = await tickMath.getSqrtRatioAtTick(firstTickAboveMarginalPrice);
                                let arbBalance0 = 0n;
                                let arbBalance1 = 0n;
                                // first frontrun to the first tick before the execution price
                                const { amount0Delta: frontrunDelta0, amount1Delta: frontrunDelta1, executionPrice: frontrunExecutionPrice, } = await simulateSwap(zeroToOne, ethers_1.MaxUint256 / 2n, priceSwapStart);
                                arbBalance0 = arbBalance0 - frontrunDelta0;
                                arbBalance1 = arbBalance1 - frontrunDelta1;
                                zeroToOne
                                    ? await swapToLowerPrice(priceSwapStart, arbitrageur.address)
                                    : await swapToHigherPrice(priceSwapStart, arbitrageur.address);
                                const profitToken1AfterFrontRun = valueToken1(arbBalance0, arbBalance1);
                                const bottomTick = zeroToOne ? tickAfterFirstTickAboveMarginPrice : firstTickAboveMarginalPrice;
                                const topTick = zeroToOne ? firstTickAboveMarginalPrice : tickAfterFirstTickAboveMarginPrice;
                                // deposit max liquidity at the tick
                                const mintReceipt = await (await mint(wallet.address, bottomTick, topTick, BigInt('40564824043007195767232224305152'))).wait();
                                // sub the mint costs
                                const { amount0: amount0Mint, amount1: amount1Mint } = pool.interface.decodeEventLog(pool.interface.getEvent('Mint'), mintReceipt?.logs?.[2].data);
                                arbBalance0 = arbBalance0 - amount0Mint;
                                arbBalance1 = arbBalance1 - amount1Mint;
                                // execute the user's swap
                                const { executionPrice: executionPriceAfterFrontrun } = await simulateSwap(zeroToOne, inputAmount);
                                zeroToOne
                                    ? await swapExact0For1(inputAmount, wallet.address)
                                    : await swapExact1For0(inputAmount, wallet.address);
                                // burn the arb's liquidity
                                const { amount0: amount0Burn, amount1: amount1Burn } = await pool.burn.staticCall(bottomTick, topTick, BigInt('40564824043007195767232224305152'), '0x');
                                await pool.burn(bottomTick, topTick, BigInt('40564824043007195767232224305152'), '0x');
                                arbBalance0 = arbBalance0 + amount0Burn;
                                arbBalance1 = arbBalance1 + amount1Burn;
                                // add the fees as well
                                const { amount0: amount0CollectAndBurn, amount1: amount1CollectAndBurn } = await pool.collect.staticCall(arbitrageur.address, bottomTick, topTick, utilities_1.MaxUint128, utilities_1.MaxUint128);
                                const [amount0Collect, amount1Collect] = [
                                    amount0CollectAndBurn - amount0Burn,
                                    amount1CollectAndBurn - amount1Burn,
                                ];
                                arbBalance0 = arbBalance0 + amount0Collect;
                                arbBalance1 = arbBalance1 + amount1Collect;
                                const profitToken1AfterSandwich = valueToken1(arbBalance0, arbBalance1);
                                // backrun the swap to true price, i.e. swap to the marginal price = true price
                                const priceToSwapTo = zeroToOne
                                    ? applySqrtRatioBipsHundredthsDelta(assumedTruePriceAfterSwap, -feeAmount)
                                    : applySqrtRatioBipsHundredthsDelta(assumedTruePriceAfterSwap, feeAmount);
                                const { amount0Delta: backrunDelta0, amount1Delta: backrunDelta1, executionPrice: backrunExecutionPrice, } = await simulateSwap(!zeroToOne, ethers_1.MaxUint256 / 2n, priceToSwapTo);
                                await swapToHigherPrice(priceToSwapTo, wallet.address);
                                arbBalance0 = arbBalance0 - backrunDelta0;
                                arbBalance1 = arbBalance1 - backrunDelta1;
                                (0, expect_1.expect)({
                                    sandwichedPrice: (0, format_1.formatPrice)(executionPriceAfterFrontrun),
                                    arbBalanceDelta0: (0, format_1.formatTokenAmount)(arbBalance0),
                                    arbBalanceDelta1: (0, format_1.formatTokenAmount)(arbBalance1),
                                    profit: {
                                        final: (0, format_1.formatTokenAmount)(valueToken1(arbBalance0, arbBalance1)),
                                        afterFrontrun: (0, format_1.formatTokenAmount)(profitToken1AfterFrontRun),
                                        afterSandwich: (0, format_1.formatTokenAmount)(profitToken1AfterSandwich),
                                    },
                                    backrun: {
                                        executionPrice: (0, format_1.formatPrice)(backrunExecutionPrice),
                                        delta0: (0, format_1.formatTokenAmount)(backrunDelta0),
                                        delta1: (0, format_1.formatTokenAmount)(backrunDelta1),
                                    },
                                    frontrun: {
                                        executionPrice: (0, format_1.formatPrice)(frontrunExecutionPrice),
                                        delta0: (0, format_1.formatTokenAmount)(frontrunDelta0),
                                        delta1: (0, format_1.formatTokenAmount)(frontrunDelta1),
                                    },
                                    collect: {
                                        amount0: (0, format_1.formatTokenAmount)(amount0Collect),
                                        amount1: (0, format_1.formatTokenAmount)(amount1Collect),
                                    },
                                    burn: {
                                        amount0: (0, format_1.formatTokenAmount)(amount0Burn),
                                        amount1: (0, format_1.formatTokenAmount)(amount1Burn),
                                    },
                                    mint: {
                                        amount0: (0, format_1.formatTokenAmount)(amount0Mint),
                                        amount1: (0, format_1.formatTokenAmount)(amount1Mint),
                                    },
                                    finalPrice: (0, format_1.formatPrice)((await pool.globalState()).price),
                                }).to.matchSnapshot();
                            });
                            it('backrun to true price after swap only', async () => {
                                let arbBalance0 = 0n;
                                let arbBalance1 = 0n;
                                zeroToOne
                                    ? await swapExact0For1(inputAmount, wallet.address)
                                    : await swapExact1For0(inputAmount, wallet.address);
                                // swap to the marginal price = true price
                                const priceToSwapTo = zeroToOne
                                    ? applySqrtRatioBipsHundredthsDelta(assumedTruePriceAfterSwap, -feeAmount)
                                    : applySqrtRatioBipsHundredthsDelta(assumedTruePriceAfterSwap, feeAmount);
                                const { amount0Delta: backrunDelta0, amount1Delta: backrunDelta1, executionPrice: backrunExecutionPrice, } = await simulateSwap(!zeroToOne, ethers_1.MaxUint256 / 2n, priceToSwapTo);
                                zeroToOne
                                    ? await swapToHigherPrice(priceToSwapTo, wallet.address)
                                    : await swapToLowerPrice(priceToSwapTo, wallet.address);
                                arbBalance0 = arbBalance0 - backrunDelta0;
                                arbBalance1 = arbBalance1 - backrunDelta1;
                                (0, expect_1.expect)({
                                    arbBalanceDelta0: (0, format_1.formatTokenAmount)(arbBalance0),
                                    arbBalanceDelta1: (0, format_1.formatTokenAmount)(arbBalance1),
                                    profit: {
                                        final: (0, format_1.formatTokenAmount)(valueToken1(arbBalance0, arbBalance1)),
                                    },
                                    backrun: {
                                        executionPrice: (0, format_1.formatPrice)(backrunExecutionPrice),
                                        delta0: (0, format_1.formatTokenAmount)(backrunDelta0),
                                        delta1: (0, format_1.formatTokenAmount)(backrunDelta1),
                                    },
                                    finalPrice: (0, format_1.formatPrice)((await pool.globalState()).price),
                                }).to.matchSnapshot();
                            });
                        });
                    }
                });
            }
        });
    }
});
