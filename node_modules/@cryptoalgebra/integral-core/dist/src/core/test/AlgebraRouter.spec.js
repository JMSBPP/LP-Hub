"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
const hardhat_1 = require("hardhat");
const hardhat_network_helpers_1 = require("@nomicfoundation/hardhat-network-helpers");
const expect_1 = require("./shared/expect");
const fixtures_1 = require("./shared/fixtures");
const utilities_1 = require("./shared/utilities");
const tickSpacing = 60;
describe('AlgebraPoolRouter', () => {
    let wallet, other;
    let token0;
    let token1;
    let token2;
    let factory;
    let pool0;
    let pool1;
    let pool0Functions;
    let pool1Functions;
    let minTick;
    let maxTick;
    let swapTargetCallee;
    let swapTargetRouter;
    let createPool;
    before('create fixture loader', async () => {
        [wallet, other] = await hardhat_1.ethers.getSigners();
    });
    beforeEach('deploy first fixture', async () => {
        ({ token0, token1, token2, factory, createPool, swapTargetCallee, swapTargetRouter } = await (0, hardhat_network_helpers_1.loadFixture)(fixtures_1.poolFixture));
        const createPoolWrapped = async (firstToken, secondToken) => {
            const pool = await createPool(firstToken, secondToken);
            const poolFunctions = (0, utilities_1.createPoolFunctions)({
                swapTarget: swapTargetCallee,
                token0: firstToken,
                token1: secondToken,
                pool,
            });
            minTick = (0, utilities_1.getMinTick)(tickSpacing);
            maxTick = (0, utilities_1.getMaxTick)(tickSpacing);
            return [pool, poolFunctions];
        };
        // default to the 30 bips pool
        [pool0, pool0Functions] = await createPoolWrapped(token0, token1);
        [pool1, pool1Functions] = await createPoolWrapped(token1, token2);
    });
    it('constructor initializes immutables', async () => {
        (0, expect_1.expect)(await pool0.factory()).to.eq(await factory.getAddress());
        (0, expect_1.expect)(await pool0.token0()).to.eq(await token0.getAddress());
        (0, expect_1.expect)(await pool0.token1()).to.eq(await token1.getAddress());
        (0, expect_1.expect)(await pool1.factory()).to.eq(await factory.getAddress());
        (0, expect_1.expect)(await pool1.token0()).to.eq(await token1.getAddress());
        (0, expect_1.expect)(await pool1.token1()).to.eq(await token2.getAddress());
    });
    describe('multi-swaps', () => {
        let inputToken;
        let outputToken;
        beforeEach('initialize both pools', async () => {
            inputToken = token0;
            outputToken = token2;
            await pool0.initialize((0, utilities_1.encodePriceSqrt)(1, 1));
            await pool1.initialize((0, utilities_1.encodePriceSqrt)(1, 1));
            await pool0Functions.mint(wallet.address, minTick, maxTick, (0, utilities_1.expandTo18Decimals)(1));
            await pool1Functions.mint(wallet.address, minTick, maxTick, (0, utilities_1.expandTo18Decimals)(1));
        });
        it('multi-swap', async () => {
            const token0OfPoolOutput = await pool1.token0();
            (0, expect_1.expect)(token0OfPoolOutput).to.be.oneOf([await token1.getAddress(), await token2.getAddress()]);
            const ForExact0 = await outputToken.getAddress() === token0OfPoolOutput;
            const { swapForExact0Multi, swapForExact1Multi } = (0, utilities_1.createMultiPoolFunctions)({
                inputToken: token0,
                swapTarget: swapTargetRouter,
                poolInput: pool0,
                poolOutput: pool1,
            });
            const method = ForExact0 ? swapForExact0Multi : swapForExact1Multi;
            const [pool0Address, pool1Address, inputTokenAddress] = [
                await pool0.getAddress(),
                await pool1.getAddress(),
                await inputToken.getAddress()
            ];
            await (0, expect_1.expect)(method(100, wallet.address))
                .to.emit(outputToken, 'Transfer')
                .withArgs(pool1Address, wallet.address, 100)
                .to.emit(token1, 'Transfer')
                .withArgs(pool0Address, pool1Address, 102)
                .to.emit(inputToken, 'Transfer')
                .withArgs(wallet.address, pool0Address, 104);
        });
    });
});
