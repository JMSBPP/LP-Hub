"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
const hardhat_1 = require("hardhat");
const ethers_1 = require("ethers");
const expect_1 = require("./shared/expect");
describe('Tick', () => {
    let tickTest;
    beforeEach('deploy TickTest', async () => {
        const tickTestFactory = await hardhat_1.ethers.getContractFactory('TickTest');
        tickTest = (await tickTestFactory.deploy());
    });
    describe('#getInnerFeeGrowth', () => {
        it('returns all for two uninitialized ticks if tick is inside', async () => {
            const { innerFeeGrowth0Token, innerFeeGrowth1Token } = await tickTest.getInnerFeeGrowth(-2, 2, 0, 15, 15);
            (0, expect_1.expect)(innerFeeGrowth0Token).to.eq(15);
            (0, expect_1.expect)(innerFeeGrowth1Token).to.eq(15);
        });
        it('returns 0 for two uninitialized ticks if tick is above', async () => {
            const { innerFeeGrowth0Token, innerFeeGrowth1Token } = await tickTest.getInnerFeeGrowth(-2, 2, 4, 15, 15);
            (0, expect_1.expect)(innerFeeGrowth0Token).to.eq(0);
            (0, expect_1.expect)(innerFeeGrowth1Token).to.eq(0);
        });
        it('returns 0 for two uninitialized ticks if tick is below', async () => {
            const { innerFeeGrowth0Token, innerFeeGrowth1Token } = await tickTest.getInnerFeeGrowth(-2, 2, -4, 15, 15);
            (0, expect_1.expect)(innerFeeGrowth0Token).to.eq(0);
            (0, expect_1.expect)(innerFeeGrowth1Token).to.eq(0);
        });
        it('subtracts upper tick if below', async () => {
            await tickTest.setTick(2, {
                outerFeeGrowth0Token: 2,
                outerFeeGrowth1Token: 3,
                liquidityTotal: 0,
                liquidityDelta: 0,
                prevTick: 0,
                nextTick: 0,
            });
            const { innerFeeGrowth0Token, innerFeeGrowth1Token } = await tickTest.getInnerFeeGrowth(-2, 2, 0, 15, 15);
            (0, expect_1.expect)(innerFeeGrowth0Token).to.eq(13);
            (0, expect_1.expect)(innerFeeGrowth1Token).to.eq(12);
        });
        it('subtracts lower tick if above', async () => {
            await tickTest.setTick(-2, {
                outerFeeGrowth0Token: 2,
                outerFeeGrowth1Token: 3,
                liquidityTotal: 0,
                liquidityDelta: 0,
                prevTick: 0,
                nextTick: 0,
            });
            const { innerFeeGrowth0Token, innerFeeGrowth1Token } = await tickTest.getInnerFeeGrowth(-2, 2, 0, 15, 15);
            (0, expect_1.expect)(innerFeeGrowth0Token).to.eq(13);
            (0, expect_1.expect)(innerFeeGrowth1Token).to.eq(12);
        });
        it('subtracts upper and lower tick if inside', async () => {
            await tickTest.setTick(-2, {
                outerFeeGrowth0Token: 2,
                outerFeeGrowth1Token: 3,
                liquidityTotal: 0,
                liquidityDelta: 0,
                prevTick: 0,
                nextTick: 0,
            });
            await tickTest.setTick(2, {
                outerFeeGrowth0Token: 4,
                outerFeeGrowth1Token: 1,
                liquidityTotal: 0,
                liquidityDelta: 0,
                prevTick: 0,
                nextTick: 0,
            });
            const { innerFeeGrowth0Token, innerFeeGrowth1Token } = await tickTest.getInnerFeeGrowth(-2, 2, 0, 15, 15);
            (0, expect_1.expect)(innerFeeGrowth0Token).to.eq(9);
            (0, expect_1.expect)(innerFeeGrowth1Token).to.eq(11);
        });
        it('works correctly with overflow on inside tick', async () => {
            await tickTest.setTick(-2, {
                outerFeeGrowth0Token: ethers_1.MaxUint256 - 3n,
                outerFeeGrowth1Token: ethers_1.MaxUint256 - 2n,
                liquidityTotal: 0,
                liquidityDelta: 0,
                prevTick: 0,
                nextTick: 0,
            });
            await tickTest.setTick(2, {
                outerFeeGrowth0Token: 3,
                outerFeeGrowth1Token: 5,
                liquidityTotal: 0,
                liquidityDelta: 0,
                prevTick: 0,
                nextTick: 0,
            });
            const { innerFeeGrowth0Token, innerFeeGrowth1Token } = await tickTest.getInnerFeeGrowth(-2, 2, 0, 15, 15);
            (0, expect_1.expect)(innerFeeGrowth0Token).to.eq(16);
            (0, expect_1.expect)(innerFeeGrowth1Token).to.eq(13);
        });
    });
    describe('#update', async () => {
        it('flips from zero to nonzero', async () => {
            (0, expect_1.expect)(await tickTest.update.staticCall(0, 0, 1, 0, 0, false)).to.eq(true);
        });
        it('does not flip from nonzero to greater nonzero', async () => {
            await tickTest.update(0, 0, 1, 0, 0, false);
            (0, expect_1.expect)(await tickTest.update.staticCall(0, 0, 1, 0, 0, false)).to.eq(false);
        });
        it('flips from nonzero to zero', async () => {
            await tickTest.update(0, 0, 1, 0, 0, false);
            (0, expect_1.expect)(await tickTest.update.staticCall(0, 0, -1, 0, 0, false)).to.eq(true);
        });
        it('does not flip from nonzero to lesser nonzero', async () => {
            await tickTest.update(0, 0, 2, 0, 0, false);
            (0, expect_1.expect)(await tickTest.update.staticCall(0, 0, -1, 0, 0, false)).to.eq(false);
        });
        it('reverts if total liquidity gross is greater than max', async () => {
            const maxLiquidityPerTick = await tickTest.maxLiquidityPerTick();
            await tickTest.update(0, 0, maxLiquidityPerTick / 2n, 0, 0, false);
            await tickTest.update(0, 0, maxLiquidityPerTick / 2n, 0, 0, true);
            await (0, expect_1.expect)(tickTest.update(0, 0, maxLiquidityPerTick / 2n, 0, 0, false)).to.be.revertedWithCustomError(tickTest, 'liquidityOverflow');
        });
        it('nets the liquidity based on upper flag', async () => {
            await tickTest.update(0, 0, 2, 0, 0, false);
            await tickTest.update(0, 0, 1, 0, 0, true);
            await tickTest.update(0, 0, 3, 0, 0, true);
            await tickTest.update(0, 0, 1, 0, 0, false);
            const { liquidityTotal, liquidityDelta } = await tickTest.ticks(0);
            (0, expect_1.expect)(liquidityTotal).to.eq(2 + 1 + 3 + 1);
            (0, expect_1.expect)(liquidityDelta).to.eq(2 - 1 - 3 + 1);
        });
        it('reverts on overflow liquidity gross', async () => {
            const maxLiquidityPerTick = await tickTest.maxLiquidityPerTick();
            await tickTest.update(0, 0, maxLiquidityPerTick - 1n, 0, 0, false);
            await (0, expect_1.expect)(tickTest.update(0, 0, 2, 0, 0, false)).to.be.reverted;
        });
        it('assumes all growth happens below ticks lte current tick', async () => {
            await tickTest.update(1, 1, 1, 1, 2, false);
            const { outerFeeGrowth0Token, outerFeeGrowth1Token } = await tickTest.ticks(1);
            (0, expect_1.expect)(outerFeeGrowth0Token).to.eq(1);
            (0, expect_1.expect)(outerFeeGrowth1Token).to.eq(2);
        });
        it('does not set any growth fields if tick is already initialized', async () => {
            await tickTest.update(1, 1, 1, 1, 2, false);
            await tickTest.update(1, 1, 1, 6, 7, false);
            const { outerFeeGrowth0Token, outerFeeGrowth1Token } = await tickTest.ticks(1);
            (0, expect_1.expect)(outerFeeGrowth0Token).to.eq(1);
            (0, expect_1.expect)(outerFeeGrowth1Token).to.eq(2);
        });
        it('does not set any growth fields for ticks gt current tick', async () => {
            await tickTest.update(2, 1, 1, 1, 2, false);
            const { outerFeeGrowth0Token, outerFeeGrowth1Token, liquidityDelta } = await tickTest.ticks(2);
            (0, expect_1.expect)(outerFeeGrowth0Token).to.eq(0);
            (0, expect_1.expect)(outerFeeGrowth1Token).to.eq(0);
            (0, expect_1.expect)(liquidityDelta).to.be.eq(1);
        });
    });
    // this is skipped because the presence of the method causes slither to fail
    describe('#clear', async () => {
        it('deletes all the data in the tick', async () => {
            await tickTest.setTick(2, {
                outerFeeGrowth0Token: 1,
                outerFeeGrowth1Token: 2,
                liquidityTotal: 3,
                liquidityDelta: 4,
                prevTick: 0,
                nextTick: 0,
            });
            const before = await tickTest.ticks(2);
            (0, expect_1.expect)(before.outerFeeGrowth0Token).to.eq(1);
            (0, expect_1.expect)(before.outerFeeGrowth1Token).to.eq(2);
            (0, expect_1.expect)(before.liquidityTotal).to.eq(3);
            (0, expect_1.expect)(before.liquidityDelta).to.eq(4);
            await tickTest.clear(2);
            const { outerFeeGrowth0Token, outerFeeGrowth1Token, liquidityTotal, liquidityDelta } = await tickTest.ticks(2);
            (0, expect_1.expect)(outerFeeGrowth0Token).to.eq(0);
            (0, expect_1.expect)(outerFeeGrowth1Token).to.eq(0);
            (0, expect_1.expect)(liquidityTotal).to.eq(0);
            (0, expect_1.expect)(liquidityDelta).to.eq(0);
        });
    });
    describe('#cross', () => {
        it('flips the growth variables', async () => {
            await tickTest.setTick(2, {
                outerFeeGrowth0Token: 1,
                outerFeeGrowth1Token: 2,
                liquidityTotal: 3,
                liquidityDelta: 4,
                prevTick: 0,
                nextTick: 0,
            });
            await tickTest.cross(2, 7, 9);
            const { outerFeeGrowth0Token, outerFeeGrowth1Token } = await tickTest.ticks(2);
            (0, expect_1.expect)(outerFeeGrowth0Token).to.eq(6);
            (0, expect_1.expect)(outerFeeGrowth1Token).to.eq(7);
        });
        it('two flips are no op', async () => {
            await tickTest.setTick(2, {
                outerFeeGrowth0Token: 1,
                outerFeeGrowth1Token: 2,
                liquidityTotal: 3,
                liquidityDelta: 4,
                prevTick: 0,
                nextTick: 0,
            });
            await tickTest.cross(2, 7, 9);
            await tickTest.cross(2, 7, 9);
            const { outerFeeGrowth0Token, outerFeeGrowth1Token } = await tickTest.ticks(2);
            (0, expect_1.expect)(outerFeeGrowth0Token).to.eq(1);
            (0, expect_1.expect)(outerFeeGrowth1Token).to.eq(2);
        });
    });
    describe('#insertTick', () => {
        beforeEach('insert ticks', async () => {
            await tickTest.init();
        });
        it('works correct', async () => {
            await tickTest.insertTick(0, -887272, 887272);
            await tickTest.insertTick(100, 0, 887272);
            await tickTest.insertTick(-100, -887272, 0);
            const { prevTick, nextTick } = await tickTest.ticks(0);
            (0, expect_1.expect)(prevTick).to.eq(-100);
            (0, expect_1.expect)(nextTick).to.eq(100);
        });
        it('insert MAX tick', async () => {
            await tickTest.insertTick(887272, 0, 0);
            const { prevTick, nextTick } = await tickTest.ticks(887272);
            (0, expect_1.expect)(prevTick).to.eq(-887272);
            (0, expect_1.expect)(nextTick).to.eq(887272);
        });
        it('insert MIN tick', async () => {
            await tickTest.insertTick(-887272, 0, 0);
            const { prevTick, nextTick } = await tickTest.ticks(-887272);
            (0, expect_1.expect)(prevTick).to.eq(-887272);
            (0, expect_1.expect)(nextTick).to.eq(887272);
        });
        it('fails with incorrect input', async () => {
            await (0, expect_1.expect)(tickTest.insertTick(0, 887272, -887272)).to.be.revertedWithCustomError(tickTest, 'tickInvalidLinks');
            await (0, expect_1.expect)(tickTest.insertTick(0, -887272, -100)).to.be.revertedWithCustomError(tickTest, 'tickInvalidLinks');
        });
    });
    describe('#removeTick', () => {
        beforeEach('insert ticks', async () => {
            await tickTest.init();
            await tickTest.insertTick(0, -887272, 887272);
            await tickTest.insertTick(100, 0, 887272);
            await tickTest.insertTick(-100, -887272, 0);
        });
        it('works correct', async () => {
            await tickTest.removeTick(0);
            const { prevTick, nextTick } = await tickTest.ticks(0);
            (0, expect_1.expect)(prevTick).to.eq(0);
            (0, expect_1.expect)(nextTick).to.eq(0);
        });
        it('remove MIN tick', async () => {
            await tickTest.removeTick(-887272);
            const { prevTick, nextTick } = await tickTest.ticks(-887272);
            (0, expect_1.expect)(prevTick).to.eq(-887272);
            (0, expect_1.expect)(nextTick).to.eq(-100);
        });
        it('remove MAX tick', async () => {
            await tickTest.removeTick(887272);
            const { prevTick, nextTick } = await tickTest.ticks(887272);
            (0, expect_1.expect)(prevTick).to.eq(100);
            (0, expect_1.expect)(nextTick).to.eq(887272);
        });
        it('fails when remove not initialized tick', async () => {
            await (0, expect_1.expect)(tickTest.removeTick(1)).to.be.revertedWithCustomError(tickTest, 'tickIsNotInitialized');
        });
    });
});
