"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
const hardhat_1 = require("hardhat");
const ethers_1 = require("ethers");
const hardhat_network_helpers_1 = require("@nomicfoundation/hardhat-network-helpers");
const expect_1 = require("./shared/expect");
const fixtures_1 = require("./shared/fixtures");
const utilities_1 = require("./shared/utilities");
describe('AlgebraPool', () => {
    let wallet, other;
    let token0;
    let token1;
    let token2;
    let factory;
    let pool;
    let swapTarget;
    let swapToLowerPrice;
    let swapToHigherPrice;
    let swapExact0For1SupportingFee;
    let swapExact1For0SupportingFee;
    let swapExact0For1;
    let swap0ForExact1;
    let swapExact1For0;
    let swap1ForExact0;
    let tickSpacing;
    let minTick;
    let maxTick;
    let mint;
    let flash;
    let createPoolWrapped;
    let vaultAddress;
    beforeEach('deploy fixture', async () => {
        [wallet, other] = await hardhat_1.ethers.getSigners();
        let vault;
        let _createPool;
        ({
            token0,
            token1,
            token2,
            factory,
            vault,
            createPool: _createPool,
            swapTargetCallee: swapTarget,
        } = await (0, hardhat_network_helpers_1.loadFixture)(fixtures_1.poolFixture));
        vaultAddress = await vault.getAddress();
        createPoolWrapped = async () => {
            const pool = await _createPool();
            ({
                swapToLowerPrice,
                swapToHigherPrice,
                swapExact0For1,
                swapExact0For1SupportingFee,
                swap0ForExact1,
                swapExact1For0,
                swapExact1For0SupportingFee,
                swap1ForExact0,
                mint,
                flash,
            } = (0, utilities_1.createPoolFunctions)({
                token0,
                token1,
                swapTarget,
                pool,
            }));
            minTick = (0, utilities_1.getMinTick)(60);
            maxTick = (0, utilities_1.getMaxTick)(60);
            tickSpacing = 60;
            return pool;
        };
        pool = await createPoolWrapped();
    });
    it('constructor initializes immutables', async () => {
        (0, expect_1.expect)(await pool.factory()).to.eq(await factory.getAddress());
        (0, expect_1.expect)(await pool.token0()).to.eq(await token0.getAddress());
        (0, expect_1.expect)(await pool.token1()).to.eq(await token1.getAddress());
        (0, expect_1.expect)(await pool.maxLiquidityPerTick()).to.eq(BigInt('191757638537527648490752896198553'));
    });
    it('_blockTimestamp works', async () => {
        (0, expect_1.expect)(await pool.checkBlockTimestamp()).to.be.eq(true);
    });
    it('isUnlocked', async () => {
        (0, expect_1.expect)(await pool.isUnlocked()).to.be.true; // false checked inside of TestAlgebraReentrantCallee.sol
    });
    it('tickTreeRoot is clear', async () => {
        (0, expect_1.expect)(await pool.tickTreeRoot()).to.be.eq(0);
    });
    describe('#initialize', () => {
        it('fails if already initialized', async () => {
            await pool.initialize((0, utilities_1.encodePriceSqrt)(1, 1));
            await (0, expect_1.expect)(pool.initialize((0, utilities_1.encodePriceSqrt)(1, 1))).to.be.reverted;
        });
        it('fails if starting price is too low', async () => {
            await (0, expect_1.expect)(pool.initialize(1)).to.be.revertedWithCustomError(pool, 'priceOutOfRange');
            await (0, expect_1.expect)(pool.initialize(utilities_1.MIN_SQRT_RATIO - 1n)).to.be.revertedWithCustomError(pool, 'priceOutOfRange');
        });
        it('fails if starting price is too high', async () => {
            await (0, expect_1.expect)(pool.initialize(utilities_1.MAX_SQRT_RATIO)).to.be.revertedWithCustomError(pool, 'priceOutOfRange');
            await (0, expect_1.expect)(pool.initialize(2n ** 160n - 1n)).to.be.revertedWithCustomError(pool, 'priceOutOfRange');
        });
        it('fails if community fee nonzero without vault', async () => {
            await factory.setDefaultCommunityFee(100);
            await pool.setCommunityVault(ethers_1.ZeroAddress);
            await (0, expect_1.expect)(pool.initialize(utilities_1.MIN_SQRT_RATIO)).to.be.revertedWithCustomError(pool, 'invalidNewCommunityFee');
        });
        it('can be initialized at MIN_SQRT_RATIO', async () => {
            await pool.initialize(utilities_1.MIN_SQRT_RATIO);
            (0, expect_1.expect)((await pool.globalState()).tick).to.eq((0, utilities_1.getMinTick)(1));
        });
        it('can be initialized at MAX_SQRT_RATIO - 1', async () => {
            await pool.initialize(utilities_1.MAX_SQRT_RATIO - 1n);
            (0, expect_1.expect)((await pool.globalState()).tick).to.eq((0, utilities_1.getMaxTick)(1) - 1);
        });
        it('sets initial variables', async () => {
            const initPrice = (0, utilities_1.encodePriceSqrt)(1, 2);
            await pool.initialize(initPrice);
            const { price } = await pool.globalState();
            (0, expect_1.expect)(price).to.eq(price);
            //expect(timepointIndex).to.eq(0) TODO check plugin
            (0, expect_1.expect)((await pool.globalState()).tick).to.eq(-6932);
        });
        it('emits a Initialized event with the input tick', async () => {
            const price = (0, utilities_1.encodePriceSqrt)(1, 2);
            await (0, expect_1.expect)(pool.initialize(price)).to.emit(pool, 'Initialize').withArgs(price, -6932);
        });
        it('emits configuration events', async () => {
            const price = (0, utilities_1.encodePriceSqrt)(1, 2);
            await (0, expect_1.expect)(pool.initialize(price))
                .to.emit(pool, 'TickSpacing')
                .withArgs(tickSpacing)
                .to.emit(pool, 'CommunityFee')
                .withArgs(0);
        });
    });
    it('safelyGetStateOfAMM', async () => {
        await pool.initialize((0, utilities_1.encodePriceSqrt)(1, 1));
        const state = await pool.safelyGetStateOfAMM();
        (0, expect_1.expect)(state.sqrtPrice).to.eq((0, utilities_1.encodePriceSqrt)(1, 1));
        (0, expect_1.expect)(state.tick).to.eq(0);
        // revert case checked inside of TestAlgebraReentrantCallee.sol
    });
    describe('#mint', () => {
        it('fails if not initialized', async () => {
            await (0, expect_1.expect)(mint(wallet.address, -tickSpacing, tickSpacing, 1)).to.be.revertedWithCustomError(pool, 'notInitialized');
            await (0, expect_1.expect)(mint(wallet.address, (0, utilities_1.getMinTick)(1), (0, utilities_1.getMaxTick)(1), 100)).to.be.revertedWithCustomError(pool, 'notInitialized');
            await (0, expect_1.expect)(mint(wallet.address, 0, (0, utilities_1.getMaxTick)(1), 100)).to.be.revertedWithCustomError(pool, 'notInitialized');
            await (0, expect_1.expect)(mint(wallet.address, (0, utilities_1.getMinTick)(1), 0, 100)).to.be.revertedWithCustomError(pool, 'notInitialized');
            await (0, expect_1.expect)(mint(wallet.address, (0, utilities_1.getMaxTick)(1) - 1, (0, utilities_1.getMaxTick)(1), 100)).to.be.revertedWithCustomError(pool, 'notInitialized');
            await (0, expect_1.expect)(mint(wallet.address, (0, utilities_1.getMinTick)(1), (0, utilities_1.getMinTick)(1) + 1, 100)).to.be.revertedWithCustomError(pool, 'notInitialized');
        });
        describe('after initialization', () => {
            beforeEach('initialize the pool at price of 10:1', async () => {
                await pool.initialize((0, utilities_1.encodePriceSqrt)(1, 10));
                await mint(wallet.address, minTick, maxTick, 3161);
            });
            describe('failure cases', () => {
                describe('underpayment', () => {
                    let payer;
                    beforeEach(async () => {
                        const factory = await hardhat_1.ethers.getContractFactory('TestAlgebraSwapPay');
                        payer = (await factory.deploy());
                        await token0.approve(payer, 2n ** 256n - 1n);
                        await token1.approve(payer, 2n ** 256n - 1n);
                    });
                    it('fails if token0 paid 0', async () => {
                        await (0, expect_1.expect)(payer.mint(pool, wallet.address, minTick + tickSpacing, maxTick - tickSpacing, 100, 0, 100)).to.be.revertedWithCustomError(pool, 'zeroLiquidityActual');
                        await (0, expect_1.expect)(payer.mint(pool, wallet.address, -22980, 0, 10000, 0, 100)).to.be.revertedWithCustomError(pool, 'zeroLiquidityActual');
                    });
                    it('fails if token1 paid 0', async () => {
                        await (0, expect_1.expect)(payer.mint(pool, wallet.address, minTick + tickSpacing, maxTick - tickSpacing, 100, 100, 0)).to.be.revertedWithCustomError(pool, 'zeroLiquidityActual');
                        await (0, expect_1.expect)(payer.mint(pool, wallet.address, minTick + tickSpacing, Math.floor((-23028 - tickSpacing) / tickSpacing) * tickSpacing, 10000, 100, 0)).to.be.revertedWithCustomError(pool, 'zeroLiquidityActual');
                    });
                    it('fails if token0 hardly underpaid', async () => {
                        await (0, expect_1.expect)(payer.mint(pool, wallet.address, minTick + tickSpacing, maxTick - tickSpacing, 100, 1, (0, utilities_1.expandTo18Decimals)(100))).to.be.revertedWithCustomError(pool, 'zeroLiquidityActual');
                    });
                    it('fails if token1 hardly underpaid', async () => {
                        await swapToHigherPrice((0, utilities_1.encodePriceSqrt)(10, 1), wallet.address);
                        await (0, expect_1.expect)(payer.mint(pool, wallet.address, minTick + tickSpacing, maxTick - tickSpacing, 100, (0, utilities_1.expandTo18Decimals)(100), 1)).to.be.revertedWithCustomError(pool, 'zeroLiquidityActual');
                    });
                });
                it('fails if bottomTick greater than topTick', async () => {
                    await (0, expect_1.expect)(mint(wallet.address, 1, 0, 1)).to.be.revertedWithCustomError(pool, 'topTickLowerOrEqBottomTick');
                });
                it('fails if invalid tickspacing', async () => {
                    await (0, expect_1.expect)(mint(wallet.address, tickSpacing - 1, tickSpacing * 2 - 1, 1)).to.be.revertedWithCustomError(pool, 'tickIsNotSpaced');
                    await (0, expect_1.expect)(mint(wallet.address, -(tickSpacing - 1), 0, 1)).to.be.revertedWithCustomError(pool, 'tickIsNotSpaced');
                    await (0, expect_1.expect)(mint(wallet.address, 0, tickSpacing - 1, 1)).to.be.revertedWithCustomError(pool, 'tickIsNotSpaced');
                });
                it('fails if bottomTick less than min tick', async () => {
                    await (0, expect_1.expect)(mint(wallet.address, -887273, 0, 1)).to.be.revertedWithCustomError(pool, 'bottomTickLowerThanMIN');
                });
                it('fails if topTick greater than max tick', async () => {
                    await (0, expect_1.expect)(mint(wallet.address, 0, 887273, 1)).to.be.revertedWithCustomError(pool, 'topTickAboveMAX');
                });
                it('fails if amount exceeds the max', async () => {
                    const maxLiquidityGross = await pool.maxLiquidityPerTick();
                    await (0, expect_1.expect)(mint(wallet.address, minTick + tickSpacing, maxTick - tickSpacing, maxLiquidityGross + 1n)).to.be.revertedWithCustomError(pool, 'liquidityOverflow');
                    await (0, expect_1.expect)(mint(wallet.address, minTick + tickSpacing, maxTick - tickSpacing, maxLiquidityGross)).to.not.be
                        .reverted;
                });
                it('fails if amount exceeds the max uint128', async () => {
                    await (0, expect_1.expect)(mint(wallet.address, minTick + tickSpacing, maxTick - tickSpacing, utilities_1.MaxUint128)).to.be.reverted;
                });
                it('fails if amount exceeds the 2**127', async () => {
                    await (0, expect_1.expect)(mint(wallet.address, minTick + tickSpacing, maxTick - tickSpacing, 2n ** 127n)).to.be.reverted;
                });
                it('fails if total amount at tick exceeds the max', async () => {
                    await mint(wallet.address, minTick + tickSpacing, maxTick - tickSpacing, 1000);
                    const maxLiquidityGross = await pool.maxLiquidityPerTick();
                    await (0, expect_1.expect)(mint(wallet.address, minTick + tickSpacing, maxTick - tickSpacing, maxLiquidityGross - 1000n + 1n)).to.be.revertedWithCustomError(pool, 'liquidityOverflow');
                    await (0, expect_1.expect)(mint(wallet.address, minTick + tickSpacing * 2, maxTick - tickSpacing, maxLiquidityGross - 1000n + 1n)).to.be.revertedWithCustomError(pool, 'liquidityOverflow');
                    await (0, expect_1.expect)(mint(wallet.address, minTick + tickSpacing, maxTick - tickSpacing * 2, maxLiquidityGross - 1000n + 1n)).to.be.revertedWithCustomError(pool, 'liquidityOverflow');
                    await (0, expect_1.expect)(mint(wallet.address, minTick + tickSpacing, maxTick - tickSpacing, maxLiquidityGross - 1000n)).to
                        .not.be.reverted;
                });
                it('fails if amount is 0', async () => {
                    await (0, expect_1.expect)(mint(wallet.address, minTick + tickSpacing, maxTick - tickSpacing, 0)).to.be.revertedWithCustomError(pool, 'zeroLiquidityDesired');
                });
            });
            describe('success cases', () => {
                afterEach('check reserves', async () => {
                    const reserves = await pool.getReserves();
                    const balances = [await token0.balanceOf(pool), await token1.balanceOf(pool)];
                    (0, expect_1.expect)(reserves[0]).to.be.eq(balances[0]);
                    (0, expect_1.expect)(reserves[1]).to.be.eq(balances[1]);
                });
                it('initial balances', async () => {
                    (0, expect_1.expect)(await token0.balanceOf(pool)).to.eq(9996);
                    (0, expect_1.expect)(await token1.balanceOf(pool)).to.eq(1000);
                });
                it('initial tick', async () => {
                    (0, expect_1.expect)((await pool.globalState()).tick).to.eq(-23028);
                });
                it('emits event', async () => {
                    await (0, expect_1.expect)(mint(wallet.address, 0, tickSpacing, (0, utilities_1.expandTo18Decimals)(1)))
                        .to.emit(pool, 'Mint')
                        .withArgs(await swapTarget.getAddress(), wallet.address, 0, tickSpacing, (0, utilities_1.expandTo18Decimals)(1), '2995354955910781', 0);
                });
                const hasRefund = async (_receipt, _token, to) => {
                    const tokenAddress = await _token.getAddress();
                    if (!_receipt)
                        return false;
                    return _receipt.logs?.some((x) => {
                        if (x.address != tokenAddress)
                            return false;
                        const decoded = _token.interface.parseLog({ topics: [...x.topics], data: x.data });
                        if (!decoded)
                            return false;
                        return decoded.name == 'Transfer' && decoded.args && decoded.args[1] == to;
                    });
                };
                it('refund if overpayment', async () => {
                    const factory = await hardhat_1.ethers.getContractFactory('TestAlgebraSwapPay');
                    let payer = (await factory.deploy());
                    await token0.approve(payer, 2n ** 256n - 1n);
                    await token1.approve(payer, 2n ** 256n - 1n);
                    const receipt = await (await payer.mint(pool, wallet.address, minTick + tickSpacing, maxTick - tickSpacing, 10, (0, utilities_1.expandTo18Decimals)(1000), (0, utilities_1.expandTo18Decimals)(1000))).wait();
                    const hasRefund0 = await hasRefund(receipt, token0, wallet.address);
                    const hasRefund1 = await hasRefund(receipt, token1, wallet.address);
                    (0, expect_1.expect)(hasRefund0).to.be.true;
                    (0, expect_1.expect)(hasRefund1).to.be.true;
                });
                it('do not refund if not overpaid', async () => {
                    const factory = await hardhat_1.ethers.getContractFactory('TestAlgebraSwapPay');
                    let payer = (await factory.deploy());
                    await token0.approve(payer, 2n ** 256n - 1n);
                    await token1.approve(payer, 2n ** 256n - 1n);
                    const tx = await mint(wallet.address, minTick + tickSpacing, maxTick - tickSpacing, (0, utilities_1.expandTo18Decimals)(1000));
                    const receipt = await tx.wait();
                    const hasRefund0 = await hasRefund(receipt, token0, wallet.address);
                    const hasRefund1 = await hasRefund(receipt, token1, wallet.address);
                    (0, expect_1.expect)(hasRefund0).to.be.false;
                    (0, expect_1.expect)(hasRefund1).to.be.false;
                });
                describe('underpayment', () => {
                    let payer;
                    // TODO improve tests, check liquiditys
                    beforeEach(async () => {
                        const factory = await hardhat_1.ethers.getContractFactory('TestAlgebraSwapPay');
                        payer = (await factory.deploy());
                        await token0.approve(payer, 2n ** 256n - 1n);
                        await token1.approve(payer, 2n ** 256n - 1n);
                    });
                    it('handle underpayment in both tokens', async () => {
                        await (0, expect_1.expect)(payer.mint(pool, wallet.address, minTick + tickSpacing, maxTick - tickSpacing, 1000000, 100, 100)).to.not.be.reverted;
                    });
                    it('handle underpayment in both tokens, token0 less', async () => {
                        await (0, expect_1.expect)(payer.mint(pool, wallet.address, minTick + tickSpacing, maxTick - tickSpacing, 1000000, 50, 100)).to.not.be.reverted;
                    });
                    it('handle underpayment in both tokens, token1 less', async () => {
                        await (0, expect_1.expect)(payer.mint(pool, wallet.address, minTick + tickSpacing, maxTick - tickSpacing, 1000000, 100, 50)).to.not.be.reverted;
                    });
                    it('handle underpayment in token0', async () => {
                        await (0, expect_1.expect)(payer.mint(pool, wallet.address, minTick + tickSpacing, maxTick - tickSpacing, 1000000, 100, 100000000)).to.not.be.reverted;
                    });
                    it('handle underpayment in token1', async () => {
                        await (0, expect_1.expect)(payer.mint(pool, wallet.address, minTick + tickSpacing, maxTick - tickSpacing, 1000000, 100000000, 100)).to.not.be.reverted;
                    });
                });
                describe('above current price', () => {
                    it('transfers token0 only', async () => {
                        const poolAddress = await pool.getAddress();
                        await (0, expect_1.expect)(mint(wallet.address, -22980, 0, 10000))
                            .to.emit(token0, 'Transfer')
                            .withArgs(wallet.address, poolAddress, 21549)
                            .to.not.emit(token1, 'Transfer');
                        (0, expect_1.expect)(await token0.balanceOf(pool)).to.eq(9996 + 21549);
                        (0, expect_1.expect)(await token1.balanceOf(pool)).to.eq(1000);
                    });
                    it('max tick with max leverage', async () => {
                        await mint(wallet.address, maxTick - tickSpacing, maxTick, 2n ** 102n);
                        (0, expect_1.expect)(await token0.balanceOf(pool)).to.eq(9996 + 828011525);
                        (0, expect_1.expect)(await token1.balanceOf(pool)).to.eq(1000);
                    });
                    it('works for max tick', async () => {
                        await (0, expect_1.expect)(mint(wallet.address, -22980, maxTick, 10000))
                            .to.emit(token0, 'Transfer')
                            .withArgs(wallet.address, await pool.getAddress(), 31549);
                        (0, expect_1.expect)(await token0.balanceOf(pool)).to.eq(9996 + 31549);
                        (0, expect_1.expect)(await token1.balanceOf(pool)).to.eq(1000);
                    });
                    it('removing works', async () => {
                        await mint(wallet.address, -240, 0, 10000);
                        await pool.burn(-240, 0, 10000, '0x');
                        const { amount0, amount1 } = await pool.collect.staticCall(wallet.address, -240, 0, utilities_1.MaxUint128, utilities_1.MaxUint128);
                        (0, expect_1.expect)(amount0, 'amount0').to.eq(120);
                        (0, expect_1.expect)(amount1, 'amount1').to.eq(0);
                    });
                    it('removing works with min amounts', async () => {
                        await mint(wallet.address, -240, 0, 10000);
                        await pool.burn(-240, 0, 10000, '0x');
                        const { amount0, amount1 } = await pool.collect.staticCall(wallet.address, -240, 0, 1, 1);
                        (0, expect_1.expect)(amount0, 'amount0').to.eq(1);
                        (0, expect_1.expect)(amount1, 'amount1').to.eq(0);
                    });
                    it('removing works after tickSpacing increase', async () => {
                        await mint(wallet.address, -240, 0, 10000);
                        await pool.setTickSpacing(100);
                        await pool.burn(-240, 0, 10000, '0x');
                        const { amount0, amount1 } = await pool.collect.staticCall(wallet.address, -240, 0, utilities_1.MaxUint128, utilities_1.MaxUint128);
                        (0, expect_1.expect)(amount0, 'amount0').to.eq(120);
                        (0, expect_1.expect)(amount1, 'amount1').to.eq(0);
                    });
                    it('removing works after tickSpacing decrease', async () => {
                        await mint(wallet.address, -240, 0, 10000);
                        await pool.setTickSpacing(1);
                        await pool.burn(-240, 0, 10000, '0x');
                        const { amount0, amount1 } = await pool.collect.staticCall(wallet.address, -240, 0, utilities_1.MaxUint128, utilities_1.MaxUint128);
                        (0, expect_1.expect)(amount0, 'amount0').to.eq(120);
                        (0, expect_1.expect)(amount1, 'amount1').to.eq(0);
                    });
                    it('adds liquidity to liquidityTotal', async () => {
                        await mint(wallet.address, -240, 0, 100);
                        (0, expect_1.expect)((await pool.ticks(-240)).liquidityTotal).to.eq(100);
                        (0, expect_1.expect)((await pool.ticks(0)).liquidityTotal).to.eq(100);
                        (0, expect_1.expect)((await pool.ticks(tickSpacing)).liquidityTotal).to.eq(0);
                        (0, expect_1.expect)((await pool.ticks(tickSpacing * 2)).liquidityTotal).to.eq(0);
                        await mint(wallet.address, -240, tickSpacing, 150);
                        (0, expect_1.expect)((await pool.ticks(-240)).liquidityTotal).to.eq(250);
                        (0, expect_1.expect)((await pool.ticks(0)).liquidityTotal).to.eq(100);
                        (0, expect_1.expect)((await pool.ticks(tickSpacing)).liquidityTotal).to.eq(150);
                        (0, expect_1.expect)((await pool.ticks(tickSpacing * 2)).liquidityTotal).to.eq(0);
                        await mint(wallet.address, 0, tickSpacing * 2, 60);
                        (0, expect_1.expect)((await pool.ticks(-240)).liquidityTotal).to.eq(250);
                        (0, expect_1.expect)((await pool.ticks(0)).liquidityTotal).to.eq(160);
                        (0, expect_1.expect)((await pool.ticks(tickSpacing)).liquidityTotal).to.eq(150);
                        (0, expect_1.expect)((await pool.ticks(tickSpacing * 2)).liquidityTotal).to.eq(60);
                    });
                    it('removes liquidity from liquidityTotal', async () => {
                        await mint(wallet.address, -240, 0, 100);
                        await mint(wallet.address, -240, 0, 40);
                        await pool.burn(-240, 0, 90, '0x');
                        (0, expect_1.expect)((await pool.ticks(-240)).liquidityTotal).to.eq(50);
                        (0, expect_1.expect)((await pool.ticks(0)).liquidityTotal).to.eq(50);
                    });
                    it('clears tick lower if last position is removed', async () => {
                        await mint(wallet.address, -240, 0, 100);
                        await pool.burn(-240, 0, 100, '0x');
                        const { liquidityTotal, outerFeeGrowth0Token, outerFeeGrowth1Token } = await pool.ticks(-240);
                        (0, expect_1.expect)(liquidityTotal).to.eq(0);
                        (0, expect_1.expect)(outerFeeGrowth0Token).to.eq(0);
                        (0, expect_1.expect)(outerFeeGrowth1Token).to.eq(0);
                    });
                    it('clears tick upper if last position is removed', async () => {
                        await mint(wallet.address, -240, 0, 100);
                        await pool.burn(-240, 0, 100, '0x');
                        const { liquidityTotal, outerFeeGrowth0Token, outerFeeGrowth1Token } = await pool.ticks(0);
                        (0, expect_1.expect)(liquidityTotal).to.eq(0);
                        (0, expect_1.expect)(outerFeeGrowth0Token).to.eq(0);
                        (0, expect_1.expect)(outerFeeGrowth1Token).to.eq(0);
                    });
                    it('only clears the tick that is not used at all', async () => {
                        await mint(wallet.address, -240, 0, 100);
                        await mint(wallet.address, -tickSpacing, 0, 250);
                        await pool.burn(-240, 0, 100, '0x');
                        let { liquidityTotal, outerFeeGrowth0Token, outerFeeGrowth1Token } = await pool.ticks(-240);
                        (0, expect_1.expect)(liquidityTotal).to.eq(0);
                        (0, expect_1.expect)(outerFeeGrowth0Token).to.eq(0);
                        (0, expect_1.expect)(outerFeeGrowth1Token).to.eq(0);
                        ({ liquidityTotal, outerFeeGrowth0Token, outerFeeGrowth1Token } = await pool.ticks(-tickSpacing));
                        (0, expect_1.expect)(liquidityTotal).to.eq(250);
                        (0, expect_1.expect)(outerFeeGrowth0Token).to.eq(0);
                        (0, expect_1.expect)(outerFeeGrowth1Token).to.eq(0);
                    });
                });
                describe('including current price', () => {
                    it('price within range: transfers current price of both tokens', async () => {
                        const poolAddress = await pool.getAddress();
                        await (0, expect_1.expect)(mint(wallet.address, minTick + tickSpacing, maxTick - tickSpacing, 100))
                            .to.emit(token0, 'Transfer')
                            .withArgs(wallet.address, poolAddress, 317)
                            .to.emit(token1, 'Transfer')
                            .withArgs(wallet.address, poolAddress, 32);
                        (0, expect_1.expect)(await token0.balanceOf(pool)).to.eq(9996 + 317);
                        (0, expect_1.expect)(await token1.balanceOf(pool)).to.eq(1000 + 32);
                    });
                    it('initializes lower tick', async () => {
                        await mint(wallet.address, minTick + tickSpacing, maxTick - tickSpacing, 100);
                        const { liquidityTotal } = await pool.ticks(minTick + tickSpacing);
                        (0, expect_1.expect)(liquidityTotal).to.eq(100);
                    });
                    it('initializes upper tick', async () => {
                        await mint(wallet.address, minTick + tickSpacing, maxTick - tickSpacing, 100);
                        const { liquidityTotal } = await pool.ticks(maxTick - tickSpacing);
                        (0, expect_1.expect)(liquidityTotal).to.eq(100);
                    });
                    it('works for min/max tick', async () => {
                        const poolAddress = await pool.getAddress();
                        await (0, expect_1.expect)(mint(wallet.address, minTick, maxTick, 10000))
                            .to.emit(token0, 'Transfer')
                            .withArgs(wallet.address, poolAddress, 31623)
                            .to.emit(token1, 'Transfer')
                            .withArgs(wallet.address, poolAddress, 3163);
                        (0, expect_1.expect)(await token0.balanceOf(pool)).to.eq(9996 + 31623);
                        (0, expect_1.expect)(await token1.balanceOf(pool)).to.eq(1000 + 3163);
                    });
                    it('removing works', async () => {
                        await mint(wallet.address, minTick + tickSpacing, maxTick - tickSpacing, 100);
                        await pool.burn(minTick + tickSpacing, maxTick - tickSpacing, 100, '0x');
                        const { amount0, amount1 } = await pool.collect.staticCall(wallet.address, minTick + tickSpacing, maxTick - tickSpacing, utilities_1.MaxUint128, utilities_1.MaxUint128);
                        (0, expect_1.expect)(amount0, 'amount0').to.eq(316);
                        (0, expect_1.expect)(amount1, 'amount1').to.eq(31);
                    });
                });
                describe('below current price', () => {
                    it('transfers token1 only', async () => {
                        await (0, expect_1.expect)(mint(wallet.address, -46080, -23040, 10000))
                            .to.emit(token1, 'Transfer')
                            .withArgs(wallet.address, await pool.getAddress(), 2162)
                            .to.not.emit(token0, 'Transfer');
                        (0, expect_1.expect)(await token0.balanceOf(pool)).to.eq(9996);
                        (0, expect_1.expect)(await token1.balanceOf(pool)).to.eq(1000 + 2162);
                    });
                    it('min tick with max leverage', async () => {
                        await mint(wallet.address, minTick, minTick + tickSpacing, 2n ** 102n);
                        (0, expect_1.expect)(await token0.balanceOf(pool)).to.eq(9996);
                        (0, expect_1.expect)(await token1.balanceOf(pool)).to.eq(1000 + 828011520);
                    });
                    it('works for min tick', async () => {
                        await (0, expect_1.expect)(mint(wallet.address, minTick, -23040, 10000))
                            .to.emit(token1, 'Transfer')
                            .withArgs(wallet.address, await pool.getAddress(), 3161);
                        (0, expect_1.expect)(await token0.balanceOf(pool)).to.eq(9996);
                        (0, expect_1.expect)(await token1.balanceOf(pool)).to.eq(1000 + 3161);
                    });
                    it('removing works', async () => {
                        await mint(wallet.address, -46080, -46020, 10000);
                        await pool.burn(-46080, -46020, 10000, '0x');
                        const { amount0, amount1 } = await pool.collect.staticCall(wallet.address, -46080, -46020, utilities_1.MaxUint128, utilities_1.MaxUint128);
                        (0, expect_1.expect)(amount0, 'amount0').to.eq(0);
                        (0, expect_1.expect)(amount1, 'amount1').to.eq(3);
                    });
                });
            });
            it('community fees accumulate as expected during swap', async () => {
                await pool.setCommunityFee(170);
                await mint(wallet.address, minTick + tickSpacing, maxTick - tickSpacing, (0, utilities_1.expandTo18Decimals)(1));
                await swapExact0For1((0, utilities_1.expandTo18Decimals)(1) / 10n, wallet.address);
                await swapExact1For0((0, utilities_1.expandTo18Decimals)(1) / 100n, wallet.address);
                (0, expect_1.expect)((await token0.balanceOf(vaultAddress)).toString()).to.eq('8500000000000');
                const [, communityFeePending1] = await pool.getCommunityFeePending();
                (0, expect_1.expect)(communityFeePending1.toString()).to.eq('850000000000');
            });
            it('positions are protected before community fee is turned on', async () => {
                await mint(wallet.address, minTick + tickSpacing, maxTick - tickSpacing, (0, utilities_1.expandTo18Decimals)(1));
                await swapExact0For1((0, utilities_1.expandTo18Decimals)(1) / 10n, wallet.address);
                await swapExact1For0((0, utilities_1.expandTo18Decimals)(1) / 100n, wallet.address);
                (0, expect_1.expect)(Number((await token0.balanceOf(vaultAddress)).toString())).to.eq(0);
                (0, expect_1.expect)(Number((await token1.balanceOf(vaultAddress)).toString())).to.eq(0);
                await pool.setCommunityFee(170);
                (0, expect_1.expect)(Number((await token0.balanceOf(vaultAddress)).toString())).to.eq(0);
                (0, expect_1.expect)(Number((await token1.balanceOf(vaultAddress)).toString())).to.eq(0);
            });
            it('poke is not happened on uninitialized position', async () => {
                await mint(other.address, minTick + tickSpacing, maxTick - tickSpacing, (0, utilities_1.expandTo18Decimals)(1));
                await swapExact0For1((0, utilities_1.expandTo18Decimals)(1) / 10n, wallet.address);
                await swapExact1For0((0, utilities_1.expandTo18Decimals)(1) / 100n, wallet.address);
                await (0, expect_1.expect)(pool.burn(minTick + tickSpacing, maxTick - tickSpacing, 0, '0x')).to.be.not.reverted;
                let { liquidity: l0, innerFeeGrowth0Token: ifg0, innerFeeGrowth1Token: ifg1, fees1: f1, fees0: f0, } = await pool.positions(await pool.getKeyForPosition(wallet.address, minTick + tickSpacing, maxTick - tickSpacing));
                (0, expect_1.expect)(l0).to.eq(0);
                (0, expect_1.expect)(f0, 'tokens owed 0 before np').to.eq(0);
                (0, expect_1.expect)(f1, 'tokens owed 1 before np').to.eq(0);
                (0, expect_1.expect)(ifg0).to.eq('0');
                (0, expect_1.expect)(ifg1).to.eq('0');
                await mint(wallet.address, minTick + tickSpacing, maxTick - tickSpacing, 1);
                let { liquidity, innerFeeGrowth0Token, innerFeeGrowth1Token, fees1, fees0 } = await pool.positions(await pool.getKeyForPosition(wallet.address, minTick + tickSpacing, maxTick - tickSpacing));
                (0, expect_1.expect)(liquidity).to.eq(1);
                (0, expect_1.expect)(fees0, 'tokens owed 0 before').to.eq(0);
                (0, expect_1.expect)(fees1, 'tokens owed 1 before').to.eq(0);
                (0, expect_1.expect)(innerFeeGrowth0Token).to.eq('17014118346046869391540638517434263');
                (0, expect_1.expect)(innerFeeGrowth1Token).to.eq('1701411834604686939154063851743426');
                await pool.burn(minTick + tickSpacing, maxTick - tickSpacing, 1, '0x');
                ({ liquidity, innerFeeGrowth0Token, innerFeeGrowth1Token, fees1, fees0 } = await pool.positions(await pool.getKeyForPosition(wallet.address, minTick + tickSpacing, maxTick - tickSpacing)));
                (0, expect_1.expect)(liquidity).to.eq(0);
                (0, expect_1.expect)(innerFeeGrowth0Token).to.eq('17014118346046869391540638517434263');
                (0, expect_1.expect)(innerFeeGrowth1Token).to.eq('1701411834604686939154063851743426');
                (0, expect_1.expect)(fees0, 'tokens owed 0 after').to.eq(3);
                (0, expect_1.expect)(fees1, 'tokens owed 1 after').to.eq(0);
            });
        });
    });
    describe('#burn', () => {
        beforeEach('initialize at zero tick', () => initializeAtZeroTick(pool));
        async function checkTickIsClear(tick) {
            const { liquidityTotal, outerFeeGrowth0Token, outerFeeGrowth1Token, liquidityDelta } = await pool.ticks(tick);
            (0, expect_1.expect)(liquidityTotal).to.eq(0);
            (0, expect_1.expect)(outerFeeGrowth0Token).to.eq(0);
            (0, expect_1.expect)(outerFeeGrowth1Token).to.eq(0);
            (0, expect_1.expect)(liquidityDelta).to.eq(0);
        }
        async function checkTickIsNotClear(tick) {
            const { liquidityTotal } = await pool.ticks(tick);
            (0, expect_1.expect)(liquidityTotal).to.not.eq(0);
        }
        it('does not clear the position fee growth snapshot if no more liquidity', async () => {
            // some activity that would make the ticks non-zero
            await pool.advanceTime(10);
            await mint(other.address, minTick, maxTick, (0, utilities_1.expandTo18Decimals)(1));
            await swapExact0For1((0, utilities_1.expandTo18Decimals)(1), wallet.address);
            await swapExact1For0((0, utilities_1.expandTo18Decimals)(1), wallet.address);
            await pool.connect(other).burn(minTick, maxTick, (0, utilities_1.expandTo18Decimals)(1), '0x');
            const { liquidity, fees0, fees1, innerFeeGrowth0Token, innerFeeGrowth1Token } = await pool.positions(await pool.getKeyForPosition(other.address, minTick, maxTick));
            (0, expect_1.expect)(liquidity).to.eq(0);
            (0, expect_1.expect)(fees0).to.not.eq(0);
            (0, expect_1.expect)(fees1).to.not.eq(0);
            (0, expect_1.expect)(innerFeeGrowth0Token).to.eq('56713727820156410577229101238628035');
            (0, expect_1.expect)(innerFeeGrowth1Token).to.eq('56713727820156410577229101238628035');
        });
        it('clears the tick if its the last position using it', async () => {
            const bottomTick = minTick + tickSpacing;
            const topTick = maxTick - tickSpacing;
            // some activity that would make the ticks non-zero
            await pool.advanceTime(10);
            await mint(wallet.address, bottomTick, topTick, 1);
            await swapExact0For1((0, utilities_1.expandTo18Decimals)(1), wallet.address);
            await pool.burn(bottomTick, topTick, 1, '0x');
            await checkTickIsClear(bottomTick);
            await checkTickIsClear(topTick);
        });
        it('clears the tick if its the last position using it after tickSpacing increase', async () => {
            const bottomTick = minTick + tickSpacing;
            const topTick = maxTick - tickSpacing;
            // some activity that would make the ticks non-zero
            await pool.advanceTime(10);
            await mint(wallet.address, bottomTick, topTick, 1);
            await swapExact0For1((0, utilities_1.expandTo18Decimals)(1), wallet.address);
            await pool.setTickSpacing(200);
            await pool.burn(bottomTick, topTick, 1, '0x');
            await checkTickIsClear(bottomTick);
            await checkTickIsClear(topTick);
        });
        it('clears only the lower tick if upper is still used', async () => {
            const bottomTick = minTick + tickSpacing;
            const topTick = maxTick - tickSpacing;
            // some activity that would make the ticks non-zero
            await pool.advanceTime(10);
            await mint(wallet.address, bottomTick, topTick, 1);
            await mint(wallet.address, bottomTick + tickSpacing, topTick, 1);
            await swapExact0For1((0, utilities_1.expandTo18Decimals)(1), wallet.address);
            await pool.burn(bottomTick, topTick, 1, '0x');
            await checkTickIsClear(bottomTick);
            await checkTickIsNotClear(topTick);
        });
        it('clears only the lower tick if upper is still used after tickSpacing decrease', async () => {
            const bottomTick = minTick + tickSpacing;
            const topTick = maxTick - tickSpacing;
            // some activity that would make the ticks non-zero
            await pool.advanceTime(10);
            await mint(wallet.address, bottomTick, topTick, 1);
            await mint(wallet.address, bottomTick + tickSpacing, topTick, 1);
            await pool.setTickSpacing(5);
            await swapExact0For1((0, utilities_1.expandTo18Decimals)(1), wallet.address);
            await pool.burn(bottomTick, topTick, 1, '0x');
            await checkTickIsClear(bottomTick);
            await checkTickIsNotClear(topTick);
        });
        it('clears only the upper tick if lower is still used', async () => {
            const bottomTick = minTick + tickSpacing;
            const topTick = maxTick - tickSpacing;
            // some activity that would make the ticks non-zero
            await pool.advanceTime(10);
            await mint(wallet.address, bottomTick, topTick, 1);
            await mint(wallet.address, bottomTick, topTick - tickSpacing, 1);
            await swapExact0For1((0, utilities_1.expandTo18Decimals)(1), wallet.address);
            await pool.burn(bottomTick, topTick, 1, '0x');
            await checkTickIsNotClear(bottomTick);
            await checkTickIsClear(topTick);
        });
        it('clears only the upper tick if lower is still used after tickSpacing increase', async () => {
            const bottomTick = minTick + tickSpacing;
            const topTick = maxTick - tickSpacing;
            // some activity that would make the ticks non-zero
            await pool.advanceTime(10);
            await mint(wallet.address, bottomTick, topTick, 1);
            await mint(wallet.address, bottomTick, topTick - tickSpacing, 1);
            await pool.setTickSpacing(100);
            await swapExact0For1((0, utilities_1.expandTo18Decimals)(1), wallet.address);
            await pool.burn(bottomTick, topTick, 1, '0x');
            await checkTickIsNotClear(bottomTick);
            await checkTickIsClear(topTick);
        });
        it('fails when try to burn with incorrect ticks', async () => {
            const bottomTick = minTick + tickSpacing;
            const topTick = maxTick - tickSpacing;
            // some activity that would make the ticks non-zero
            await pool.advanceTime(10);
            await mint(wallet.address, bottomTick, topTick, 1);
            await swapExact0For1((0, utilities_1.expandTo18Decimals)(1), wallet.address);
            await (0, expect_1.expect)(pool.burn(topTick, bottomTick, 1, '0x')).to.be.revertedWithCustomError(pool, 'topTickLowerOrEqBottomTick');
        });
        it('fails when try to burn max uint128 value', async () => {
            const bottomTick = minTick + tickSpacing;
            const topTick = maxTick - tickSpacing;
            // some activity that would make the ticks non-zero
            await pool.advanceTime(10);
            await mint(wallet.address, bottomTick, topTick, 1);
            await swapExact0For1((0, utilities_1.expandTo18Decimals)(1), wallet.address);
            await (0, expect_1.expect)(pool.burn(bottomTick, topTick, 2n ** 128n - 1n, '0x')).to.be.revertedWithCustomError(pool, 'arithmeticError');
        });
        it('fails when try to burn max int128 + 1 value', async () => {
            const bottomTick = minTick + tickSpacing;
            const topTick = maxTick - tickSpacing;
            // some activity that would make the ticks non-zero
            await pool.advanceTime(10);
            await mint(wallet.address, bottomTick, topTick, 1);
            await swapExact0For1((0, utilities_1.expandTo18Decimals)(1), wallet.address);
            await (0, expect_1.expect)(pool.burn(bottomTick, topTick, 2n ** 127n, '0x')).to.be.revertedWithCustomError(pool, 'arithmeticError');
        });
        it('do not emit event after poke on empty position', async () => {
            const bottomTick = minTick + 2 * tickSpacing;
            const topTick = maxTick - 2 * tickSpacing;
            // some activity that would make the ticks non-zero
            await pool.advanceTime(10);
            await (0, expect_1.expect)(pool.burn(bottomTick, topTick, 0, '0x')).to.not.emit(pool, 'Burn');
        });
    });
    // the combined amount of liquidity that the pool is initialized with (including the 1 minimum liquidity that is burned)
    const initializeLiquidityAmount = (0, utilities_1.expandTo18Decimals)(2);
    async function initializeAtZeroTick(pool) {
        await pool.initialize((0, utilities_1.encodePriceSqrt)(1, 1));
        const tickSpacing = Number(await pool.tickSpacing());
        const [min, max] = [(0, utilities_1.getMinTick)(tickSpacing), (0, utilities_1.getMaxTick)(tickSpacing)];
        await mint(wallet.address, min, max, initializeLiquidityAmount);
    }
    describe('miscellaneous mint tests', () => {
        beforeEach('initialize at zero tick', async () => {
            pool = await createPoolWrapped();
            await initializeAtZeroTick(pool);
        });
        it('mint to the right of the current price', async () => {
            const liquidityDelta = 1000;
            const bottomTick = tickSpacing;
            const topTick = tickSpacing * 2;
            const liquidityBefore = await pool.liquidity();
            const b0 = await token0.balanceOf(pool);
            const b1 = await token1.balanceOf(pool);
            await mint(wallet.address, bottomTick, topTick, liquidityDelta);
            const liquidityAfter = await pool.liquidity();
            (0, expect_1.expect)(liquidityAfter).to.be.gte(liquidityBefore);
            (0, expect_1.expect)((await token0.balanceOf(pool)) - b0).to.eq(3);
            (0, expect_1.expect)((await token1.balanceOf(pool)) - b1).to.eq(0);
        });
        it('mint to the left of the current price', async () => {
            const liquidityDelta = 1000;
            const bottomTick = -tickSpacing * 2;
            const topTick = -tickSpacing;
            const liquidityBefore = await pool.liquidity();
            const b0 = await token0.balanceOf(pool);
            const b1 = await token1.balanceOf(pool);
            await mint(wallet.address, bottomTick, topTick, liquidityDelta);
            const liquidityAfter = await pool.liquidity();
            (0, expect_1.expect)(liquidityAfter).to.be.gte(liquidityBefore);
            (0, expect_1.expect)((await token0.balanceOf(pool)) - b0).to.eq(0);
            (0, expect_1.expect)((await token1.balanceOf(pool)) - b1).to.eq(3);
        });
        it('mint within the current price', async () => {
            const liquidityDelta = 1000;
            const bottomTick = -tickSpacing;
            const topTick = tickSpacing;
            const liquidityBefore = await pool.liquidity();
            const b0 = await token0.balanceOf(pool);
            const b1 = await token1.balanceOf(pool);
            await mint(wallet.address, bottomTick, topTick, liquidityDelta);
            const liquidityAfter = await pool.liquidity();
            (0, expect_1.expect)(liquidityAfter).to.be.gte(liquidityBefore);
            (0, expect_1.expect)((await token0.balanceOf(pool)) - b0).to.eq(3);
            (0, expect_1.expect)((await token1.balanceOf(pool)) - b1).to.eq(3);
        });
        it('cannot remove more than the entire position', async () => {
            const bottomTick = -tickSpacing;
            const topTick = tickSpacing;
            await mint(wallet.address, bottomTick, topTick, (0, utilities_1.expandTo18Decimals)(1000));
            await (0, expect_1.expect)(pool.burn(bottomTick, topTick, (0, utilities_1.expandTo18Decimals)(1001), '0x')).to.be.revertedWithCustomError(pool, 'liquiditySub');
        });
        it('collect fees within the current price after swap', async () => {
            const liquidityDelta = (0, utilities_1.expandTo18Decimals)(100);
            const bottomTick = -tickSpacing * 100;
            const topTick = tickSpacing * 100;
            await mint(wallet.address, bottomTick, topTick, liquidityDelta);
            const liquidityBefore = await pool.liquidity();
            const amount0In = (0, utilities_1.expandTo18Decimals)(1);
            await swapExact0For1(amount0In, wallet.address);
            const liquidityAfter = await pool.liquidity();
            (0, expect_1.expect)(liquidityAfter, 'k increases').to.be.gte(liquidityBefore);
            const token0BalanceBeforePool = await token0.balanceOf(pool);
            const token1BalanceBeforePool = await token1.balanceOf(pool);
            const token0BalanceBeforeWallet = await token0.balanceOf(wallet.address);
            const token1BalanceBeforeWallet = await token1.balanceOf(wallet.address);
            await pool.burn(bottomTick, topTick, 0, '0x');
            await pool.collect(wallet.address, bottomTick, topTick, utilities_1.MaxUint128, utilities_1.MaxUint128);
            await pool.burn(bottomTick, topTick, 0, '0x');
            const { amount0: fees0, amount1: fees1 } = await pool.collect.staticCall(wallet.address, bottomTick, topTick, utilities_1.MaxUint128, utilities_1.MaxUint128);
            (0, expect_1.expect)(fees0).to.be.eq(0);
            (0, expect_1.expect)(fees1).to.be.eq(0);
            const token0BalanceAfterWallet = await token0.balanceOf(wallet.address);
            const token1BalanceAfterWallet = await token1.balanceOf(wallet.address);
            const token0BalanceAfterPool = await token0.balanceOf(pool);
            const token1BalanceAfterPool = await token1.balanceOf(pool);
            (0, expect_1.expect)(token0BalanceAfterWallet).to.be.gt(token0BalanceBeforeWallet);
            (0, expect_1.expect)(token1BalanceAfterWallet).to.be.eq(token1BalanceBeforeWallet);
            (0, expect_1.expect)(token0BalanceAfterPool).to.be.lt(token0BalanceBeforePool);
            (0, expect_1.expect)(token1BalanceAfterPool).to.be.eq(token1BalanceBeforePool);
        });
    });
    describe('post-initialize at medium fee', () => {
        describe('k (implicit)', () => {
            it('returns 0 before initialization', async () => {
                (0, expect_1.expect)(await pool.liquidity()).to.eq(0);
            });
            describe('post initialized', () => {
                beforeEach(() => initializeAtZeroTick(pool));
                it('returns initial liquidity', async () => {
                    (0, expect_1.expect)(await pool.liquidity()).to.eq((0, utilities_1.expandTo18Decimals)(2));
                });
                it('returns in supply in range', async () => {
                    await mint(wallet.address, -tickSpacing, tickSpacing, (0, utilities_1.expandTo18Decimals)(3));
                    (0, expect_1.expect)(await pool.liquidity()).to.eq((0, utilities_1.expandTo18Decimals)(5));
                });
                it('excludes supply at tick above current tick', async () => {
                    await mint(wallet.address, tickSpacing, tickSpacing * 2, (0, utilities_1.expandTo18Decimals)(3));
                    (0, expect_1.expect)(await pool.liquidity()).to.eq((0, utilities_1.expandTo18Decimals)(2));
                });
                it('excludes supply at tick below current tick', async () => {
                    await mint(wallet.address, -tickSpacing * 2, -tickSpacing, (0, utilities_1.expandTo18Decimals)(3));
                    (0, expect_1.expect)(await pool.liquidity()).to.eq((0, utilities_1.expandTo18Decimals)(2));
                });
                it('updates correctly when exiting range', async () => {
                    const kBefore = await pool.liquidity();
                    (0, expect_1.expect)(kBefore).to.be.eq((0, utilities_1.expandTo18Decimals)(2));
                    // add liquidity at and above current tick
                    const liquidityDelta = (0, utilities_1.expandTo18Decimals)(1);
                    const bottomTick = 0;
                    const topTick = tickSpacing;
                    await mint(wallet.address, bottomTick, topTick, liquidityDelta);
                    // ensure virtual supply has increased appropriately
                    const kAfter = await pool.liquidity();
                    (0, expect_1.expect)(kAfter).to.be.eq((0, utilities_1.expandTo18Decimals)(3));
                    // swap toward the left (just enough for the tick transition function to trigger)
                    await swapExact0For1(1, wallet.address);
                    const { tick } = await pool.globalState();
                    (0, expect_1.expect)(tick).to.be.eq(-1);
                    const kAfterSwap = await pool.liquidity();
                    (0, expect_1.expect)(kAfterSwap).to.be.eq((0, utilities_1.expandTo18Decimals)(2));
                });
                it('updates correctly when entering range', async () => {
                    const kBefore = await pool.liquidity();
                    (0, expect_1.expect)(kBefore).to.be.eq((0, utilities_1.expandTo18Decimals)(2));
                    // add liquidity below the current tick
                    const liquidityDelta = (0, utilities_1.expandTo18Decimals)(1);
                    const bottomTick = -tickSpacing;
                    const topTick = 0;
                    await mint(wallet.address, bottomTick, topTick, liquidityDelta);
                    // ensure virtual supply hasn't changed
                    const kAfter = await pool.liquidity();
                    (0, expect_1.expect)(kAfter).to.be.eq(kBefore);
                    // swap toward the left (just enough for the tick transition function to trigger)
                    await swapExact0For1(1, wallet.address);
                    const { tick } = await pool.globalState();
                    (0, expect_1.expect)(tick).to.be.eq(-1);
                    const kAfterSwap = await pool.liquidity();
                    (0, expect_1.expect)(kAfterSwap).to.be.eq((0, utilities_1.expandTo18Decimals)(3));
                });
            });
        });
    });
    describe('limit orders', () => {
        beforeEach('initialize at tick 0', () => initializeAtZeroTick(pool));
        it('limit selling 0 for 1 at tick 0 thru 1', async () => {
            const poolAddress = await pool.getAddress();
            await (0, expect_1.expect)(mint(wallet.address, 0, 120, (0, utilities_1.expandTo18Decimals)(1)))
                .to.emit(token0, 'Transfer')
                .withArgs(wallet.address, poolAddress, '5981737760509663');
            // somebody takes the limit order
            await swapExact1For0((0, utilities_1.expandTo18Decimals)(2), other.address);
            await (0, expect_1.expect)(pool.burn(0, 120, (0, utilities_1.expandTo18Decimals)(1), '0x'))
                .to.emit(pool, 'Burn')
                .withArgs(wallet.address, 0, 120, (0, utilities_1.expandTo18Decimals)(1), 0, '6017734268818165')
                .to.not.emit(token0, 'Transfer')
                .to.not.emit(token1, 'Transfer');
            await (0, expect_1.expect)(pool.collect(wallet.address, 0, 120, utilities_1.MaxUint128, utilities_1.MaxUint128))
                .to.emit(token1, 'Transfer')
                .withArgs(poolAddress, wallet.address, BigInt('6020744641138734'))
                .to.not.emit(token0, 'Transfer');
            (0, expect_1.expect)((await pool.globalState()).tick).to.be.gte(120);
        });
        it('limit selling 1 for 0 at tick 0 thru -1', async () => {
            const poolAddress = await pool.getAddress();
            await (0, expect_1.expect)(mint(wallet.address, -120, 0, (0, utilities_1.expandTo18Decimals)(1)))
                .to.emit(token1, 'Transfer')
                .withArgs(wallet.address, poolAddress, '5981737760509663');
            // somebody takes the limit order
            await swapExact0For1((0, utilities_1.expandTo18Decimals)(2), other.address);
            await (0, expect_1.expect)(pool.burn(-120, 0, (0, utilities_1.expandTo18Decimals)(1), '0x'))
                .to.emit(pool, 'Burn')
                .withArgs(wallet.address, -120, 0, (0, utilities_1.expandTo18Decimals)(1), '6017734268818165', 0)
                .to.not.emit(token0, 'Transfer')
                .to.not.emit(token1, 'Transfer');
            await (0, expect_1.expect)(pool.collect(wallet.address, -120, 0, utilities_1.MaxUint128, utilities_1.MaxUint128))
                .to.emit(token0, 'Transfer')
                .withArgs(poolAddress, wallet.address, BigInt('6020744641138734'));
            (0, expect_1.expect)((await pool.globalState()).tick).to.be.lt(-120);
        });
        describe('fee is on', () => {
            beforeEach(() => pool.setCommunityFee(170));
            it('limit selling 0 for 1 at tick 0 thru 1', async () => {
                const poolAddress = await pool.getAddress();
                await (0, expect_1.expect)(mint(wallet.address, 0, 120, (0, utilities_1.expandTo18Decimals)(1)))
                    .to.emit(token0, 'Transfer')
                    .withArgs(wallet.address, poolAddress, '5981737760509663');
                // somebody takes the limit order
                await swapExact1For0((0, utilities_1.expandTo18Decimals)(2), other.address);
                await (0, expect_1.expect)(pool.burn(0, 120, (0, utilities_1.expandTo18Decimals)(1), '0x'))
                    .to.emit(pool, 'Burn')
                    .withArgs(wallet.address, 0, 120, (0, utilities_1.expandTo18Decimals)(1), 0, '6017734268818165')
                    .to.not.emit(token0, 'Transfer')
                    .to.not.emit(token1, 'Transfer');
                await (0, expect_1.expect)(pool.collect(wallet.address, 0, 120, utilities_1.MaxUint128, utilities_1.MaxUint128))
                    .to.emit(token1, 'Transfer')
                    .withArgs(poolAddress, wallet.address, BigInt('6017734268818165') + 2498609026072n);
                (0, expect_1.expect)((await pool.globalState()).tick).to.be.gte(120);
            });
            it('limit selling 1 for 0 at tick 0 thru -1', async () => {
                const poolAddress = await pool.getAddress();
                await (0, expect_1.expect)(mint(wallet.address, -120, 0, (0, utilities_1.expandTo18Decimals)(1)))
                    .to.emit(token1, 'Transfer')
                    .withArgs(wallet.address, poolAddress, '5981737760509663');
                // somebody takes the limit order
                await swapExact0For1((0, utilities_1.expandTo18Decimals)(2), other.address);
                await (0, expect_1.expect)(pool.burn(-120, 0, (0, utilities_1.expandTo18Decimals)(1), '0x'))
                    .to.emit(pool, 'Burn')
                    .withArgs(wallet.address, -120, 0, (0, utilities_1.expandTo18Decimals)(1), '6017734268818165', 0)
                    .to.not.emit(token0, 'Transfer')
                    .to.not.emit(token1, 'Transfer');
                await (0, expect_1.expect)(pool.collect(wallet.address, -120, 0, utilities_1.MaxUint128, utilities_1.MaxUint128))
                    .to.emit(token0, 'Transfer')
                    .withArgs(poolAddress, wallet.address, BigInt('6017734268818165') + 2498609026072n);
                (0, expect_1.expect)((await pool.globalState()).tick).to.be.lt(-120);
            });
        });
    });
    describe('#swaps', () => {
        describe('#swap', async () => {
            it('fails if not initialized', async () => {
                await (0, expect_1.expect)(swapToLowerPrice((0, utilities_1.encodePriceSqrt)(1, 5), other.address)).to.be.revertedWithCustomError(pool, 'notInitialized');
            });
            describe('after initialization', () => {
                beforeEach('initialize the pool at price of 10:1', async () => {
                    await pool.initialize((0, utilities_1.encodePriceSqrt)(1, 10));
                });
                describe('swaps without liquidity', async () => {
                    it('can swap to max tick', async () => {
                        await swapExact1For0(1, wallet.address);
                        const tick = (await pool.globalState()).tick;
                        (0, expect_1.expect)(tick).to.be.eq(utilities_1.MAX_TICK - 1);
                    });
                    it('can swap to min tick', async () => {
                        await swapExact0For1(1, wallet.address);
                        const tick = (await pool.globalState()).tick;
                        (0, expect_1.expect)(tick).to.be.eq(utilities_1.MIN_TICK);
                    });
                    it('can swap through whole price range', async () => {
                        await swapExact0For1(1, wallet.address);
                        let tick = (await pool.globalState()).tick;
                        (0, expect_1.expect)(tick).to.be.eq(utilities_1.MIN_TICK);
                        await swapExact1For0(1, wallet.address);
                        tick = (await pool.globalState()).tick;
                        (0, expect_1.expect)(tick).to.be.eq(utilities_1.MAX_TICK - 1);
                        await swapExact0For1(1, wallet.address);
                        tick = (await pool.globalState()).tick;
                        (0, expect_1.expect)(tick).to.be.eq(utilities_1.MIN_TICK);
                    });
                    it('can swap to lower price', async () => {
                        await swapExact0For1(1, wallet.address, (0, utilities_1.encodePriceSqrt)(1, 1000));
                        const price = (await pool.globalState()).price;
                        (0, expect_1.expect)(price).to.be.eq((0, utilities_1.encodePriceSqrt)(1, 1000));
                    });
                    it('can swap to higher price', async () => {
                        await swapExact1For0(1, wallet.address, (0, utilities_1.encodePriceSqrt)(1000, 1));
                        const price = (await pool.globalState()).price;
                        (0, expect_1.expect)(price).to.be.eq((0, utilities_1.encodePriceSqrt)(1000, 1));
                    });
                });
                it('fails if required int256.min', async () => {
                    await mint(wallet.address, minTick, maxTick, 3161);
                    await (0, expect_1.expect)(pool.swap(other.address, true, '-57896044618658097711785492504343953926634992332820282019728792003956564819968', 0, '0x')).to.be.revertedWithCustomError(pool, 'invalidAmountRequired');
                });
            });
        });
        describe('#swapWithPaymentInAdvance', async () => {
            it('fails if not initialized', async () => {
                await (0, expect_1.expect)(swapExact0For1SupportingFee(100, other.address)).to.be.revertedWithCustomError(pool, 'notInitialized');
            });
            describe('after initialization', () => {
                beforeEach('initialize the pool at price of 10:1', async () => {
                    await pool.initialize((0, utilities_1.encodePriceSqrt)(1, 10));
                    await mint(wallet.address, minTick, maxTick, 3161);
                });
                it('fails if required negative amount', async () => {
                    await (0, expect_1.expect)(pool.swapWithPaymentInAdvance(other.address, other.address, true, '-1', 0, '0x')).to.be.revertedWithCustomError(pool, 'invalidAmountRequired');
                });
                it('fails if required 0 amount', async () => {
                    await (0, expect_1.expect)(swapExact0For1SupportingFee(0, other.address)).to.be.revertedWithCustomError(pool, 'insufficientInputAmount');
                });
                it('fails if required uint128 max amount', async () => {
                    await (0, expect_1.expect)(swapExact0For1SupportingFee(2n ** 128n - 1n, other.address)).to.be.reverted;
                });
                it('fails if required int256 max amount', async () => {
                    await (0, expect_1.expect)(swapExact0For1SupportingFee(2n ** 255n - 1n, other.address)).to.be.reverted;
                });
                it('fails if required min256 amount', async () => {
                    await (0, expect_1.expect)(pool.swapWithPaymentInAdvance(other.address, other.address, true, '-57896044618658097711785492504343953926634992332820282019728792003956564819968', 0, '0x')).to.be.revertedWithCustomError(pool, 'invalidAmountRequired');
                });
                it('pass correct amounts to callback', async () => {
                    await (0, expect_1.expect)(swapExact0For1SupportingFee((0, utilities_1.expandTo18Decimals)(1), wallet.address))
                        .to.emit(swapTarget, 'SwapCallback')
                        .withArgs((0, utilities_1.expandTo18Decimals)(1), 0);
                    await (0, expect_1.expect)(swapExact1For0SupportingFee((0, utilities_1.expandTo18Decimals)(1), wallet.address))
                        .to.emit(swapTarget, 'SwapCallback')
                        .withArgs(0, (0, utilities_1.expandTo18Decimals)(1));
                });
            });
        });
    });
    describe('#collect', () => {
        beforeEach(async () => {
            pool = await createPoolWrapped();
            await pool.initialize((0, utilities_1.encodePriceSqrt)(1, 1));
        });
        afterEach('check reserves', async () => {
            const reserves = await pool.getReserves();
            const balances = [await token0.balanceOf(pool), await token1.balanceOf(pool)];
            (0, expect_1.expect)(reserves[0]).to.be.eq(balances[0]);
            (0, expect_1.expect)(reserves[1]).to.be.eq(balances[1]);
        });
        it('works with multiple LPs', async () => {
            await mint(wallet.address, minTick, maxTick, (0, utilities_1.expandTo18Decimals)(1));
            await mint(wallet.address, minTick + tickSpacing, maxTick - tickSpacing, (0, utilities_1.expandTo18Decimals)(2));
            await swapExact0For1((0, utilities_1.expandTo18Decimals)(1), wallet.address);
            // poke positions
            await pool.burn(minTick, maxTick, 0, '0x');
            await pool.burn(minTick + tickSpacing, maxTick - tickSpacing, 0, '0x');
            const { fees0: fees0Position0 } = await pool.positions(await (0, utilities_1.getPositionKey)(wallet.address, minTick, maxTick, pool));
            const { fees0: fees0Position1 } = await pool.positions(await (0, utilities_1.getPositionKey)(wallet.address, minTick + tickSpacing, maxTick - tickSpacing, pool));
            (0, expect_1.expect)(fees0Position0).to.be.eq('166666666666666');
            (0, expect_1.expect)(fees0Position1).to.be.eq('333333333333333');
        });
        it('collect part of fees', async () => {
            await mint(wallet.address, minTick, maxTick, (0, utilities_1.expandTo18Decimals)(1));
            await swapExact0For1((0, utilities_1.expandTo18Decimals)(1), wallet.address);
            await swapExact1For0((0, utilities_1.expandTo18Decimals)(1), wallet.address);
            await pool.burn(minTick, maxTick, 0, '0x');
            const { fees0: fees0Position0before, fees1: fees0Position1before } = await pool.positions(await (0, utilities_1.getPositionKey)(wallet.address, minTick, maxTick, pool));
            (0, expect_1.expect)(fees0Position0before).to.eq('499999999999999');
            (0, expect_1.expect)(fees0Position1before).to.eq('499999999999999');
            // collect the fees
            await pool.collect(wallet.address, minTick, maxTick, 1000, 1000);
            const { fees0: fees0Position0, fees1: fees0Position1 } = await pool.positions(await (0, utilities_1.getPositionKey)(wallet.address, minTick, maxTick, pool));
            (0, expect_1.expect)(fees0Position0).to.be.eq('499999999998999');
            (0, expect_1.expect)(fees0Position1).to.be.eq('499999999998999');
        });
        it('emits event', async () => {
            await mint(wallet.address, minTick, maxTick, (0, utilities_1.expandTo18Decimals)(1));
            await swapExact0For1((0, utilities_1.expandTo18Decimals)(1), wallet.address);
            await swapExact1For0((0, utilities_1.expandTo18Decimals)(1), wallet.address);
            await pool.burn(minTick, maxTick, 0, '0x');
            await (0, expect_1.expect)(pool.collect(wallet.address, minTick, maxTick, 1000, 1000))
                .to.emit(pool, 'Collect')
                .withArgs(wallet.address, wallet.address, minTick, maxTick, 1000, 1000);
        });
        it('do not emit event if 0 collected', async () => {
            await mint(wallet.address, minTick, maxTick, (0, utilities_1.expandTo18Decimals)(1));
            await (0, expect_1.expect)(pool.collect(wallet.address, minTick, maxTick, 0, 0)).to.not.emit(pool, 'Collect');
        });
        it('works with multiple LPs after tickSpacing increase', async () => {
            await mint(wallet.address, minTick, maxTick, (0, utilities_1.expandTo18Decimals)(1));
            await mint(wallet.address, minTick + tickSpacing, maxTick - tickSpacing, (0, utilities_1.expandTo18Decimals)(2));
            await swapExact0For1((0, utilities_1.expandTo18Decimals)(1), wallet.address);
            await pool.setTickSpacing(200);
            // poke positions
            await pool.burn(minTick, maxTick, 0, '0x');
            await pool.burn(minTick + tickSpacing, maxTick - tickSpacing, 0, '0x');
            const { fees0: fees0Position0 } = await pool.positions(await (0, utilities_1.getPositionKey)(wallet.address, minTick, maxTick, pool));
            const { fees0: fees0Position1 } = await pool.positions(await (0, utilities_1.getPositionKey)(wallet.address, minTick + tickSpacing, maxTick - tickSpacing, pool));
            (0, expect_1.expect)(fees0Position0).to.be.eq('166666666666666');
            (0, expect_1.expect)(fees0Position1).to.be.eq('333333333333333');
        });
        it('works with multiple LPs after tickSpacing decrease', async () => {
            await mint(wallet.address, minTick, maxTick, (0, utilities_1.expandTo18Decimals)(1));
            await mint(wallet.address, minTick + tickSpacing, maxTick - tickSpacing, (0, utilities_1.expandTo18Decimals)(2));
            await pool.setTickSpacing(1);
            await swapExact0For1((0, utilities_1.expandTo18Decimals)(1), wallet.address);
            // poke positions
            await pool.burn(minTick, maxTick, 0, '0x');
            await pool.burn(minTick + tickSpacing, maxTick - tickSpacing, 0, '0x');
            const { fees0: fees0Position0 } = await pool.positions(await (0, utilities_1.getPositionKey)(wallet.address, minTick, maxTick, pool));
            const { fees0: fees0Position1 } = await pool.positions(await (0, utilities_1.getPositionKey)(wallet.address, minTick + tickSpacing, maxTick - tickSpacing, pool));
            (0, expect_1.expect)(fees0Position0).to.be.eq('166666666666666');
            (0, expect_1.expect)(fees0Position1).to.be.eq('333333333333333');
        });
        it('works with zero fee', async () => {
            await mint(wallet.address, minTick, maxTick, (0, utilities_1.expandTo18Decimals)(1));
            await pool.setFee(0);
            await swap0ForExact1((0, utilities_1.expandTo18Decimals)(1), other.address);
            await pool.burn(minTick, maxTick, 0, '0x');
            const { fees0: fee0, fees1: fee1 } = await pool.positions(await (0, utilities_1.getPositionKey)(wallet.address, minTick, maxTick, pool));
            (0, expect_1.expect)(fee0).to.be.eq(0);
            (0, expect_1.expect)(fee1).to.be.eq(0);
        });
        it('works with uint16.max fee', async () => {
            let amount = (0, utilities_1.expandTo18Decimals)(1);
            await mint(wallet.address, minTick, maxTick, amount);
            await pool.setFee(65535);
            await swapExact1For0(amount, other.address);
            await pool.burn(minTick, maxTick, 0, '0x');
            const { fees0: fee0, fees1: fee1 } = await pool.positions(await (0, utilities_1.getPositionKey)(wallet.address, minTick, maxTick, pool));
            (0, expect_1.expect)(fee0).to.be.eq(0);
            (0, expect_1.expect)(fee1).to.be.eq((amount * 65535n) / 1000000n - 1n);
        });
        describe('works across large increases', () => {
            beforeEach(async () => {
                await mint(wallet.address, minTick, maxTick, (0, utilities_1.expandTo18Decimals)(1));
            });
            // type(uint128).max * 2**128 / 1e18
            // https://www.wolframalpha.com/input/?i=%282**128+-+1%29+*+2**128+%2F+1e18
            const magicNumber = BigInt('115792089237316195423570985008687907852929702298719625575994');
            it('works just before the cap binds', async () => {
                await pool.setTotalFeeGrowth0Token(magicNumber);
                await pool.burn(minTick, maxTick, 0, '0x');
                const { fees0, fees1 } = await pool.positions(await (0, utilities_1.getPositionKey)(wallet.address, minTick, maxTick, pool));
                (0, expect_1.expect)(fees0).to.be.eq(utilities_1.MaxUint128 - 1n);
                (0, expect_1.expect)(fees1).to.be.eq(0);
            });
            it('works just after the cap binds', async () => {
                await pool.setTotalFeeGrowth0Token(magicNumber + 1n);
                await pool.burn(minTick, maxTick, 0, '0x');
                const { fees0, fees1 } = await pool.positions(await (0, utilities_1.getPositionKey)(wallet.address, minTick, maxTick, pool));
                (0, expect_1.expect)(fees0).to.be.eq(utilities_1.MaxUint128);
                (0, expect_1.expect)(fees1).to.be.eq(0);
            });
            it('works well after the cap binds', async () => {
                await pool.setTotalFeeGrowth0Token(ethers_1.MaxUint256);
                await pool.burn(minTick, maxTick, 0, '0x');
                const { fees0, fees1 } = await pool.positions(await (0, utilities_1.getPositionKey)(wallet.address, minTick, maxTick, pool));
                (0, expect_1.expect)(fees0).to.be.eq(utilities_1.MaxUint128);
                (0, expect_1.expect)(fees1).to.be.eq(0);
            });
        });
        describe('works across overflow boundaries', () => {
            beforeEach(async () => {
                await pool.setTotalFeeGrowth0Token(ethers_1.MaxUint256);
                await pool.setTotalFeeGrowth1Token(ethers_1.MaxUint256);
                await mint(wallet.address, minTick, maxTick, (0, utilities_1.expandTo18Decimals)(10));
            });
            it('token0', async () => {
                await swapExact0For1((0, utilities_1.expandTo18Decimals)(1), wallet.address);
                await pool.burn(minTick, maxTick, 0, '0x');
                const { amount0, amount1 } = await pool.collect.staticCall(wallet.address, minTick, maxTick, utilities_1.MaxUint128, utilities_1.MaxUint128);
                (0, expect_1.expect)(amount0).to.be.eq('499999999999999');
                (0, expect_1.expect)(amount1).to.be.eq(0);
            });
            it('unexpected donation', async () => {
                await token1.transfer(pool, (0, utilities_1.expandTo18Decimals)(1));
                await token0.transfer(pool, (0, utilities_1.expandTo18Decimals)(2));
                await pool.burn(minTick, maxTick, 0, '0x');
                const { amount0, amount1 } = await pool.collect.staticCall(wallet.address, minTick, maxTick, utilities_1.MaxUint128, utilities_1.MaxUint128);
                (0, expect_1.expect)(amount0).to.be.eq('1999999999999999999');
                (0, expect_1.expect)(amount1).to.be.eq('999999999999999999');
            });
            it('token0 with unexpected donation before burn', async () => {
                await swapExact0For1((0, utilities_1.expandTo18Decimals)(1), wallet.address);
                await token0.transfer(pool, (0, utilities_1.expandTo18Decimals)(1));
                await pool.burn(minTick, maxTick, 0, '0x');
                const { amount0, amount1 } = await pool.collect.staticCall(wallet.address, minTick, maxTick, utilities_1.MaxUint128, utilities_1.MaxUint128);
                (0, expect_1.expect)(amount0).to.be.eq('1000499999999999999');
                (0, expect_1.expect)(amount1).to.be.eq(0);
            });
            it('token0 with unexpected donation before swap', async () => {
                await token0.transfer(pool, (0, utilities_1.expandTo18Decimals)(1));
                await swapExact0For1((0, utilities_1.expandTo18Decimals)(1), wallet.address);
                await pool.burn(minTick, maxTick, 0, '0x');
                const { amount0, amount1 } = await pool.collect.staticCall(wallet.address, minTick, maxTick, utilities_1.MaxUint128, utilities_1.MaxUint128);
                (0, expect_1.expect)(amount0).to.be.eq('1000499999999999999');
                (0, expect_1.expect)(amount1).to.be.eq(0);
            });
            it('token1', async () => {
                await swapExact1For0((0, utilities_1.expandTo18Decimals)(1), wallet.address);
                await pool.burn(minTick, maxTick, 0, '0x');
                const { amount0, amount1 } = await pool.collect.staticCall(wallet.address, minTick, maxTick, utilities_1.MaxUint128, utilities_1.MaxUint128);
                (0, expect_1.expect)(amount0).to.be.eq(0);
                (0, expect_1.expect)(amount1).to.be.eq('499999999999999');
            });
            it('token1 with unexpected donation before burn', async () => {
                await swapExact1For0((0, utilities_1.expandTo18Decimals)(1), wallet.address);
                await token1.transfer(pool, (0, utilities_1.expandTo18Decimals)(1));
                await pool.burn(minTick, maxTick, 0, '0x');
                const { amount0, amount1 } = await pool.collect.staticCall(wallet.address, minTick, maxTick, utilities_1.MaxUint128, utilities_1.MaxUint128);
                (0, expect_1.expect)(amount0).to.be.eq(0);
                (0, expect_1.expect)(amount1).to.be.eq('1000499999999999999');
            });
            it('token1 with unexpected donation before swap', async () => {
                await token1.transfer(pool, (0, utilities_1.expandTo18Decimals)(1));
                await swapExact1For0((0, utilities_1.expandTo18Decimals)(1), wallet.address);
                await pool.burn(minTick, maxTick, 0, '0x');
                const { amount0, amount1 } = await pool.collect.staticCall(wallet.address, minTick, maxTick, utilities_1.MaxUint128, utilities_1.MaxUint128);
                (0, expect_1.expect)(amount0).to.be.eq(0);
                (0, expect_1.expect)(amount1).to.be.eq('1000499999999999999');
            });
            it('token0 and token1', async () => {
                await swapExact0For1((0, utilities_1.expandTo18Decimals)(1), wallet.address);
                await swapExact1For0((0, utilities_1.expandTo18Decimals)(1), wallet.address);
                await pool.burn(minTick, maxTick, 0, '0x');
                const { amount0, amount1 } = await pool.collect.staticCall(wallet.address, minTick, maxTick, utilities_1.MaxUint128, utilities_1.MaxUint128);
                (0, expect_1.expect)(amount0).to.be.eq('499999999999999');
                (0, expect_1.expect)(amount1).to.be.eq('499999999999999');
            });
            it('token0 and token1 with unexpected donation before burn', async () => {
                await swapExact0For1((0, utilities_1.expandTo18Decimals)(1), wallet.address);
                await swapExact1For0((0, utilities_1.expandTo18Decimals)(1), wallet.address);
                await token1.transfer(pool, (0, utilities_1.expandTo18Decimals)(1));
                await token0.transfer(pool, (0, utilities_1.expandTo18Decimals)(2));
                await pool.burn(minTick, maxTick, 0, '0x');
                const { amount0, amount1 } = await pool.collect.staticCall(wallet.address, minTick, maxTick, utilities_1.MaxUint128, utilities_1.MaxUint128);
                (0, expect_1.expect)(amount0).to.be.eq('2000499999999999999');
                (0, expect_1.expect)(amount1).to.be.eq('1000499999999999999');
            });
            it('token0 and token1 with unexpected donation before swaps', async () => {
                await token1.transfer(pool, (0, utilities_1.expandTo18Decimals)(1));
                await token0.transfer(pool, (0, utilities_1.expandTo18Decimals)(2));
                await swapExact0For1((0, utilities_1.expandTo18Decimals)(1), wallet.address);
                await swapExact1For0((0, utilities_1.expandTo18Decimals)(1), wallet.address);
                await pool.burn(minTick, maxTick, 0, '0x');
                const { amount0, amount1 } = await pool.collect.staticCall(wallet.address, minTick, maxTick, utilities_1.MaxUint128, utilities_1.MaxUint128);
                (0, expect_1.expect)(amount0).to.be.eq('2000499999999999999');
                (0, expect_1.expect)(amount1).to.be.eq('1000499999999999999');
            });
        });
    });
    describe('#communityFee', () => {
        const liquidityAmount = (0, utilities_1.expandTo18Decimals)(1000);
        beforeEach(async () => {
            pool = await createPoolWrapped();
            await pool.initialize((0, utilities_1.encodePriceSqrt)(1, 1));
            await mint(wallet.address, minTick, maxTick, liquidityAmount);
        });
        it('is initially set to 0', async () => {
            (0, expect_1.expect)((await pool.globalState()).communityFee).to.eq(0);
        });
        it('can be changed by the owner', async () => {
            await pool.setCommunityFee(170);
            (0, expect_1.expect)((await pool.globalState()).communityFee).to.eq(170);
        });
        it('cannot be changed out of bounds', async () => {
            await (0, expect_1.expect)(pool.setCommunityFee(1001)).to.be.reverted;
        });
        it('cannot be changed by addresses that are not owner', async () => {
            await (0, expect_1.expect)(pool.connect(other).setCommunityFee(170)).to.be.reverted;
        });
        async function swapAndGetFeesOwed({ amount, zeroToOne, poke, supportingFee, }) {
            if (supportingFee) {
                await (zeroToOne
                    ? swapExact0For1SupportingFee(amount, wallet.address)
                    : swapExact1For0SupportingFee(amount, wallet.address));
            }
            else {
                await (zeroToOne ? swapExact0For1(amount, wallet.address) : swapExact1For0(amount, wallet.address));
            }
            if (poke)
                await pool.burn(minTick, maxTick, 0, '0x');
            const { amount0: fees0, amount1: fees1 } = await pool.collect.staticCall(wallet.address, minTick, maxTick, utilities_1.MaxUint128, utilities_1.MaxUint128);
            (0, expect_1.expect)(fees0, 'fees owed in token0 are greater than 0').to.be.gte(0);
            (0, expect_1.expect)(fees1, 'fees owed in token1 are greater than 0').to.be.gte(0);
            return { token0Fees: fees0, token1Fees: fees1 };
        }
        it('position owner gets full fees when community fee is off', async () => {
            const { token0Fees, token1Fees } = await swapAndGetFeesOwed({
                amount: (0, utilities_1.expandTo18Decimals)(1),
                zeroToOne: true,
                poke: true,
            });
            // 6 bips * 1e18
            (0, expect_1.expect)(token0Fees).to.eq('499999999999999');
            (0, expect_1.expect)(token1Fees).to.eq(0);
        });
        it('swap fees accumulate as expected (0 for 1)', async () => {
            let token0Fees;
            let token1Fees;
            ({ token0Fees, token1Fees } = await swapAndGetFeesOwed({
                amount: (0, utilities_1.expandTo18Decimals)(1),
                zeroToOne: true,
                poke: true,
            }));
            (0, expect_1.expect)(token0Fees).to.eq('499999999999999');
            (0, expect_1.expect)(token1Fees).to.eq(0);
            ({ token0Fees, token1Fees } = await swapAndGetFeesOwed({
                amount: (0, utilities_1.expandTo18Decimals)(1),
                zeroToOne: true,
                poke: true,
            }));
            (0, expect_1.expect)(token0Fees).to.eq('999999999999998');
            (0, expect_1.expect)(token1Fees).to.eq(0);
            ({ token0Fees, token1Fees } = await swapAndGetFeesOwed({
                amount: (0, utilities_1.expandTo18Decimals)(1),
                zeroToOne: true,
                poke: true,
            }));
            (0, expect_1.expect)(token0Fees).to.eq('1499999999999997');
            (0, expect_1.expect)(token1Fees).to.eq(0);
        });
        it('swap fees accumulate as expected (0 for 1), supporting fee on transfer', async () => {
            let token0Fees;
            let token1Fees;
            ({ token0Fees, token1Fees } = await swapAndGetFeesOwed({
                amount: (0, utilities_1.expandTo18Decimals)(1),
                zeroToOne: true,
                poke: true,
                supportingFee: true,
            }));
            (0, expect_1.expect)(token0Fees).to.eq('499999999999999');
            (0, expect_1.expect)(token1Fees).to.eq(0);
            ({ token0Fees, token1Fees } = await swapAndGetFeesOwed({
                amount: (0, utilities_1.expandTo18Decimals)(1),
                zeroToOne: true,
                poke: true,
                supportingFee: true,
            }));
            (0, expect_1.expect)(token0Fees).to.eq('999999999999998');
            (0, expect_1.expect)(token1Fees).to.eq(0);
            ({ token0Fees, token1Fees } = await swapAndGetFeesOwed({
                amount: (0, utilities_1.expandTo18Decimals)(1),
                zeroToOne: true,
                poke: true,
                supportingFee: true,
            }));
            (0, expect_1.expect)(token0Fees).to.eq('1499999999999997');
            (0, expect_1.expect)(token1Fees).to.eq(0);
        });
        it('swap fees accumulate as expected (0 for 1), supporting fee on transfer community on', async () => {
            await pool.setCommunityFee(170);
            let token0Fees;
            let token1Fees;
            ({ token0Fees, token1Fees } = await swapAndGetFeesOwed({
                amount: (0, utilities_1.expandTo18Decimals)(1),
                zeroToOne: true,
                poke: true,
                supportingFee: true,
            }));
            (0, expect_1.expect)(token0Fees).to.eq('414999999999999');
            (0, expect_1.expect)(token1Fees).to.eq(0);
            ({ token0Fees, token1Fees } = await swapAndGetFeesOwed({
                amount: (0, utilities_1.expandTo18Decimals)(1),
                zeroToOne: true,
                poke: true,
                supportingFee: true,
            }));
            (0, expect_1.expect)(token0Fees).to.eq('829999999999998');
            (0, expect_1.expect)(token1Fees).to.eq(0);
            ({ token0Fees, token1Fees } = await swapAndGetFeesOwed({
                amount: (0, utilities_1.expandTo18Decimals)(1),
                zeroToOne: true,
                poke: true,
                supportingFee: true,
            }));
            (0, expect_1.expect)(token0Fees).to.eq('1244999999999997');
            (0, expect_1.expect)(token1Fees).to.eq(0);
        });
        it('swap fees accumulate as expected (1 for 0)', async () => {
            let token0Fees;
            let token1Fees;
            ({ token0Fees, token1Fees } = await swapAndGetFeesOwed({
                amount: (0, utilities_1.expandTo18Decimals)(1),
                zeroToOne: false,
                poke: true,
            }));
            (0, expect_1.expect)(token0Fees).to.eq(0);
            (0, expect_1.expect)(token1Fees).to.eq('499999999999999');
            ({ token0Fees, token1Fees } = await swapAndGetFeesOwed({
                amount: (0, utilities_1.expandTo18Decimals)(1),
                zeroToOne: false,
                poke: true,
            }));
            (0, expect_1.expect)(token0Fees).to.eq(0);
            (0, expect_1.expect)(token1Fees).to.eq('999999999999998');
            ({ token0Fees, token1Fees } = await swapAndGetFeesOwed({
                amount: (0, utilities_1.expandTo18Decimals)(1),
                zeroToOne: false,
                poke: true,
            }));
            (0, expect_1.expect)(token0Fees).to.eq(0);
            (0, expect_1.expect)(token1Fees).to.eq('1499999999999997');
        });
        it('swap fees accumulate as expected (1 for 0) supporting fee on transfer', async () => {
            let token0Fees;
            let token1Fees;
            ({ token0Fees, token1Fees } = await swapAndGetFeesOwed({
                amount: (0, utilities_1.expandTo18Decimals)(1),
                zeroToOne: false,
                poke: true,
                supportingFee: true,
            }));
            (0, expect_1.expect)(token0Fees).to.eq(0);
            (0, expect_1.expect)(token1Fees).to.eq('499999999999999');
            ({ token0Fees, token1Fees } = await swapAndGetFeesOwed({
                amount: (0, utilities_1.expandTo18Decimals)(1),
                zeroToOne: false,
                poke: true,
                supportingFee: true,
            }));
            (0, expect_1.expect)(token0Fees).to.eq(0);
            (0, expect_1.expect)(token1Fees).to.eq('999999999999998');
            ({ token0Fees, token1Fees } = await swapAndGetFeesOwed({
                amount: (0, utilities_1.expandTo18Decimals)(1),
                zeroToOne: false,
                poke: true,
                supportingFee: true,
            }));
            (0, expect_1.expect)(token0Fees).to.eq(0);
            (0, expect_1.expect)(token1Fees).to.eq('1499999999999997');
        });
        it('swap fees accumulate as expected (1 for 0) supporting fee on transfer community on', async () => {
            await pool.setCommunityFee(170);
            let token0Fees;
            let token1Fees;
            ({ token0Fees, token1Fees } = await swapAndGetFeesOwed({
                amount: (0, utilities_1.expandTo18Decimals)(1),
                zeroToOne: false,
                poke: true,
                supportingFee: true,
            }));
            (0, expect_1.expect)(token0Fees).to.eq(0);
            (0, expect_1.expect)(token1Fees).to.eq('414999999999999');
            ({ token0Fees, token1Fees } = await swapAndGetFeesOwed({
                amount: (0, utilities_1.expandTo18Decimals)(1),
                zeroToOne: false,
                poke: true,
                supportingFee: true,
            }));
            (0, expect_1.expect)(token0Fees).to.eq(0);
            (0, expect_1.expect)(token1Fees).to.eq('829999999999998');
            ({ token0Fees, token1Fees } = await swapAndGetFeesOwed({
                amount: (0, utilities_1.expandTo18Decimals)(1),
                zeroToOne: false,
                poke: true,
                supportingFee: true,
            }));
            (0, expect_1.expect)(token0Fees).to.eq(0);
            (0, expect_1.expect)(token1Fees).to.eq('1244999999999997');
        });
        it('position owner gets partial fees when community fee is on', async () => {
            await pool.setCommunityFee(170);
            const { token0Fees, token1Fees } = await swapAndGetFeesOwed({
                amount: (0, utilities_1.expandTo18Decimals)(1),
                zeroToOne: true,
                poke: true,
            });
            (0, expect_1.expect)(token0Fees).to.be.eq('414999999999999');
            (0, expect_1.expect)(token1Fees).to.be.eq(0);
        });
        it('fees collected by lp after two swaps should be double one swap', async () => {
            await swapAndGetFeesOwed({
                amount: (0, utilities_1.expandTo18Decimals)(1),
                zeroToOne: true,
                poke: true,
            });
            const { token0Fees, token1Fees } = await swapAndGetFeesOwed({
                amount: (0, utilities_1.expandTo18Decimals)(1),
                zeroToOne: true,
                poke: true,
            });
            // 1 bips * 2e18
            (0, expect_1.expect)(token0Fees).to.eq('999999999999998');
            (0, expect_1.expect)(token1Fees).to.eq(0);
        });
        it('fees collected after two swaps with fee turned on in middle are fees from last swap (not confiscatory)', async () => {
            await swapAndGetFeesOwed({
                amount: (0, utilities_1.expandTo18Decimals)(1),
                zeroToOne: true,
                poke: false,
            });
            await pool.setCommunityFee(170);
            const { token0Fees, token1Fees } = await swapAndGetFeesOwed({
                amount: (0, utilities_1.expandTo18Decimals)(1),
                zeroToOne: true,
                poke: true,
            });
            (0, expect_1.expect)(token0Fees).to.eq('914999999999999');
            (0, expect_1.expect)(token1Fees).to.eq(0);
        });
        it('fees collected by lp after two swaps with intermediate withdrawal', async () => {
            await pool.setCommunityFee(170);
            const { token0Fees, token1Fees } = await swapAndGetFeesOwed({
                amount: (0, utilities_1.expandTo18Decimals)(1),
                zeroToOne: true,
                poke: true,
            });
            (0, expect_1.expect)(token0Fees).to.eq('414999999999999');
            (0, expect_1.expect)(token1Fees).to.eq(0);
            // collect the fees
            await pool.collect(wallet.address, minTick, maxTick, utilities_1.MaxUint128, utilities_1.MaxUint128);
            const { token0Fees: token0FeesNext, token1Fees: token1FeesNext } = await swapAndGetFeesOwed({
                amount: (0, utilities_1.expandTo18Decimals)(1),
                zeroToOne: true,
                poke: false,
            });
            (0, expect_1.expect)(token0FeesNext).to.eq(0);
            (0, expect_1.expect)(token1FeesNext).to.eq(0);
            (0, expect_1.expect)((await token0.balanceOf(vaultAddress)).toString()).to.eq('85000000000000');
            const [communityFeePending0] = await pool.getCommunityFeePending();
            (0, expect_1.expect)(communityFeePending0).to.be.eq('85000000000000');
            (0, expect_1.expect)(Number((await token1.balanceOf(vaultAddress)).toString())).to.eq(0);
            await pool.burn(minTick, maxTick, 0, '0x'); // poke to update fees
            await (0, expect_1.expect)(pool.collect(wallet.address, minTick, maxTick, utilities_1.MaxUint128, utilities_1.MaxUint128))
                .to.emit(token0, 'Transfer')
                .withArgs(await pool.getAddress(), wallet.address, '414999999999999');
            (0, expect_1.expect)((await token0.balanceOf(vaultAddress)).toString()).to.eq('85000000000000');
            const [communityFeePending0After] = await pool.getCommunityFeePending();
            (0, expect_1.expect)(communityFeePending0After).to.be.eq('85000000000000');
            (0, expect_1.expect)(Number((await token1.balanceOf(vaultAddress)).toString())).to.eq(0);
        });
        it('community fee pending increases after swap', async () => {
            await pool.setCommunityFee(170);
            await swapExact0For1((0, utilities_1.expandTo18Decimals)(1), wallet.address);
            async function checkFees(cb, zto) {
                const pendingFeesBefore = await pool.getCommunityFeePending();
                await cb((0, utilities_1.expandTo18Decimals)(1));
                const pendingFeesAfter = await pool.getCommunityFeePending();
                if (zto) {
                    (0, expect_1.expect)(pendingFeesAfter[0]).to.be.gt(pendingFeesBefore[0]);
                    (0, expect_1.expect)(pendingFeesAfter[1]).to.eq(pendingFeesBefore[1]);
                }
                else {
                    (0, expect_1.expect)(pendingFeesAfter[1]).to.be.gt(pendingFeesBefore[1]);
                    (0, expect_1.expect)(pendingFeesAfter[0]).to.eq(pendingFeesBefore[0]);
                }
            }
            await checkFees(async (amount) => swapExact0For1(amount, wallet.address), true);
            await checkFees(async (amount) => swapExact1For0(amount, wallet.address), false);
            await checkFees(async (amount) => swapExact0For1SupportingFee(amount, wallet.address), true);
            await checkFees(async (amount) => swapExact1For0SupportingFee(amount, wallet.address), false);
        });
    });
    describe('#tickSpacing', () => {
        beforeEach('deploy pool', async () => {
            pool = await createPoolWrapped();
        });
        describe('post initialize', () => {
            beforeEach('initialize pool', async () => {
                await pool.initialize((0, utilities_1.encodePriceSqrt)(1, 1));
            });
            it('mint can only be called for multiples of 60', async () => {
                await (0, expect_1.expect)(mint(wallet.address, -61, 0, 1)).to.be.reverted;
                await (0, expect_1.expect)(mint(wallet.address, 0, 6, 1)).to.be.reverted;
            });
            it('mint can be called with multiples of 60', async () => {
                await mint(wallet.address, 60, 120, 1);
                await mint(wallet.address, -240, -180, 1);
            });
            it('mint after tickSpacing increase', async () => {
                await mint(wallet.address, 60, 120, 1);
                await pool.setTickSpacing(200);
                await mint(wallet.address, -2400, -1800, 1);
            });
            it('mint after tickSpacing decrease', async () => {
                await mint(wallet.address, 60, 120, 1);
                await pool.setTickSpacing(13);
                await mint(wallet.address, -260, -130, 1);
            });
            it('swapping across gaps works in 1 for 0 direction', async () => {
                const liquidityAmount = (0, utilities_1.expandTo18Decimals)(1) / 4n;
                await mint(wallet.address, 120000, 121200, liquidityAmount);
                await swapExact1For0((0, utilities_1.expandTo18Decimals)(1), wallet.address);
                await (0, expect_1.expect)(pool.burn(120000, 121200, liquidityAmount, '0x'))
                    .to.emit(pool, 'Burn')
                    .withArgs(wallet.address, 120000, 121200, liquidityAmount, '30012388425661', '999499999999999999')
                    .to.not.emit(token0, 'Transfer')
                    .to.not.emit(token1, 'Transfer');
                (0, expect_1.expect)((await pool.globalState()).tick).to.eq(120197);
            });
            it('swapping across gaps works in 0 for 1 direction', async () => {
                const liquidityAmount = (0, utilities_1.expandTo18Decimals)(1) / 4n;
                await mint(wallet.address, -121200, -120000, liquidityAmount);
                await swapExact0For1((0, utilities_1.expandTo18Decimals)(1), wallet.address);
                await (0, expect_1.expect)(pool.burn(-121200, -120000, liquidityAmount, '0x'))
                    .to.emit(pool, 'Burn')
                    .withArgs(wallet.address, -121200, -120000, liquidityAmount, '999499999999999999', '30012388425661')
                    .to.not.emit(token0, 'Transfer')
                    .to.not.emit(token1, 'Transfer');
                (0, expect_1.expect)((await pool.globalState()).tick).to.eq(-120198);
            });
        });
    });
    it('tickMath handles tick overflow', async () => {
        const sqrtTickMath = (await (await hardhat_1.ethers.getContractFactory('TickMathTest')).deploy());
        await (0, expect_1.expect)(sqrtTickMath.getSqrtRatioAtTick(887273)).to.be.revertedWithCustomError(sqrtTickMath, 'tickOutOfRange');
        await (0, expect_1.expect)(sqrtTickMath.getSqrtRatioAtTick(-887273)).to.be.revertedWithCustomError(sqrtTickMath, 'tickOutOfRange');
    });
    it('tick transition cannot run twice if zero for one swap ends at fractional price just below tick', async () => {
        pool = await createPoolWrapped();
        const sqrtTickMath = (await (await hardhat_1.ethers.getContractFactory('TickMathTest')).deploy());
        const PriceMovementMath = (await (await hardhat_1.ethers.getContractFactory('PriceMovementMathTest')).deploy());
        const p0 = (await sqrtTickMath.getSqrtRatioAtTick(-24081)) + 1n;
        // initialize at a price of ~0.3 token1/token0
        // meaning if you swap in 2 token0, you should end up getting 0 token1
        await pool.initialize(p0);
        (0, expect_1.expect)(await pool.liquidity(), 'current pool liquidity is 1').to.eq(0);
        (0, expect_1.expect)((await pool.globalState()).tick, 'pool tick is -24081').to.eq(-24081);
        await pool.setTickSpacing(1);
        // add a bunch of liquidity around current price
        const liquidity = (0, utilities_1.expandTo18Decimals)(1000);
        await mint(wallet.address, -24082, -24080, liquidity);
        (0, expect_1.expect)(await pool.liquidity(), 'current pool liquidity is now liquidity + 1').to.eq(liquidity);
        await mint(wallet.address, -24082, -24081, liquidity);
        (0, expect_1.expect)(await pool.liquidity(), 'current pool liquidity is still liquidity + 1').to.eq(liquidity);
        // check the math works out to moving the price down 1, sending no amount out, and having some amount remaining
        {
            const { feeAmount, amountIn, amountOut, sqrtQ } = await PriceMovementMath.movePriceTowardsTarget(p0, p0 - 1n, liquidity, 3, utilities_1.FeeAmount.MEDIUM);
            (0, expect_1.expect)(sqrtQ, 'price moves').to.eq(p0 - 1n);
            (0, expect_1.expect)(feeAmount, 'fee amount is 1').to.eq(1);
            (0, expect_1.expect)(amountIn, 'amount in is 1').to.eq(1);
            (0, expect_1.expect)(amountOut, 'zero amount out').to.eq(0);
        }
        // swap 2 amount in, should get 0 amount out
        await (0, expect_1.expect)(swapExact0For1(3, wallet.address))
            .to.emit(token0, 'Transfer')
            .withArgs(wallet.address, await pool.getAddress(), 3)
            .to.not.emit(token1, 'Transfer');
        const { tick, price } = await pool.globalState();
        (0, expect_1.expect)(tick, 'pool is at the next tick').to.eq(-24082);
        (0, expect_1.expect)(price, 'pool price is still on the p0 boundary').to.eq(p0 - 1n);
        (0, expect_1.expect)(await pool.liquidity(), 'pool has run tick transition and liquidity changed').to.eq(liquidity * 2n);
    });
    describe('#Position', async () => {
        it('correctly handle underflow innerFeeGrowth', async () => {
            await pool.initialize((0, utilities_1.encodePriceSqrt)(1, 1));
            await mint(wallet.address, -887220, 887220, initializeLiquidityAmount);
            await mint(wallet.address, -120, -60, 1000n * initializeLiquidityAmount);
            await swapExact0For1(10n ** 18n, wallet.address);
            await mint(wallet.address, -240, -60, initializeLiquidityAmount);
            let result = await pool.positions(await (0, utilities_1.getPositionKey)(wallet.address, -240, -60, pool));
            (0, expect_1.expect)(result.innerFeeGrowth0Token).to.be.gt(2n ** 255n).and.lt(2n ** 256n);
            let { amount0 } = await pool.collect.staticCall(wallet.address, -240, -60, utilities_1.MaxUint128, utilities_1.MaxUint128);
            (0, expect_1.expect)(amount0).to.be.eq(0);
        });
        it('correctly update ticks feeGrowth on mint', async () => {
            await pool.initialize((0, utilities_1.encodePriceSqrt)(1, 1));
            await mint(wallet.address, -887220, 887220, initializeLiquidityAmount);
            await swapExact0For1(10n ** 18n, wallet.address);
            await swapExact1For0(10n ** 18n, wallet.address);
            await mint(wallet.address, -240, -60, initializeLiquidityAmount);
            await mint(wallet.address, -240, 6000, initializeLiquidityAmount);
            console.log((await pool.globalState()).tick);
            (0, expect_1.expect)((await pool.ticks(-60)).outerFeeGrowth0Token).to.be.gt(0);
            (0, expect_1.expect)((await pool.ticks(-240)).outerFeeGrowth0Token).to.be.gt(0);
            (0, expect_1.expect)((await pool.ticks(6000)).outerFeeGrowth0Token).to.be.eq(0);
        });
    });
    describe('#fee getter', async () => {
        it('works without plugin', async () => {
            await pool.setFee(150);
            (0, expect_1.expect)(await pool.fee()).to.be.eq(150);
        });
        it('works with plugin', async () => {
            const MockPoolPluginFactory = await hardhat_1.ethers.getContractFactory('MockPoolPlugin');
            const poolPlugin = (await MockPoolPluginFactory.deploy(await pool.getAddress()));
            await pool.setPlugin(poolPlugin);
            await pool.setPluginConfig(255);
            (0, expect_1.expect)(await pool.fee()).to.be.eq(220);
        });
    });
    describe('#flash', () => {
        it('fails if not initialized', async () => {
            await (0, expect_1.expect)(flash(100, 200, other.address)).to.be.reverted;
            await (0, expect_1.expect)(flash(100, 0, other.address)).to.be.reverted;
            await (0, expect_1.expect)(flash(0, 200, other.address)).to.be.reverted;
        });
        it('fails if no liquidity and reserves', async () => {
            await pool.initialize((0, utilities_1.encodePriceSqrt)(1, 1));
            await (0, expect_1.expect)(flash(100, 200, other.address)).to.be.revertedWithCustomError(pool, 'transferFailed');
            await (0, expect_1.expect)(flash(100, 0, other.address)).to.be.revertedWithCustomError(pool, 'transferFailed');
            await (0, expect_1.expect)(flash(0, 200, other.address)).to.be.revertedWithCustomError(pool, 'transferFailed');
        });
        it('works with zero liquidity', async () => {
            await pool.initialize((0, utilities_1.encodePriceSqrt)(1, 1));
            const tickSpacing = await pool.tickSpacing();
            await mint(wallet.address, -tickSpacing, tickSpacing, initializeLiquidityAmount);
            await swapExact0For1(initializeLiquidityAmount * 10000n, wallet.address);
            (0, expect_1.expect)(await pool.liquidity()).to.be.eq(0);
            await (0, expect_1.expect)(flash(100, 0, other.address))
                .to.emit(token0, 'Transfer')
                .withArgs(await pool.getAddress(), other.address, 100);
            await (0, expect_1.expect)(flash(100, 100, other.address)).to.be.revertedWithCustomError(pool, 'transferFailed');
        });
        it('flash overflows communityFee0', async () => {
            await pool.initialize((0, utilities_1.encodePriceSqrt)(1, 1));
            await pool.setCommunityFee(1000);
            const MAX_PENDING_FEE = 2n ** 104n - 1n;
            await token0.approve(swapTarget, ethers_1.MaxUint256);
            await token1.approve(swapTarget, ethers_1.MaxUint256);
            await flash(0, 0, wallet.address, 1, 1);
            await flash(0, 0, wallet.address, MAX_PENDING_FEE, 0);
            await flash(0, 0, wallet.address, 1, 1);
            const [reserve0after, reserve1after] = await pool.getReserves();
            (0, expect_1.expect)(reserve0after).to.eq(0);
            (0, expect_1.expect)(reserve1after).to.eq(0);
        });
        it('flash overflows communityFee1', async () => {
            await pool.initialize((0, utilities_1.encodePriceSqrt)(1, 1));
            await pool.setCommunityFee(1000);
            const MAX_PENDING_FEE = 2n ** 104n - 1n;
            await token0.approve(swapTarget, ethers_1.MaxUint256);
            await token1.approve(swapTarget, ethers_1.MaxUint256);
            await flash(0, 0, wallet.address, 1, 1);
            await flash(0, 0, wallet.address, 0, MAX_PENDING_FEE);
            await flash(0, 0, wallet.address, 1, 1);
            const [reserve0after, reserve1after] = await pool.getReserves();
            (0, expect_1.expect)(reserve0after).to.eq(0);
            (0, expect_1.expect)(reserve1after).to.eq(0);
        });
        describe('after liquidity added', () => {
            let balanceToken0;
            let balanceToken1;
            beforeEach('add some tokens', async () => {
                await initializeAtZeroTick(pool);
                [balanceToken0, balanceToken1] = await Promise.all([token0.balanceOf(pool), token1.balanceOf(pool)]);
            });
            describe('fee off', () => {
                it('emits an event', async () => {
                    await (0, expect_1.expect)(flash(1001, 2001, other.address))
                        .to.emit(pool, 'Flash')
                        .withArgs(await swapTarget.getAddress(), other.address, 1001, 2001, 1, 1);
                });
                it('emits an event', async () => {
                    await (0, expect_1.expect)(flash(1, 1, other.address))
                        .to.emit(pool, 'Flash')
                        .withArgs(await swapTarget.getAddress(), other.address, 1, 1, 1, 1);
                });
                it('transfers the amount0 to the recipient', async () => {
                    await (0, expect_1.expect)(flash(100, 200, other.address))
                        .to.emit(token0, 'Transfer')
                        .withArgs(await pool.getAddress(), other.address, 100);
                });
                it('transfers the amount1 to the recipient', async () => {
                    await (0, expect_1.expect)(flash(100, 200, other.address))
                        .to.emit(token1, 'Transfer')
                        .withArgs(await pool.getAddress(), other.address, 200);
                });
                it('can flash only token0', async () => {
                    await (0, expect_1.expect)(flash(101, 0, other.address))
                        .to.emit(token0, 'Transfer')
                        .withArgs(await pool.getAddress(), other.address, 101)
                        .to.not.emit(token1, 'Transfer');
                });
                it('can flash only token1', async () => {
                    await (0, expect_1.expect)(flash(0, 102, other.address))
                        .to.emit(token1, 'Transfer')
                        .withArgs(await pool.getAddress(), other.address, 102)
                        .to.not.emit(token0, 'Transfer');
                });
                it('can flash max uint128', async () => {
                    await token0.transfer(pool.getAddress(), utilities_1.MaxUint128);
                    await token1.transfer(pool.getAddress(), utilities_1.MaxUint128);
                    await (0, expect_1.expect)(flash(utilities_1.MaxUint128, utilities_1.MaxUint128, other.address))
                        .to.emit(token1, 'Transfer')
                        .withArgs(await pool.getAddress(), other.address, utilities_1.MaxUint128);
                });
                it('can flash entire token balance', async () => {
                    await (0, expect_1.expect)(flash(balanceToken0, balanceToken1, other.address))
                        .to.emit(token0, 'Transfer')
                        .withArgs(await pool.getAddress(), other.address, balanceToken0)
                        .to.emit(token1, 'Transfer')
                        .withArgs(await pool.getAddress(), other.address, balanceToken1);
                });
                it('no-op if both amounts are 0', async () => {
                    await (0, expect_1.expect)(flash(0, 0, other.address)).to.not.emit(token0, 'Transfer').to.not.emit(token1, 'Transfer');
                });
                it('fails if flash amount is greater than token balance', async () => {
                    await (0, expect_1.expect)(flash(balanceToken0 + 1n, balanceToken1, other.address)).to.be.reverted;
                    await (0, expect_1.expect)(flash(balanceToken0, balanceToken1 + 1n, other.address)).to.be.reverted;
                });
                it('calls the flash callback on the sender with correct fee amounts', async () => {
                    await (0, expect_1.expect)(flash(1001, 2002, other.address)).to.emit(swapTarget, 'FlashCallback').withArgs(1, 1);
                });
                it('increases the fee growth by the expected amount', async () => {
                    await flash(1001, 2002, other.address);
                    (0, expect_1.expect)(await pool.totalFeeGrowth0Token()).to.eq(0);
                    (0, expect_1.expect)(await pool.totalFeeGrowth1Token()).to.eq(0);
                    await pool.burn(minTick, maxTick, 0, '0x');
                    (0, expect_1.expect)(await pool.totalFeeGrowth0Token()).to.eq(2n ** 128n / (0, utilities_1.expandTo18Decimals)(2));
                    (0, expect_1.expect)(await pool.totalFeeGrowth1Token()).to.eq(2n ** 128n / (0, utilities_1.expandTo18Decimals)(2));
                });
                it('increases the fee growth by the expected amount after unexpected donation of token0', async () => {
                    await token0.transfer(pool, (0, utilities_1.expandTo18Decimals)(2));
                    await flash(1001, 2002, other.address);
                    (0, expect_1.expect)(await pool.totalFeeGrowth1Token()).to.eq(0);
                    await pool.burn(minTick, maxTick, 0, '0x');
                    (0, expect_1.expect)(await pool.totalFeeGrowth0Token()).to.eq((((0, utilities_1.expandTo18Decimals)(2) + 1n) * 2n ** 128n) / (0, utilities_1.expandTo18Decimals)(2));
                    (0, expect_1.expect)(await pool.totalFeeGrowth1Token()).to.eq(2n ** 128n / (0, utilities_1.expandTo18Decimals)(2));
                });
                it('increases the fee growth by the expected amount after unexpected donation of token1', async () => {
                    await token1.transfer(pool, (0, utilities_1.expandTo18Decimals)(1));
                    await flash(1001, 2002, other.address);
                    (0, expect_1.expect)(await pool.totalFeeGrowth0Token()).to.eq(0);
                    await pool.burn(minTick, maxTick, 0, '0x');
                    (0, expect_1.expect)(await pool.totalFeeGrowth0Token()).to.eq(2n ** 128n / (0, utilities_1.expandTo18Decimals)(2));
                    (0, expect_1.expect)(await pool.totalFeeGrowth1Token()).to.eq((((0, utilities_1.expandTo18Decimals)(1) + 1n) * 2n ** 128n) / (0, utilities_1.expandTo18Decimals)(2));
                });
                it('increases the fee growth by the expected amount after unexpected donation', async () => {
                    await token0.transfer(pool, (0, utilities_1.expandTo18Decimals)(2));
                    await token1.transfer(pool, (0, utilities_1.expandTo18Decimals)(1));
                    await flash(1001, 2002, other.address);
                    await pool.burn(minTick, maxTick, 0, '0x');
                    (0, expect_1.expect)(await pool.totalFeeGrowth0Token()).to.eq((((0, utilities_1.expandTo18Decimals)(2) + 1n) * 2n ** 128n) / (0, utilities_1.expandTo18Decimals)(2));
                    (0, expect_1.expect)(await pool.totalFeeGrowth1Token()).to.eq((((0, utilities_1.expandTo18Decimals)(1) + 1n) * 2n ** 128n) / (0, utilities_1.expandTo18Decimals)(2));
                });
                it('fails if original balance not returned in either token', async () => {
                    await (0, expect_1.expect)(flash(1000, 0, other.address, 999, 0)).to.be.reverted;
                    await (0, expect_1.expect)(flash(0, 1000, other.address, 0, 999)).to.be.reverted;
                });
                it('fails if underpays either token', async () => {
                    await (0, expect_1.expect)(flash(1000, 0, other.address, 1000, 0)).to.be.reverted;
                    await (0, expect_1.expect)(flash(0, 1000, other.address, 0, 1000)).to.be.reverted;
                });
                it('allows donating token0', async () => {
                    await (0, expect_1.expect)(flash(0, 0, ethers_1.ZeroAddress, 567, 0))
                        .to.emit(token0, 'Transfer')
                        .withArgs(wallet.address, await pool.getAddress(), 567)
                        .to.not.emit(token1, 'Transfer');
                    await pool.burn(minTick, maxTick, 0, '0x');
                    (0, expect_1.expect)(await pool.totalFeeGrowth0Token()).to.eq((567n * 2n ** 128n) / (0, utilities_1.expandTo18Decimals)(2));
                });
                it('allows donating token1', async () => {
                    await (0, expect_1.expect)(flash(0, 0, ethers_1.ZeroAddress, 0, 678))
                        .to.emit(token1, 'Transfer')
                        .withArgs(wallet.address, await pool.getAddress(), 678)
                        .to.not.emit(token0, 'Transfer');
                    await pool.burn(minTick, maxTick, 0, '0x');
                    (0, expect_1.expect)(await pool.totalFeeGrowth1Token()).to.eq((678n * 2n ** 128n) / (0, utilities_1.expandTo18Decimals)(2));
                });
                it('allows donating token0 and token1 together', async () => {
                    await (0, expect_1.expect)(flash(0, 0, ethers_1.ZeroAddress, 789, 1234))
                        .to.emit(token0, 'Transfer')
                        .withArgs(wallet.address, await pool.getAddress(), 789)
                        .to.emit(token1, 'Transfer')
                        .withArgs(wallet.address, await pool.getAddress(), 1234);
                    await pool.burn(minTick, maxTick, 0, '0x');
                    (0, expect_1.expect)(await pool.totalFeeGrowth0Token()).to.eq((789n * 2n ** 128n) / (0, utilities_1.expandTo18Decimals)(2));
                    (0, expect_1.expect)(await pool.totalFeeGrowth1Token()).to.eq((1234n * 2n ** 128n) / (0, utilities_1.expandTo18Decimals)(2));
                });
            });
            describe('fee on', () => {
                beforeEach('turn community fee on', async () => {
                    await pool.setCommunityFee(170);
                });
                it('emits an event', async () => {
                    await (0, expect_1.expect)(flash(1001, 2001, other.address))
                        .to.emit(pool, 'Flash')
                        .withArgs(await swapTarget.getAddress(), other.address, 1001, 2001, 1, 1);
                });
                it('increases the fee growth by the expected amount', async () => {
                    await flash(20020, 16016 * 5, other.address);
                    (0, expect_1.expect)(await pool.totalFeeGrowth0Token()).to.eq(0);
                    (0, expect_1.expect)(await pool.totalFeeGrowth1Token()).to.eq(0);
                    await pool.burn(minTick, maxTick, 0, '0x');
                    (0, expect_1.expect)(await pool.totalFeeGrowth0Token()).to.eq((3n * 2n ** 128n) / (0, utilities_1.expandTo18Decimals)(2));
                    (0, expect_1.expect)(await pool.totalFeeGrowth1Token()).to.eq((8n * 2n ** 128n) / (0, utilities_1.expandTo18Decimals)(2));
                    (0, expect_1.expect)(Number((await token0.balanceOf(vaultAddress)).toString())).to.eq(0);
                    (0, expect_1.expect)(Number((await token1.balanceOf(vaultAddress)).toString())).to.eq(1);
                });
                it('allows donating token0', async () => {
                    await (0, expect_1.expect)(flash(0, 0, ethers_1.ZeroAddress, 567, 0))
                        .to.emit(token0, 'Transfer')
                        .withArgs(wallet.address, await pool.getAddress(), 567)
                        .to.not.emit(token1, 'Transfer');
                    await pool.burn(minTick, maxTick, 0, '0x');
                    const [communityFeePending0] = await pool.getCommunityFeePending();
                    (0, expect_1.expect)(Number(communityFeePending0.toString())).to.eq(0);
                    (0, expect_1.expect)(Number((await token0.balanceOf(vaultAddress)).toString())).to.eq(96);
                    (0, expect_1.expect)(await pool.totalFeeGrowth0Token()).to.eq((471n * 2n ** 128n) / (0, utilities_1.expandTo18Decimals)(2));
                });
                it('allows donating token1', async () => {
                    await (0, expect_1.expect)(flash(0, 0, ethers_1.ZeroAddress, 0, 678))
                        .to.emit(token1, 'Transfer')
                        .withArgs(wallet.address, await pool.getAddress(), 678)
                        .to.not.emit(token0, 'Transfer');
                    await pool.burn(minTick, maxTick, 0, '0x');
                    const [, communityFeePending1] = await pool.getCommunityFeePending();
                    (0, expect_1.expect)(Number(communityFeePending1.toString())).to.eq(0);
                    (0, expect_1.expect)(Number((await token1.balanceOf(vaultAddress)).toString())).to.eq(115);
                    (0, expect_1.expect)(await pool.totalFeeGrowth1Token()).to.eq((563n * 2n ** 128n) / (0, utilities_1.expandTo18Decimals)(2));
                });
                it('allows donating token0 and token1 together', async () => {
                    await (0, expect_1.expect)(flash(0, 0, ethers_1.ZeroAddress, 789, 1234))
                        .to.emit(token0, 'Transfer')
                        .withArgs(wallet.address, await pool.getAddress(), 789)
                        .to.emit(token1, 'Transfer')
                        .withArgs(wallet.address, await pool.getAddress(), 1234);
                    await pool.burn(minTick, maxTick, 0, '0x');
                    const [communityFeePending0, communityFeePending1] = await pool.getCommunityFeePending();
                    (0, expect_1.expect)(Number(communityFeePending0.toString())).to.eq(0);
                    (0, expect_1.expect)(Number(communityFeePending1.toString())).to.eq(0);
                    (0, expect_1.expect)(Number((await token0.balanceOf(vaultAddress)).toString())).to.eq(134);
                    (0, expect_1.expect)(Number((await token1.balanceOf(vaultAddress)).toString())).to.eq(209);
                    (0, expect_1.expect)(await pool.totalFeeGrowth0Token()).to.eq((655n * 2n ** 128n) / (0, utilities_1.expandTo18Decimals)(2));
                    (0, expect_1.expect)(await pool.totalFeeGrowth1Token()).to.eq((1025n * 2n ** 128n) / (0, utilities_1.expandTo18Decimals)(2));
                });
            });
        });
    });
    describe('Plugin fees', () => {
        let poolPlugin;
        beforeEach('initialize the pool', async () => {
            const MockPoolPluginFactory = await hardhat_1.ethers.getContractFactory('MockPoolPlugin');
            poolPlugin = (await MockPoolPluginFactory.deploy(await pool.getAddress()));
            await pool.setPlugin(poolPlugin);
            await pool.setPluginConfig(255);
            await pool.initialize((0, utilities_1.encodePriceSqrt)(1, 1));
            await mint(wallet.address, minTick, maxTick, (0, utilities_1.expandTo18Decimals)(1));
        });
        it('swap/burn fails if plugin fee exceeds max value', async () => {
            await poolPlugin.setPluginFees(4000, 1000000);
            await (0, expect_1.expect)(swapExact0For1((0, utilities_1.expandTo18Decimals)(1), wallet.address)).to.be.revertedWithCustomError(pool, 'incorrectPluginFee');
            await (0, expect_1.expect)(pool.burn(minTick, maxTick, (0, utilities_1.expandTo18Decimals)(1), '0x')).to.be.revertedWithCustomError(pool, 'incorrectPluginFee');
        });
        it('swap fails if fees sum exceeds max value', async () => {
            await poolPlugin.setPluginFees(15000, 990000);
            await (0, expect_1.expect)(swapExact0For1((0, utilities_1.expandTo18Decimals)(1), wallet.address)).to.be.revertedWithCustomError(pool, 'incorrectPluginFee');
            await poolPlugin.setPluginFees(0, 990000);
            await pool.setPluginConfig(1);
            await pool.setFee(15000);
            await pool.setPluginConfig(129);
            await (0, expect_1.expect)(swapExact0For1((0, utilities_1.expandTo18Decimals)(1), wallet.address)).to.be.revertedWithCustomError(pool, 'incorrectPluginFee');
        });
        it('swap fails if plugin return incorrect selector', async () => {
            await poolPlugin.disablePluginFeeHandle();
            await poolPlugin.setPluginFees(5000, 4000);
            const selector = poolPlugin.interface.getFunction('handlePluginFee').selector;
            await (0, expect_1.expect)(swapExact0For1((0, utilities_1.expandTo18Decimals)(1), wallet.address)).
                to.be.revertedWithCustomError(pool, 'invalidHookResponse').withArgs(selector);
        });
        it('works correct on swap', async () => {
            await poolPlugin.setPluginFees(5000, 4000);
            await swapExact0For1((0, utilities_1.expandTo18Decimals)(1), wallet.address);
            await swapExact0For1((0, utilities_1.expandTo18Decimals)(1), wallet.address);
            await swapExact1For0((0, utilities_1.expandTo18Decimals)(1), wallet.address);
            let pluginFees = await pool.getPluginFeePending();
            (0, expect_1.expect)(pluginFees[0]).to.be.eq(4n * 10n ** 15n);
            (0, expect_1.expect)(pluginFees[1]).to.be.eq(4n * 10n ** 15n);
        });
        it('works correct on swap, fee is 50%, 75%, 99%', async () => {
            await poolPlugin.setPluginFees(0, 500000);
            await swapExact0For1((0, utilities_1.expandTo18Decimals)(1), wallet.address);
            await swapExact1For0((0, utilities_1.expandTo18Decimals)(1), wallet.address);
            let pluginFees = await pool.getPluginFeePending();
            (0, expect_1.expect)(pluginFees[1]).to.be.eq((0, utilities_1.expandTo18Decimals)(1) / 2n);
            await poolPlugin.setPluginFees(0, 750000);
            await swapExact1For0((0, utilities_1.expandTo18Decimals)(1), wallet.address);
            pluginFees = await pool.getPluginFeePending();
            (0, expect_1.expect)(pluginFees[1]).to.be.eq((0, utilities_1.expandTo18Decimals)(1) * 125n / 100n);
            await poolPlugin.setPluginFees(0, 990000);
            await swapExact1For0((0, utilities_1.expandTo18Decimals)(1), wallet.address);
            pluginFees = await pool.getPluginFeePending();
            (0, expect_1.expect)(pluginFees[1]).to.be.eq((0, utilities_1.expandTo18Decimals)(1) * 224n / 100n);
        });
        it('works correct on burn', async () => {
            await poolPlugin.setPluginFees(0, 6000);
            const pluginBalance0Before = await token0.balanceOf(poolPlugin);
            const pluginBalance1Before = await token1.balanceOf(poolPlugin);
            await pool.burn(minTick, maxTick, (0, utilities_1.expandTo18Decimals)(1), '0x');
            const pluginBalance0After = await token0.balanceOf(poolPlugin);
            const pluginBalance1After = await token1.balanceOf(poolPlugin);
            (0, expect_1.expect)(pluginBalance0After - pluginBalance0Before).to.be.eq(6n * 10n ** 15n - 1n);
            (0, expect_1.expect)(pluginBalance1After - pluginBalance1Before).to.be.eq(6n * 10n ** 15n - 1n);
        });
        it('works correct on burn single-sided position', async () => {
            await poolPlugin.setPluginFees(0, 6000);
            await mint(wallet.address, -120, -60, (0, utilities_1.expandTo18Decimals)(1));
            await mint(wallet.address, 60, 120, (0, utilities_1.expandTo18Decimals)(1));
            await pool.burn(minTick, maxTick, (0, utilities_1.expandTo18Decimals)(1), '0x');
            await pool.burn(-120, -60, (0, utilities_1.expandTo18Decimals)(1), '0x');
            await pool.burn(60, 120, (0, utilities_1.expandTo18Decimals)(1), '0x');
            let res = await pool.getPluginFeePending();
            (0, expect_1.expect)(res[0]).to.be.eq(17918296827593n);
            (0, expect_1.expect)(res[1]).to.be.eq(17918296827593n);
        });
        it('fees transfered to plugin', async () => {
            await poolPlugin.setPluginFees(5000, 4000);
            const pluginBalance0Before = await token0.balanceOf(poolPlugin);
            const pluginBalance1Before = await token1.balanceOf(poolPlugin);
            await swapExact0For1((0, utilities_1.expandTo18Decimals)(1), wallet.address);
            const pluginBalance0After = await token0.balanceOf(poolPlugin);
            const pluginBalance1After = await token1.balanceOf(poolPlugin);
            (0, expect_1.expect)(pluginBalance0After - pluginBalance0Before).to.be.eq(4n * 10n ** 15n);
            (0, expect_1.expect)(pluginBalance1After - pluginBalance1Before).to.be.eq(0);
        });
        it('fees transfered to plugin, if comm fee is zero', async () => {
            await poolPlugin.setPluginFees(5000, 4000);
            await swapExact1For0((0, utilities_1.expandTo18Decimals)(1), wallet.address);
            const pluginBalance0Before = await token0.balanceOf(poolPlugin);
            const pluginBalance1Before = await token1.balanceOf(poolPlugin);
            await pool.advanceTime(86400);
            await swapExact0For1((0, utilities_1.expandTo18Decimals)(1), wallet.address);
            const pluginBalance0After = await token0.balanceOf(poolPlugin);
            const pluginBalance1After = await token1.balanceOf(poolPlugin);
            (0, expect_1.expect)(pluginBalance0After - pluginBalance0Before).to.be.eq(4n * 10n ** 15n);
            (0, expect_1.expect)(pluginBalance1After - pluginBalance1Before).to.be.eq(0);
        });
        it('fees transfered to plugin, after disable plugin fee and enable comm fee', async () => {
            await poolPlugin.setPluginFees(5000, 4000);
            await swapExact1For0((0, utilities_1.expandTo18Decimals)(1), wallet.address);
            await swapExact0For1((0, utilities_1.expandTo18Decimals)(1), wallet.address);
            const pluginBalance0Before = await token0.balanceOf(poolPlugin);
            const pluginBalance1Before = await token1.balanceOf(poolPlugin);
            await pool.advanceTime(86400);
            await poolPlugin.setPluginFees(5000, 0);
            await pool.setCommunityFee(100);
            await swapExact0For1((0, utilities_1.expandTo18Decimals)(1), wallet.address);
            const pluginBalance0After = await token0.balanceOf(poolPlugin);
            const pluginBalance1After = await token1.balanceOf(poolPlugin);
            (0, expect_1.expect)(pluginBalance0After - pluginBalance0Before).to.be.eq(4n * 10n ** 15n);
            (0, expect_1.expect)(pluginBalance1After - pluginBalance1Before).to.be.eq(0);
        });
        it('fees transfered to vault, after disable comm fee and enable plugin fee', async () => {
            await pool.setCommunityFee(100);
            await swapExact1For0((0, utilities_1.expandTo18Decimals)(1), wallet.address);
            await swapExact0For1((0, utilities_1.expandTo18Decimals)(1), wallet.address);
            const vaultBalance0Before = await token0.balanceOf(vaultAddress);
            const vaultBalance1Before = await token1.balanceOf(vaultAddress);
            await pool.advanceTime(86400);
            await poolPlugin.setPluginFees(5000, 4000);
            await pool.setCommunityFee(0);
            await swapExact0For1((0, utilities_1.expandTo18Decimals)(1), wallet.address);
            const vaultBalance0After = await token0.balanceOf(vaultAddress);
            const vaultBalance1After = await token1.balanceOf(vaultAddress);
            (0, expect_1.expect)(vaultBalance0After - vaultBalance0Before).to.be.eq(5n * 10n ** 13n);
            (0, expect_1.expect)(vaultBalance1After - vaultBalance1Before).to.be.eq(0);
        });
        it('communityFee is charged from plugin + override fees', async () => {
            await poolPlugin.setPluginFees(1000, 4000);
            await pool.setCommunityFee(500);
            await swapExact0For1((0, utilities_1.expandTo18Decimals)(1), wallet.address);
            await swapExact0For1((0, utilities_1.expandTo18Decimals)(1), wallet.address);
            const communityFees = await pool.getCommunityFeePending();
            const pluginFees = await pool.getPluginFeePending();
            (0, expect_1.expect)(communityFees[0]).to.be.eq((0, utilities_1.expandTo18Decimals)(1) * 5n * 5n / 10000n); // 0.05%
            (0, expect_1.expect)(pluginFees[0]).to.be.eq(2n * 10n ** 15n);
        });
        it('communityFee is charged from plugin fee', async () => {
            await poolPlugin.setPluginFees(0, 4000);
            await pool.setPluginConfig(1);
            await pool.setFee(0);
            await pool.setPluginConfig(255);
            await pool.setCommunityFee(500);
            await swapExact0For1((0, utilities_1.expandTo18Decimals)(1), wallet.address);
            await swapExact0For1((0, utilities_1.expandTo18Decimals)(1), wallet.address);
            const communityFees = await pool.getCommunityFeePending();
            const pluginFees = await pool.getPluginFeePending();
            (0, expect_1.expect)(communityFees[0]).to.be.eq((0, utilities_1.expandTo18Decimals)(1) * 5n * 4n / 10000n);
            (0, expect_1.expect)(pluginFees[0]).to.be.eq(2n * 10n ** 15n);
        });
        it('communityFee is charged from plugin + pool fee', async () => {
            await poolPlugin.setPluginFees(0, 4000);
            await pool.setPluginConfig(1);
            await pool.setFee(1000);
            await pool.setPluginConfig(255);
            await pool.setCommunityFee(500);
            await swapExact0For1((0, utilities_1.expandTo18Decimals)(1), wallet.address);
            await swapExact0For1((0, utilities_1.expandTo18Decimals)(1), wallet.address);
            const communityFees = await pool.getCommunityFeePending();
            const pluginFees = await pool.getPluginFeePending();
            (0, expect_1.expect)(communityFees[0]).to.be.eq((0, utilities_1.expandTo18Decimals)(1) * 5n * 5n / 10000n);
            (0, expect_1.expect)(pluginFees[0]).to.be.eq(2n * 10n ** 15n);
        });
        it('communityFee is charged from override fee', async () => {
            await poolPlugin.setPluginFees(5000, 0);
            await pool.setCommunityFee(500);
            await swapExact0For1((0, utilities_1.expandTo18Decimals)(1), wallet.address);
            await swapExact0For1((0, utilities_1.expandTo18Decimals)(1), wallet.address);
            const communityFees = await pool.getCommunityFeePending();
            const pluginFees = await pool.getPluginFeePending();
            (0, expect_1.expect)(communityFees[0]).to.be.eq((0, utilities_1.expandTo18Decimals)(1) * 5n * 5n / 10000n);
            (0, expect_1.expect)(pluginFees[0]).to.be.eq(0n);
        });
        it('emits an event with plugin fee and override fee on swap', async () => {
            await poolPlugin.setPluginFees(4000, 6000);
            await (0, expect_1.expect)(swapExact0For1((0, utilities_1.expandTo18Decimals)(1), wallet.address)).to.be.emit(pool, 'Swap').withArgs(await swapTarget.getAddress(), wallet.address, 10n ** 18n, -497487437185929648n, 39813146992092631956554748913n, 1000000000000000000n, -13764);
            await (0, expect_1.expect)(swapExact0For1((0, utilities_1.expandTo18Decimals)(1), wallet.address)).to.be.emit(pool, 'SwapFee').withArgs(await swapTarget.getAddress(), 4000, 6000);
        });
        it('emits an event with plugin fee and override fee on burn', async () => {
            await poolPlugin.setPluginFees(4000, 6000);
            await mint(wallet.address, 60, 120, (0, utilities_1.expandTo18Decimals)(1));
            await (0, expect_1.expect)(pool.burn(60, 120, (0, utilities_1.expandTo18Decimals)(1), '0x'))
                .to.emit(pool, 'BurnFee')
                .withArgs(wallet.address, 6000);
        });
    });
    describe('PermissionedActions', async () => {
        describe('#setCommunityFee', () => {
            beforeEach('initialize the pool', async () => {
                await pool.initialize((0, utilities_1.encodePriceSqrt)(1, 1));
            });
            it('cannot be positive without vault', async () => {
                await pool.setCommunityVault(ethers_1.ZeroAddress);
                await (0, expect_1.expect)(pool.setCommunityFee(1)).to.be.revertedWithCustomError(pool, 'invalidNewCommunityFee');
            });
            it('can only be called by factory owner', async () => {
                await (0, expect_1.expect)(pool.connect(other).setCommunityFee(200)).to.be.reverted;
            });
            it('fails if fee is gt 100%', async () => {
                await (0, expect_1.expect)(pool.setCommunityFee(1004)).to.be.reverted;
            });
            it('succeeds for fee 100%', async () => {
                await pool.setCommunityFee(1000);
                (0, expect_1.expect)((await pool.globalState()).communityFee).to.eq(1000);
            });
            it('succeeds for fee 25%', async () => {
                await pool.setCommunityFee(250);
            });
            it('succeeds for fee of 10%', async () => {
                await pool.setCommunityFee(100);
            });
            it('sets community fee', async () => {
                await pool.setCommunityFee(140);
                (0, expect_1.expect)((await pool.globalState()).communityFee).to.eq(140);
            });
            it('can change community fee', async () => {
                await pool.setCommunityFee(140);
                await pool.setCommunityFee(200);
                (0, expect_1.expect)((await pool.globalState()).communityFee).to.eq(200);
            });
            it('can turn off community fee', async () => {
                await pool.setCommunityFee(250);
                await pool.setCommunityFee(0);
                (0, expect_1.expect)((await pool.globalState()).communityFee).to.eq(0);
            });
            it('emits an event when turned on', async () => {
                await (0, expect_1.expect)(pool.setCommunityFee(140)).to.be.emit(pool, 'CommunityFee').withArgs(140);
            });
            it('emits an event when turned off', async () => {
                await pool.setCommunityFee(140);
                await (0, expect_1.expect)(pool.setCommunityFee(0)).to.be.emit(pool, 'CommunityFee').withArgs(0);
            });
            it('emits an event when changed', async () => {
                await pool.setCommunityFee(250);
                await (0, expect_1.expect)(pool.setCommunityFee(170)).to.be.emit(pool, 'CommunityFee').withArgs(170);
            });
            it('fails if unchanged', async () => {
                await pool.setCommunityFee(200);
                await (0, expect_1.expect)(pool.setCommunityFee(200)).to.be.revertedWithCustomError(pool, 'invalidNewCommunityFee');
            });
        });
        describe('#setCommunityVault', () => {
            beforeEach('initialize the pool', async () => {
                await pool.initialize((0, utilities_1.encodePriceSqrt)(1, 1));
            });
            it('can only be called by factory owner', async () => {
                await (0, expect_1.expect)(pool.connect(other).setCommunityVault(other.address)).to.be.reverted;
            });
            it('sets community vault', async () => {
                await pool.setCommunityVault(other.address);
                (0, expect_1.expect)(await pool.communityVault()).to.eq(other.address);
            });
            it('can change community vault', async () => {
                await pool.setCommunityVault(other.address);
                await pool.setCommunityVault(wallet.address);
                (0, expect_1.expect)(await pool.communityVault()).to.eq(wallet.address);
            });
            it('can set zero address with zero community fee', async () => {
                await pool.setCommunityVault(ethers_1.ZeroAddress);
                (0, expect_1.expect)(await pool.communityVault()).to.eq(ethers_1.ZeroAddress);
            });
            it('can set zero address with nonzero community fee', async () => {
                await pool.setCommunityFee(200);
                await pool.setCommunityVault(ethers_1.ZeroAddress);
                (0, expect_1.expect)(await pool.communityVault()).to.eq(ethers_1.ZeroAddress);
                (0, expect_1.expect)((await pool.globalState()).communityFee).to.eq(0);
            });
            it('emits an event when changed', async () => {
                await (0, expect_1.expect)(pool.setCommunityVault(other.address)).to.be.emit(pool, 'CommunityVault').withArgs(other.address);
            });
            it('emits an event when set to zero', async () => {
                await (0, expect_1.expect)(pool.setCommunityVault(ethers_1.ZeroAddress)).to.be.emit(pool, 'CommunityVault').withArgs(ethers_1.ZeroAddress);
            });
            //it('fails if unchanged', async () => {
            //  await pool.setCommunityVault(other.address);
            //  await expect(pool.setCommunityVault(other.address)).to.be.revertedWithCustomError(pool, 'InvalidVault');
            //});
        });
        describe('#setTickSpacing', () => {
            beforeEach('initialize the pool', async () => {
                await pool.initialize((0, utilities_1.encodePriceSqrt)(1, 1));
            });
            it('setTickspacing works', async () => {
                await (0, expect_1.expect)(pool.setTickSpacing(100)).to.emit(pool, 'TickSpacing').withArgs(100);
                (0, expect_1.expect)(await pool.tickSpacing()).to.eq(100);
            });
            it('setTickspacing can be called only by owner', async () => {
                await (0, expect_1.expect)(pool.connect(other).setTickSpacing(100)).to.be.reverted;
            });
            it('can set max tickspacing', async () => {
                await (0, expect_1.expect)(pool.setTickSpacing(500)).to.not.be.reverted;
            });
            it('cannot setTickSpacing as min int24', async () => {
                await (0, expect_1.expect)(pool.setTickSpacing(-8388608)).to.be.revertedWithCustomError(pool, 'invalidNewTickSpacing');
            });
            it('cannot setTickSpacing gt 500 & lt 1', async () => {
                await (0, expect_1.expect)(pool.setTickSpacing(600)).to.be.revertedWithCustomError(pool, 'invalidNewTickSpacing');
                await (0, expect_1.expect)(pool.setTickSpacing(-20)).to.be.revertedWithCustomError(pool, 'invalidNewTickSpacing');
                await (0, expect_1.expect)(pool.setTickSpacing(0)).to.be.revertedWithCustomError(pool, 'invalidNewTickSpacing');
            });
            it('cannot set same value', async () => {
                await (0, expect_1.expect)(pool.setTickSpacing(60)).to.be.revertedWithCustomError(pool, 'invalidNewTickSpacing');
            });
        });
        describe('#plugin', () => {
            let poolPlugin;
            let callbackData;
            beforeEach('create plugin', async () => {
                const MockPoolPluginFactory = await hardhat_1.ethers.getContractFactory('MockPoolPlugin');
                poolPlugin = (await MockPoolPluginFactory.deploy(pool));
                await pool.setPlugin(poolPlugin);
                await pool.setPluginConfig(255);
                callbackData = (0, utilities_1.encodeCallback)(wallet.address);
            });
            it('before initialize the hook is called', async () => {
                await (0, expect_1.expect)(pool.initialize((0, utilities_1.encodePriceSqrt)(1, 1)))
                    .to.be.emit(poolPlugin, 'BeforeInitialize')
                    .withArgs(wallet.address, (0, utilities_1.encodePriceSqrt)(1, 1));
            });
            it('after initialize the hook is called', async () => {
                await (0, expect_1.expect)(pool.initialize((0, utilities_1.encodePriceSqrt)(1, 1)))
                    .to.be.emit(poolPlugin, 'AfterInitialize')
                    .withArgs(wallet.address, (0, utilities_1.encodePriceSqrt)(1, 1), 0);
            });
            it('before mint the hook is called', async () => {
                await pool.initialize((0, utilities_1.encodePriceSqrt)(1, 1));
                await (0, expect_1.expect)(mint(wallet.address, minTick, maxTick, (0, utilities_1.expandTo18Decimals)(1)))
                    .to.be.emit(poolPlugin, 'BeforeModifyPosition')
                    .withArgs(await swapTarget.getAddress(), wallet.address, minTick, maxTick, (0, utilities_1.expandTo18Decimals)(1), callbackData);
            });
            it('after mint the hook is called', async () => {
                await pool.initialize((0, utilities_1.encodePriceSqrt)(1, 1));
                await (0, expect_1.expect)(mint(wallet.address, minTick, maxTick, (0, utilities_1.expandTo18Decimals)(1)))
                    .to.be.emit(poolPlugin, 'AfterModifyPosition')
                    .withArgs(await swapTarget.getAddress(), wallet.address, minTick, maxTick, (0, utilities_1.expandTo18Decimals)(1), (0, utilities_1.expandTo18Decimals)(1), (0, utilities_1.expandTo18Decimals)(1), callbackData);
            });
            it('before burn the hook is called', async () => {
                await pool.initialize((0, utilities_1.encodePriceSqrt)(1, 1));
                await mint(wallet.address, minTick, maxTick, (0, utilities_1.expandTo18Decimals)(1));
                await (0, expect_1.expect)(pool.burn(minTick, maxTick, (0, utilities_1.expandTo18Decimals)(1), '0x'))
                    .to.be.emit(poolPlugin, 'BeforeModifyPosition')
                    .withArgs(wallet.address, wallet.address, minTick, maxTick, (0, utilities_1.expandTo18Decimals)(-1), '0x');
            });
            it('after burn the hook is called', async () => {
                await pool.initialize((0, utilities_1.encodePriceSqrt)(1, 1));
                await mint(wallet.address, minTick, maxTick, (0, utilities_1.expandTo18Decimals)(1));
                await (0, expect_1.expect)(pool.burn(minTick, maxTick, (0, utilities_1.expandTo18Decimals)(1), '0x'))
                    .to.be.emit(poolPlugin, 'AfterModifyPosition')
                    .withArgs(wallet.address, wallet.address, minTick, maxTick, (0, utilities_1.expandTo18Decimals)(-1), (0, utilities_1.expandTo18Decimals)(1) - 1n, (0, utilities_1.expandTo18Decimals)(1) - 1n, '0x');
            });
            it('before swap fee on transfer tokens the hook is called', async () => {
                await pool.initialize((0, utilities_1.encodePriceSqrt)(1, 1));
                await mint(wallet.address, minTick, maxTick, (0, utilities_1.expandTo18Decimals)(1));
                await (0, expect_1.expect)(swapExact1For0SupportingFee(10000, wallet.address))
                    .to.be.emit(poolPlugin, 'BeforeSwap')
                    .withArgs(await swapTarget.getAddress(), wallet.address, false, 10000, utilities_1.MAX_SQRT_RATIO - 1n, true, callbackData);
            });
            it('after swap fee on transfer tokens the hook is called', async () => {
                await pool.initialize((0, utilities_1.encodePriceSqrt)(1, 1));
                await mint(wallet.address, minTick, maxTick, (0, utilities_1.expandTo18Decimals)(1));
                await (0, expect_1.expect)(swapExact1For0SupportingFee(10000, wallet.address))
                    .to.be.emit(poolPlugin, 'AfterSwap')
                    .withArgs(await swapTarget.getAddress(), wallet.address, false, 10000, utilities_1.MAX_SQRT_RATIO - 1n, -9994, 10000, callbackData);
            });
            it('before swap the hook is called', async () => {
                await pool.initialize((0, utilities_1.encodePriceSqrt)(1, 1));
                await mint(wallet.address, minTick, maxTick, (0, utilities_1.expandTo18Decimals)(1));
                await (0, expect_1.expect)(swapExact0For1(10000, wallet.address))
                    .to.be.emit(poolPlugin, 'BeforeSwap')
                    .withArgs(await swapTarget.getAddress(), wallet.address, true, 10000, utilities_1.MIN_SQRT_RATIO + 1n, false, callbackData);
            });
            it('after swap the hook is called', async () => {
                await pool.initialize((0, utilities_1.encodePriceSqrt)(1, 1));
                await mint(wallet.address, minTick, maxTick, (0, utilities_1.expandTo18Decimals)(1));
                await (0, expect_1.expect)(swapExact0For1(10000, wallet.address))
                    .to.be.emit(poolPlugin, 'AfterSwap')
                    .withArgs(await swapTarget.getAddress(), wallet.address, true, 10000, utilities_1.MIN_SQRT_RATIO + 1n, 10000, -9994, callbackData);
            });
            it('before flash the hook is called', async () => {
                await pool.initialize((0, utilities_1.encodePriceSqrt)(1, 1));
                await mint(wallet.address, minTick, maxTick, (0, utilities_1.expandTo18Decimals)(1));
                callbackData = (0, utilities_1.encodeCallback)(wallet.address, 101n, 201n);
                await (0, expect_1.expect)(flash(100, 200, other.address))
                    .to.be.emit(poolPlugin, 'BeforeFlash')
                    .withArgs(await swapTarget.getAddress(), other.address, 100, 200, callbackData);
            });
            it('after flash the hook is called', async () => {
                await pool.initialize((0, utilities_1.encodePriceSqrt)(1, 1));
                await mint(wallet.address, minTick, maxTick, (0, utilities_1.expandTo18Decimals)(1));
                callbackData = (0, utilities_1.encodeCallback)(wallet.address, 101n, 201n);
                await (0, expect_1.expect)(flash(100, 200, other.address))
                    .to.emit(poolPlugin, 'AfterFlash')
                    .withArgs(await swapTarget.getAddress(), other.address, 100, 200, 1, 1, callbackData);
            });
            it('transaction reverted if plugin returns incorrect selector for beforeInitialized hook', async () => {
                await poolPlugin.setSelectorDisable(128);
                const selector = poolPlugin.interface.getFunction('beforeInitialize').selector;
                await (0, expect_1.expect)(pool.initialize((0, utilities_1.encodePriceSqrt)(1, 1)))
                    .to.be.revertedWithCustomError(pool, 'invalidHookResponse')
                    .withArgs(selector);
            });
            it('transaction reverted if plugin returns incorrect selector for afterInitialized hook', async () => {
                await poolPlugin.setSelectorDisable(64);
                const selector = poolPlugin.interface.getFunction('afterInitialize').selector;
                await (0, expect_1.expect)(pool.initialize((0, utilities_1.encodePriceSqrt)(1, 1)))
                    .to.be.revertedWithCustomError(pool, 'invalidHookResponse')
                    .withArgs(selector);
            });
            it('transaction reverted if plugin returns incorrect selector for beforeModifyPosition hook', async () => {
                await poolPlugin.setSelectorDisable(4);
                await pool.initialize((0, utilities_1.encodePriceSqrt)(1, 1));
                const selector = poolPlugin.interface.getFunction('beforeModifyPosition').selector;
                await (0, expect_1.expect)(mint(wallet.address, minTick, maxTick, (0, utilities_1.expandTo18Decimals)(1)))
                    .to.be.revertedWithCustomError(pool, 'invalidHookResponse')
                    .withArgs(selector);
            });
            it('transaction reverted if plugin returns incorrect selector for afterModifyPosition hook', async () => {
                await poolPlugin.setSelectorDisable(8);
                await pool.initialize((0, utilities_1.encodePriceSqrt)(1, 1));
                const selector = poolPlugin.interface.getFunction('afterModifyPosition').selector;
                await (0, expect_1.expect)(mint(wallet.address, minTick, maxTick, (0, utilities_1.expandTo18Decimals)(1)))
                    .to.be.revertedWithCustomError(pool, 'invalidHookResponse')
                    .withArgs(selector);
            });
            it('transaction reverted if plugin returns incorrect selector for beforeSwap hook', async () => {
                await pool.initialize((0, utilities_1.encodePriceSqrt)(1, 1));
                await mint(wallet.address, minTick, maxTick, (0, utilities_1.expandTo18Decimals)(1));
                await poolPlugin.setSelectorDisable(1);
                const selector = poolPlugin.interface.getFunction('beforeSwap').selector;
                await (0, expect_1.expect)(swapExact0For1(10000, wallet.address))
                    .to.be.revertedWithCustomError(pool, 'invalidHookResponse')
                    .withArgs(selector);
            });
            it('transaction reverted if plugin returns incorrect selector for afterSwap hook', async () => {
                await pool.initialize((0, utilities_1.encodePriceSqrt)(1, 1));
                await mint(wallet.address, minTick, maxTick, (0, utilities_1.expandTo18Decimals)(1));
                await poolPlugin.setSelectorDisable(2);
                const selector = poolPlugin.interface.getFunction('afterSwap').selector;
                await (0, expect_1.expect)(swapExact0For1(10000, wallet.address))
                    .to.be.revertedWithCustomError(pool, 'invalidHookResponse')
                    .withArgs(selector);
            });
            it('transaction reverted if plugin returns incorrect selector for beforeFlash hook', async () => {
                await pool.initialize((0, utilities_1.encodePriceSqrt)(1, 1));
                await mint(wallet.address, minTick, maxTick, (0, utilities_1.expandTo18Decimals)(1));
                await poolPlugin.setSelectorDisable(16);
                const selector = poolPlugin.interface.getFunction('beforeFlash').selector;
                await (0, expect_1.expect)(flash(100, 200, other.address))
                    .to.be.revertedWithCustomError(pool, 'invalidHookResponse')
                    .withArgs(selector);
            });
            it('transaction reverted if plugin returns incorrect selector for afterFlash hook', async () => {
                await pool.initialize((0, utilities_1.encodePriceSqrt)(1, 1));
                await mint(wallet.address, minTick, maxTick, (0, utilities_1.expandTo18Decimals)(1));
                await poolPlugin.setSelectorDisable(32);
                const selector = poolPlugin.interface.getFunction('afterFlash').selector;
                await (0, expect_1.expect)(flash(100, 200, other.address))
                    .to.be.revertedWithCustomError(pool, 'invalidHookResponse')
                    .withArgs(selector);
            });
            it('hooks are disabled after a config change', async () => {
                await pool.initialize((0, utilities_1.encodePriceSqrt)(1, 1));
                await mint(wallet.address, minTick, maxTick, (0, utilities_1.expandTo18Decimals)(1));
                await (0, expect_1.expect)(flash(100, 200, other.address)).to.be.emit(poolPlugin, 'AfterFlash');
                await pool.setPluginConfig(223);
                await (0, expect_1.expect)(flash(100, 200, other.address)).not.to.be.emit(poolPlugin, 'AfterFlash');
            });
            it('before/after swap hook is not called if caller is a plugin,', async () => {
                await pool.initialize((0, utilities_1.encodePriceSqrt)(1, 1));
                await mint(wallet.address, minTick, maxTick, (0, utilities_1.expandTo18Decimals)(1));
                await token0.transfer(poolPlugin, (0, utilities_1.expandTo18Decimals)(1));
                await token1.transfer(poolPlugin, (0, utilities_1.expandTo18Decimals)(1));
                await (0, expect_1.expect)(poolPlugin.swap()).not.to.be.emit(poolPlugin, 'BeforeSwap');
                await (0, expect_1.expect)(poolPlugin.swap()).not.to.be.emit(poolPlugin, 'AfterSwap');
            });
            it('before/after modify hook is not called if caller is a plugin,', async () => {
                await pool.initialize((0, utilities_1.encodePriceSqrt)(1, 1));
                await mint(wallet.address, minTick, maxTick, (0, utilities_1.expandTo18Decimals)(1));
                await token0.transfer(poolPlugin, (0, utilities_1.expandTo18Decimals)(1));
                await token1.transfer(poolPlugin, (0, utilities_1.expandTo18Decimals)(1));
                await (0, expect_1.expect)(poolPlugin.mint()).not.to.be.emit(poolPlugin, 'BeforeModifyPosition');
                await (0, expect_1.expect)(poolPlugin.mint()).not.to.be.emit(poolPlugin, 'AfterModifyPosition');
            });
        });
        describe('#setPlugin', () => {
            beforeEach('initialize the pool', async () => {
                await pool.initialize((0, utilities_1.encodePriceSqrt)(1, 1));
            });
            it('can only be called by factory owner or administrator', async () => {
                await (0, expect_1.expect)(pool.connect(other).setPlugin(other.address)).to.be.reverted;
            });
            it('emits an event when changed', async () => {
                await (0, expect_1.expect)(pool.setPlugin(other.address)).to.be.emit(pool, 'Plugin').withArgs(other.address);
            });
        });
        describe('#setPluginConfig', () => {
            beforeEach('initialize the pool', async () => {
                await pool.initialize((0, utilities_1.encodePriceSqrt)(1, 1));
            });
            it('cannot be called by usual user', async () => {
                await (0, expect_1.expect)(pool.connect(other).setPluginConfig(1)).to.be.reverted;
            });
            it('can be called by plugin', async () => {
                await pool.setPlugin(other.address);
                await (0, expect_1.expect)(pool.connect(other).setPluginConfig(1)).to.be.emit(pool, 'PluginConfig').withArgs(1);
            });
            it('reverts if admin sets non-zero pluginConfig in pool with zero plugin', async () => {
                await (0, expect_1.expect)(pool.setPluginConfig(63)).to.be.revertedWithCustomError(pool, 'pluginIsNotConnected');
            });
            it('emits an event when changed', async () => {
                await pool.setPlugin(other.address);
                await (0, expect_1.expect)(pool.setPluginConfig(1)).to.be.emit(pool, 'PluginConfig').withArgs(1);
            });
        });
        describe('#setFee', () => {
            let poolPlugin;
            beforeEach('create plugin', async () => {
                const MockPoolPluginFactory = await hardhat_1.ethers.getContractFactory('MockPoolPlugin');
                poolPlugin = (await MockPoolPluginFactory.deploy(pool));
                await pool.setPlugin(poolPlugin);
                await pool.setPluginConfig(255);
            });
            it('if dynamic fee is off, owner can set fee in pool', async () => {
                await pool.initialize((0, utilities_1.encodePriceSqrt)(1, 1));
                await mint(wallet.address, minTick, maxTick, (0, utilities_1.expandTo18Decimals)(1));
                await pool.setPluginConfig(127);
                await (0, expect_1.expect)(pool.setFee(20000)).to.emit(pool, 'Fee').withArgs(20000);
                const { lastFee } = await pool.globalState();
                (0, expect_1.expect)(lastFee).to.eq(20000);
                const fee = await pool.fee();
                (0, expect_1.expect)(lastFee).to.eq(fee);
            });
            it('only owner can set fee', async () => {
                await pool.initialize((0, utilities_1.encodePriceSqrt)(1, 1));
                await mint(wallet.address, minTick, maxTick, (0, utilities_1.expandTo18Decimals)(1));
                await pool.setPluginConfig(128);
                await (0, expect_1.expect)(pool.connect(other).setFee(20000)).to.be.reverted;
            });
            it('if dynamic fee is on, owner can not set fee in pool', async () => {
                await pool.initialize((0, utilities_1.encodePriceSqrt)(1, 1));
                await pool.setPluginConfig(128);
                await mint(wallet.address, minTick, maxTick, (0, utilities_1.expandTo18Decimals)(1));
                await (0, expect_1.expect)(pool.setFee(20000)).to.be.revertedWithCustomError(pool, 'dynamicFeeActive');
            });
            it('swap fee cannot be overridden if dynamic fee disabled', async () => {
                await pool.initialize((0, utilities_1.encodePriceSqrt)(1, 1));
                await mint(wallet.address, minTick, maxTick, (0, utilities_1.expandTo18Decimals)(1));
                await pool.setPluginConfig(1);
                await poolPlugin.setPluginFees(1000, 0);
                await (0, expect_1.expect)(swapExact0For1((0, utilities_1.expandTo18Decimals)(1) / 10n, wallet.address)).to.be.revertedWithCustomError(pool, 'dynamicFeeDisabled');
            });
            it('plugin fees cannot be overridden if dynamic fee disabled', async () => {
                await pool.initialize((0, utilities_1.encodePriceSqrt)(1, 1));
                await mint(wallet.address, minTick, maxTick, (0, utilities_1.expandTo18Decimals)(1));
                await pool.setPluginConfig(1);
                await poolPlugin.setPluginFees(0, 1000);
                await (0, expect_1.expect)(swapExact0For1((0, utilities_1.expandTo18Decimals)(1) / 10n, wallet.address)).to.be.revertedWithCustomError(pool, 'dynamicFeeDisabled');
                await poolPlugin.setPluginFees(1000, 1000);
                await (0, expect_1.expect)(swapExact0For1((0, utilities_1.expandTo18Decimals)(1) / 10n, wallet.address)).to.be.revertedWithCustomError(pool, 'dynamicFeeDisabled');
                await poolPlugin.setPluginFees(0, 0);
                await (0, expect_1.expect)(swapExact0For1((0, utilities_1.expandTo18Decimals)(1) / 10n, wallet.address)).to.be.not.reverted;
            });
        });
        describe('#sync', () => {
            beforeEach('initialize the pool', async () => {
                await pool.initialize((0, utilities_1.encodePriceSqrt)(1, 1));
                await mint(wallet.address, minTick, maxTick, (0, utilities_1.expandTo18Decimals)(1));
            });
            it('cannot call if not plugin', async () => {
                await (0, expect_1.expect)(pool.sync()).to.be.revertedWithCustomError(pool, 'notAllowed');
            });
            it('can call without excess tokens', async () => {
                await pool.setPlugin(wallet);
                const balance0 = await token0.balanceOf(pool);
                const balance1 = await token1.balanceOf(pool);
                const reserves = await pool.getReserves();
                await pool.sync();
                (0, expect_1.expect)(await token0.balanceOf(pool)).to.be.eq(balance0);
                (0, expect_1.expect)(await token1.balanceOf(pool)).to.be.eq(balance1);
                const reservesAfter = await pool.getReserves();
                (0, expect_1.expect)(reserves[0]).to.be.eq(reservesAfter[0]);
                (0, expect_1.expect)(reserves[1]).to.be.eq(reservesAfter[1]);
            });
            it('can sync excess tokens', async () => {
                await pool.setPlugin(wallet);
                await token0.transfer(pool, 100000);
                await token1.transfer(pool, 100000);
                const balance0 = await token0.balanceOf(pool);
                const balance1 = await token1.balanceOf(pool);
                const reserves = await pool.getReserves();
                await pool.sync();
                (0, expect_1.expect)(await token0.balanceOf(pool)).to.be.eq(balance0);
                (0, expect_1.expect)(await token1.balanceOf(pool)).to.be.eq(balance1);
                const reservesAfter = await pool.getReserves();
                (0, expect_1.expect)(reservesAfter[0]).to.be.eq(reserves[0] + 100000n);
                (0, expect_1.expect)(reservesAfter[1]).to.be.eq(reserves[1] + 100000n);
            });
        });
        describe('#skim', () => {
            beforeEach('initialize the pool', async () => {
                await pool.initialize((0, utilities_1.encodePriceSqrt)(1, 1));
                await mint(wallet.address, minTick, maxTick, (0, utilities_1.expandTo18Decimals)(1));
            });
            it('cannot call if not plugin', async () => {
                await (0, expect_1.expect)(pool.skim()).to.be.revertedWithCustomError(pool, 'notAllowed');
            });
            it('can call without excess tokens', async () => {
                await pool.setPlugin(wallet);
                const balance0 = await token0.balanceOf(pool);
                const balance1 = await token1.balanceOf(pool);
                const reserves = await pool.getReserves();
                await (0, expect_1.expect)(pool.skim()).to.not.emit(pool, 'Skim');
                (0, expect_1.expect)(await token0.balanceOf(pool)).to.be.eq(balance0);
                (0, expect_1.expect)(await token1.balanceOf(pool)).to.be.eq(balance1);
                const reservesAfter = await pool.getReserves();
                (0, expect_1.expect)(reserves[0]).to.be.eq(reservesAfter[0]);
                (0, expect_1.expect)(reserves[1]).to.be.eq(reservesAfter[1]);
            });
            it('can skim excess tokens', async () => {
                await pool.setPlugin(wallet);
                const amount0 = 1000000n;
                const amount1 = 1000010n;
                await token0.transfer(pool, amount0);
                await token1.transfer(pool, amount1);
                const balance0 = await token0.balanceOf(pool);
                const balance1 = await token1.balanceOf(pool);
                const reserves = await pool.getReserves();
                const walletBalance0Before = await token0.balanceOf(wallet.address);
                const walletBalance1Before = await token1.balanceOf(wallet.address);
                await (0, expect_1.expect)(pool.skim()).to.emit(pool, 'Skim').withArgs(wallet.address, amount0, amount1);
                (0, expect_1.expect)(await token0.balanceOf(pool)).to.be.eq(balance0 - amount0);
                (0, expect_1.expect)(await token1.balanceOf(pool)).to.be.eq(balance1 - amount1);
                const reservesAfter = await pool.getReserves();
                (0, expect_1.expect)(reservesAfter[0]).to.be.eq(reserves[0]);
                (0, expect_1.expect)(reservesAfter[1]).to.be.eq(reserves[1]);
                (0, expect_1.expect)(await token0.balanceOf(wallet.address)).to.be.eq(walletBalance0Before + amount0);
                (0, expect_1.expect)(await token1.balanceOf(wallet.address)).to.be.eq(walletBalance1Before + amount1);
            });
            it('can skim excess token0 only', async () => {
                await pool.setPlugin(wallet);
                const amount0 = 1000000n;
                await token0.transfer(pool, amount0);
                const balance0 = await token0.balanceOf(pool);
                const balance1 = await token1.balanceOf(pool);
                const reserves = await pool.getReserves();
                const walletBalance0Before = await token0.balanceOf(wallet.address);
                const walletBalance1Before = await token1.balanceOf(wallet.address);
                await (0, expect_1.expect)(pool.skim()).to.emit(pool, 'Skim').withArgs(wallet.address, amount0, 0n);
                (0, expect_1.expect)(await token0.balanceOf(pool)).to.be.eq(balance0 - amount0);
                (0, expect_1.expect)(await token1.balanceOf(pool)).to.be.eq(balance1);
                const reservesAfter = await pool.getReserves();
                (0, expect_1.expect)(reservesAfter[0]).to.be.eq(reserves[0]);
                (0, expect_1.expect)(reservesAfter[1]).to.be.eq(reserves[1]);
                (0, expect_1.expect)(await token0.balanceOf(wallet.address)).to.be.eq(walletBalance0Before + amount0);
                (0, expect_1.expect)(await token1.balanceOf(wallet.address)).to.be.eq(walletBalance1Before);
            });
        });
        it('can skim excess token1 only', async () => {
            await pool.setPlugin(wallet);
            const amount1 = 1000010n;
            await token1.transfer(pool, amount1);
            const balance0 = await token0.balanceOf(pool);
            const balance1 = await token1.balanceOf(pool);
            const reserves = await pool.getReserves();
            const walletBalance0Before = await token0.balanceOf(wallet.address);
            const walletBalance1Before = await token1.balanceOf(wallet.address);
            await (0, expect_1.expect)(pool.skim()).to.emit(pool, 'Skim').withArgs(wallet.address, 0n, amount1);
            (0, expect_1.expect)(await token0.balanceOf(pool)).to.be.eq(balance0);
            (0, expect_1.expect)(await token1.balanceOf(pool)).to.be.eq(balance1 - amount1);
            const reservesAfter = await pool.getReserves();
            (0, expect_1.expect)(reservesAfter[0]).to.be.eq(reserves[0]);
            (0, expect_1.expect)(reservesAfter[1]).to.be.eq(reserves[1]);
            (0, expect_1.expect)(await token0.balanceOf(wallet.address)).to.be.eq(walletBalance0Before);
            (0, expect_1.expect)(await token1.balanceOf(wallet.address)).to.be.eq(walletBalance1Before + amount1);
        });
    });
    describe('#lock', () => {
        beforeEach('initialize the pool', async () => {
            await pool.initialize((0, utilities_1.encodePriceSqrt)(1, 1));
            await mint(wallet.address, minTick, maxTick, (0, utilities_1.expandTo18Decimals)(1));
        });
        it('cannot reenter from swap callback', async () => {
            const reentrant = (await (await hardhat_1.ethers.getContractFactory('TestAlgebraReentrantCallee')).deploy());
            await pool.setPlugin(reentrant);
            await factory.grantRole(await factory.POOLS_ADMINISTRATOR_ROLE(), reentrant);
            // the tests happen in solidity
            await (0, expect_1.expect)(reentrant.swapToReenter(pool)).to.be.revertedWith('Unable to reenter');
        });
    });
    describe('fees and reserves overflow scenarios', async () => {
        it('up to max uint 128 - 1', async () => {
            await pool.initialize((0, utilities_1.encodePriceSqrt)(1, 1));
            await mint(wallet.address, minTick, maxTick, 1);
            const [reserve0before, reserve1before] = await pool.getReserves();
            await flash(0, 0, wallet.address, utilities_1.MaxUint128 - 1n, utilities_1.MaxUint128 - 1n);
            await pool.burn(minTick, maxTick, 0, '0x');
            const [totalFeeGrowth0Token, totalFeeGrowth1Token] = await Promise.all([
                pool.totalFeeGrowth0Token(),
                pool.totalFeeGrowth1Token(),
            ]);
            // all 1s in first 128 bits
            (0, expect_1.expect)(totalFeeGrowth0Token).to.eq((utilities_1.MaxUint128 << 128n) - (reserve0before << 128n));
            (0, expect_1.expect)(totalFeeGrowth1Token).to.eq((utilities_1.MaxUint128 << 128n) - (reserve1before << 128n));
            const { amount0, amount1 } = await pool.collect.staticCall(wallet.address, minTick, maxTick, utilities_1.MaxUint128, utilities_1.MaxUint128);
            (0, expect_1.expect)(amount0).to.eq(utilities_1.MaxUint128 - 1n);
            (0, expect_1.expect)(amount1).to.eq(utilities_1.MaxUint128 - 1n);
        });
        it('both reserves overflow max uint 128', async () => {
            await pool.initialize((0, utilities_1.encodePriceSqrt)(1, 1));
            await mint(wallet.address, minTick, maxTick, 1);
            const [reserve0before, reserve1before] = await pool.getReserves();
            await flash(0, 0, wallet.address, utilities_1.MaxUint128, utilities_1.MaxUint128);
            await flash(0, 0, wallet.address, 1, 1);
            await pool.burn(minTick, maxTick, 0, '0x');
            const [totalFeeGrowth0Token, totalFeeGrowth1Token] = await Promise.all([
                pool.totalFeeGrowth0Token(),
                pool.totalFeeGrowth1Token(),
            ]);
            // all 1s in first 128 bits
            (0, expect_1.expect)(totalFeeGrowth0Token).to.eq((utilities_1.MaxUint128 << 128n) - (reserve0before << 128n));
            (0, expect_1.expect)(totalFeeGrowth1Token).to.eq((utilities_1.MaxUint128 << 128n) - (reserve1before << 128n));
            const { amount0, amount1 } = await pool.collect.staticCall(wallet.address, minTick, maxTick, utilities_1.MaxUint128, utilities_1.MaxUint128);
            // fees burned
            (0, expect_1.expect)(amount0).to.eq(utilities_1.MaxUint128 - 1n);
            (0, expect_1.expect)(amount1).to.eq(utilities_1.MaxUint128 - 1n);
        });
        it('reserve0 overflow max uint 128', async () => {
            await pool.initialize((0, utilities_1.encodePriceSqrt)(1, 1));
            await mint(wallet.address, minTick, maxTick, 1);
            const [reserve0before] = await pool.getReserves();
            await flash(0, 0, wallet.address, utilities_1.MaxUint128, 0);
            await flash(0, 0, wallet.address, 1, 0);
            await pool.burn(minTick, maxTick, 0, '0x');
            const [totalFeeGrowth0Token, totalFeeGrowth1Token] = await Promise.all([
                pool.totalFeeGrowth0Token(),
                pool.totalFeeGrowth1Token(),
            ]);
            // all 1s in first 128 bits
            (0, expect_1.expect)(totalFeeGrowth0Token).to.eq((utilities_1.MaxUint128 << 128n) - (reserve0before << 128n));
            (0, expect_1.expect)(totalFeeGrowth1Token).to.eq(0);
            const { amount0, amount1 } = await pool.collect.staticCall(wallet.address, minTick, maxTick, utilities_1.MaxUint128, utilities_1.MaxUint128);
            // fees burned
            (0, expect_1.expect)(amount0).to.eq(utilities_1.MaxUint128 - 1n);
            (0, expect_1.expect)(amount1).to.eq(0);
        });
        it('reserve1 overflow max uint 128', async () => {
            await pool.initialize((0, utilities_1.encodePriceSqrt)(1, 1));
            await mint(wallet.address, minTick, maxTick, 1);
            const [, reserve1before] = await pool.getReserves();
            await flash(0, 0, wallet.address, 0, utilities_1.MaxUint128);
            await flash(0, 0, wallet.address, 0, 1);
            await pool.burn(minTick, maxTick, 0, '0x');
            const [totalFeeGrowth0Token, totalFeeGrowth1Token] = await Promise.all([
                pool.totalFeeGrowth0Token(),
                pool.totalFeeGrowth1Token(),
            ]);
            // all 1s in first 128 bits
            (0, expect_1.expect)(totalFeeGrowth0Token).to.eq(0);
            (0, expect_1.expect)(totalFeeGrowth1Token).to.eq((utilities_1.MaxUint128 << 128n) - (reserve1before << 128n));
            const { amount0, amount1 } = await pool.collect.staticCall(wallet.address, minTick, maxTick, utilities_1.MaxUint128, utilities_1.MaxUint128);
            // fees burned
            (0, expect_1.expect)(amount0).to.eq(0);
            (0, expect_1.expect)(amount1).to.eq(utilities_1.MaxUint128 - 1n);
        });
        it('overflow max uint 128 after poke burns fees owed to 0', async () => {
            await pool.initialize((0, utilities_1.encodePriceSqrt)(1, 1));
            await mint(wallet.address, minTick, maxTick, 1);
            await flash(0, 0, wallet.address, utilities_1.MaxUint128, utilities_1.MaxUint128);
            await pool.burn(minTick, maxTick, 0, '0x');
            await flash(0, 0, wallet.address, 1, 1);
            await pool.burn(minTick, maxTick, 0, '0x');
            const { amount0, amount1 } = await pool.collect.staticCall(wallet.address, minTick, maxTick, utilities_1.MaxUint128, utilities_1.MaxUint128);
            // fees burned
            (0, expect_1.expect)(amount0).to.eq(utilities_1.MaxUint128 - 1n);
            (0, expect_1.expect)(amount1).to.eq(utilities_1.MaxUint128 - 1n);
        });
        it('two positions at the same snapshot', async () => {
            await pool.initialize((0, utilities_1.encodePriceSqrt)(1, 1));
            await mint(wallet.address, minTick, maxTick, 1);
            await mint(other.address, minTick, maxTick, 1);
            const [reserve0before] = await pool.getReserves();
            await flash(0, 0, wallet.address, utilities_1.MaxUint128, 0);
            await flash(0, 0, wallet.address, utilities_1.MaxUint128, 0);
            await pool.burn(minTick, maxTick, 0, '0x');
            const totalFeeGrowth0Token = await pool.totalFeeGrowth0Token();
            (0, expect_1.expect)(totalFeeGrowth0Token).to.eq(((utilities_1.MaxUint128 << 128n) - (reserve0before << 128n)) / 2n);
            await flash(0, 0, wallet.address, 2, 0);
            await pool.burn(minTick, maxTick, 0, '0x');
            await pool.connect(other).burn(minTick, maxTick, 0, '0x');
            let { amount0 } = await pool.collect.staticCall(wallet.address, minTick, maxTick, utilities_1.MaxUint128, utilities_1.MaxUint128);
            (0, expect_1.expect)(amount0, 'amount0 of wallet').to.eq(utilities_1.MaxUint128 / 2n - 1n);
            ({ amount0 } = await pool
                .connect(other)
                .collect.staticCall(other.address, minTick, maxTick, utilities_1.MaxUint128, utilities_1.MaxUint128));
            (0, expect_1.expect)(amount0, 'amount0 of other').to.eq(utilities_1.MaxUint128 / 2n - 1n);
        });
        it('two positions 1 wei of fees apart', async () => {
            await pool.initialize((0, utilities_1.encodePriceSqrt)(1, 1));
            await mint(wallet.address, minTick, maxTick, 1);
            await flash(0, 0, wallet.address, 1, 0);
            await mint(other.address, minTick, maxTick, 1);
            const totalFeeGrowth0TokenBefore = await pool.totalFeeGrowth0Token();
            await flash(0, 0, wallet.address, utilities_1.MaxUint128, 0);
            await flash(0, 0, wallet.address, utilities_1.MaxUint128, 0);
            await pool.burn(minTick, maxTick, 0, '0x');
            const totalFeeGrowth0Token = await pool.totalFeeGrowth0Token();
            (0, expect_1.expect)(totalFeeGrowth0Token).to.eq(totalFeeGrowth0TokenBefore + ((utilities_1.MaxUint128 - 3n) << 128n) / 2n);
            await flash(0, 0, wallet.address, 2, 0);
            await pool.burn(minTick, maxTick, 0, '0x');
            await pool.connect(other).burn(minTick, maxTick, 0, '0x');
            let { amount0 } = await pool.collect.staticCall(wallet.address, minTick, maxTick, utilities_1.MaxUint128, utilities_1.MaxUint128);
            (0, expect_1.expect)(amount0, 'amount0 of wallet').to.eq(utilities_1.MaxUint128 / 2n);
            ({ amount0 } = await pool
                .connect(other)
                .collect.staticCall(other.address, minTick, maxTick, utilities_1.MaxUint128, utilities_1.MaxUint128));
            (0, expect_1.expect)(amount0, 'amount0 of other').to.eq(utilities_1.MaxUint128 / 2n - 1n);
        });
    });
    describe('swap underpayment tests', () => {
        let underpay;
        let poolAddress;
        beforeEach('deploy swap test', async () => {
            const underpayFactory = await hardhat_1.ethers.getContractFactory('TestAlgebraSwapPay');
            underpay = (await underpayFactory.deploy());
            await token0.approve(underpay, ethers_1.MaxUint256);
            await token1.approve(underpay, ethers_1.MaxUint256);
            await pool.initialize((0, utilities_1.encodePriceSqrt)(1, 1));
            await mint(wallet.address, minTick, maxTick, (0, utilities_1.expandTo18Decimals)(1));
            poolAddress = await pool.getAddress();
        });
        it('swap 0 tokens', async () => {
            await (0, expect_1.expect)(underpay.swap(pool, wallet.address, true, utilities_1.MIN_SQRT_RATIO + 1n, 0, 1, 0)).to.be.revertedWithCustomError(pool, 'zeroAmountRequired');
        });
        it('underpay zero for one and exact in', async () => {
            await (0, expect_1.expect)(underpay.swap(pool, wallet.address, true, utilities_1.MIN_SQRT_RATIO + 1n, 1000, 1, 0)).to.be.revertedWithCustomError(pool, 'insufficientInputAmount');
        });
        it('underpay hardly zero for one and exact in supporting fee on transfer', async () => {
            await (0, expect_1.expect)(underpay.swapSupportingFee(pool, wallet.address, true, utilities_1.MIN_SQRT_RATIO + 1n, 1000, 0, 0)).to.be.revertedWithCustomError(pool, 'insufficientInputAmount');
        });
        it('underpay zero for one and exact in supporting fee on transfer', async () => {
            await (0, expect_1.expect)(underpay.swapSupportingFee(pool, wallet.address, true, utilities_1.MIN_SQRT_RATIO + 1n, 1000, 900, 0)).to.be.not
                .reverted;
        });
        it('pay in the wrong token zero for one and exact in', async () => {
            await (0, expect_1.expect)(underpay.swap(pool, wallet.address, true, utilities_1.MIN_SQRT_RATIO + 1n, 1000, 0, 2000)).to.be.revertedWithCustomError(pool, 'insufficientInputAmount');
        });
        it('overpay zero for one and exact in', async () => {
            await (0, expect_1.expect)(underpay.swap(pool, wallet.address, true, utilities_1.MIN_SQRT_RATIO + 1n, 1000, 2000, 0)).to.not.be.revertedWithCustomError(pool, 'insufficientInputAmount');
        });
        it('underpay zero for one and exact out', async () => {
            await (0, expect_1.expect)(underpay.swap(pool, wallet.address, true, utilities_1.MIN_SQRT_RATIO + 1n, -1000, 1, 0)).to.be.revertedWithCustomError(pool, 'insufficientInputAmount');
        });
        it('pay in the wrong token zero for one and exact out', async () => {
            await (0, expect_1.expect)(underpay.swap(pool, wallet.address, true, utilities_1.MIN_SQRT_RATIO + 1n, -1000, 0, 2000)).to.be.revertedWithCustomError(pool, 'insufficientInputAmount');
        });
        it('overpay zero for one and exact out', async () => {
            await (0, expect_1.expect)(underpay.swap(pool, wallet.address, true, utilities_1.MIN_SQRT_RATIO + 1n, -1000, 2000, 0)).to.not.be.revertedWithCustomError(pool, 'insufficientInputAmount');
        });
        it('underpay one for zero and exact in', async () => {
            await (0, expect_1.expect)(underpay.swap(pool, wallet.address, false, utilities_1.MAX_SQRT_RATIO - 1n, 1000, 0, 1)).to.be.revertedWithCustomError(pool, 'insufficientInputAmount');
        });
        it('underpay hardly one for zero and exact in supporting fee on transfer', async () => {
            await (0, expect_1.expect)(underpay.swapSupportingFee(pool, wallet.address, false, utilities_1.MAX_SQRT_RATIO - 1n, 1000, 0, 0)).to.be.revertedWithCustomError(pool, 'insufficientInputAmount');
        });
        it('underpay one for zero and exact in supporting fee on transfer', async () => {
            await (0, expect_1.expect)(underpay.swapSupportingFee(pool, wallet.address, false, utilities_1.MAX_SQRT_RATIO - 1n, 1000, 0, 990)).to.be.not
                .reverted;
        });
        it('pay in the wrong token one for zero and exact in', async () => {
            await (0, expect_1.expect)(underpay.swap(pool, wallet.address, false, utilities_1.MAX_SQRT_RATIO - 1n, 1000, 2000, 0)).to.be.revertedWithCustomError(pool, 'insufficientInputAmount');
        });
        it('overpay one for zero and exact in', async () => {
            await (0, expect_1.expect)(underpay.swap(pool, wallet.address, false, utilities_1.MAX_SQRT_RATIO - 1n, 1000, 0, 2000)).to.not.be.revertedWithCustomError(pool, 'insufficientInputAmount');
        });
        it('underpay one for zero and exact out', async () => {
            await (0, expect_1.expect)(underpay.swap(pool, wallet.address, false, utilities_1.MAX_SQRT_RATIO - 1n, -1000, 0, 1)).to.be.revertedWithCustomError(pool, 'insufficientInputAmount');
        });
        it('pay in the wrong token one for zero and exact out', async () => {
            await (0, expect_1.expect)(underpay.swap(pool, wallet.address, false, utilities_1.MAX_SQRT_RATIO - 1n, -1000, 2000, 0)).to.be.revertedWithCustomError(pool, 'insufficientInputAmount');
        });
        it('overpay one for zero and exact out', async () => {
            await (0, expect_1.expect)(underpay.swap(pool, wallet.address, false, utilities_1.MAX_SQRT_RATIO - 1n, -1000, 0, 2000)).to.not.be.revertedWithCustomError(pool, 'insufficientInputAmount');
        });
    });
});
