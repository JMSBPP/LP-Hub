import type { BaseContract, BigNumberish, BytesLike, FunctionFragment, Result, Interface, EventFragment, AddressLike, ContractRunner, ContractMethod, Listener } from "ethers";
import type { TypedContractEvent, TypedDeferredTopicFilter, TypedEventLog, TypedLogDescription, TypedListener, TypedContractMethod } from "../../common";
export interface MockPoolPluginInterface extends Interface {
    getFunction(nameOrSignature: "afterFlash" | "afterInitialize" | "afterModifyPosition" | "afterSwap" | "algebraMintCallback" | "algebraSwapCallback" | "beforeFlash" | "beforeInitialize" | "beforeModifyPosition" | "beforeSwap" | "defaultPluginConfig" | "disablePluginFeeHandle" | "getCurrentFee" | "handlePluginFee" | "isDisabled" | "mint" | "overrideFee" | "pluginFee" | "pool" | "selectorsDisableConfig" | "setPluginFees" | "setSelectorDisable" | "swap"): FunctionFragment;
    getEvent(nameOrSignatureOrTopic: "AfterFlash" | "AfterInitialize" | "AfterModifyPosition" | "AfterSwap" | "BeforeFlash" | "BeforeInitialize" | "BeforeModifyPosition" | "BeforeSwap"): EventFragment;
    encodeFunctionData(functionFragment: "afterFlash", values: [
        AddressLike,
        AddressLike,
        BigNumberish,
        BigNumberish,
        BigNumberish,
        BigNumberish,
        BytesLike
    ]): string;
    encodeFunctionData(functionFragment: "afterInitialize", values: [AddressLike, BigNumberish, BigNumberish]): string;
    encodeFunctionData(functionFragment: "afterModifyPosition", values: [
        AddressLike,
        AddressLike,
        BigNumberish,
        BigNumberish,
        BigNumberish,
        BigNumberish,
        BigNumberish,
        BytesLike
    ]): string;
    encodeFunctionData(functionFragment: "afterSwap", values: [
        AddressLike,
        AddressLike,
        boolean,
        BigNumberish,
        BigNumberish,
        BigNumberish,
        BigNumberish,
        BytesLike
    ]): string;
    encodeFunctionData(functionFragment: "algebraMintCallback", values: [BigNumberish, BigNumberish, BytesLike]): string;
    encodeFunctionData(functionFragment: "algebraSwapCallback", values: [BigNumberish, BigNumberish, BytesLike]): string;
    encodeFunctionData(functionFragment: "beforeFlash", values: [AddressLike, AddressLike, BigNumberish, BigNumberish, BytesLike]): string;
    encodeFunctionData(functionFragment: "beforeInitialize", values: [AddressLike, BigNumberish]): string;
    encodeFunctionData(functionFragment: "beforeModifyPosition", values: [
        AddressLike,
        AddressLike,
        BigNumberish,
        BigNumberish,
        BigNumberish,
        BytesLike
    ]): string;
    encodeFunctionData(functionFragment: "beforeSwap", values: [
        AddressLike,
        AddressLike,
        boolean,
        BigNumberish,
        BigNumberish,
        boolean,
        BytesLike
    ]): string;
    encodeFunctionData(functionFragment: "defaultPluginConfig", values?: undefined): string;
    encodeFunctionData(functionFragment: "disablePluginFeeHandle", values?: undefined): string;
    encodeFunctionData(functionFragment: "getCurrentFee", values?: undefined): string;
    encodeFunctionData(functionFragment: "handlePluginFee", values: [BigNumberish, BigNumberish]): string;
    encodeFunctionData(functionFragment: "isDisabled", values?: undefined): string;
    encodeFunctionData(functionFragment: "mint", values?: undefined): string;
    encodeFunctionData(functionFragment: "overrideFee", values?: undefined): string;
    encodeFunctionData(functionFragment: "pluginFee", values?: undefined): string;
    encodeFunctionData(functionFragment: "pool", values?: undefined): string;
    encodeFunctionData(functionFragment: "selectorsDisableConfig", values?: undefined): string;
    encodeFunctionData(functionFragment: "setPluginFees", values: [BigNumberish, BigNumberish]): string;
    encodeFunctionData(functionFragment: "setSelectorDisable", values: [BigNumberish]): string;
    encodeFunctionData(functionFragment: "swap", values?: undefined): string;
    decodeFunctionResult(functionFragment: "afterFlash", data: BytesLike): Result;
    decodeFunctionResult(functionFragment: "afterInitialize", data: BytesLike): Result;
    decodeFunctionResult(functionFragment: "afterModifyPosition", data: BytesLike): Result;
    decodeFunctionResult(functionFragment: "afterSwap", data: BytesLike): Result;
    decodeFunctionResult(functionFragment: "algebraMintCallback", data: BytesLike): Result;
    decodeFunctionResult(functionFragment: "algebraSwapCallback", data: BytesLike): Result;
    decodeFunctionResult(functionFragment: "beforeFlash", data: BytesLike): Result;
    decodeFunctionResult(functionFragment: "beforeInitialize", data: BytesLike): Result;
    decodeFunctionResult(functionFragment: "beforeModifyPosition", data: BytesLike): Result;
    decodeFunctionResult(functionFragment: "beforeSwap", data: BytesLike): Result;
    decodeFunctionResult(functionFragment: "defaultPluginConfig", data: BytesLike): Result;
    decodeFunctionResult(functionFragment: "disablePluginFeeHandle", data: BytesLike): Result;
    decodeFunctionResult(functionFragment: "getCurrentFee", data: BytesLike): Result;
    decodeFunctionResult(functionFragment: "handlePluginFee", data: BytesLike): Result;
    decodeFunctionResult(functionFragment: "isDisabled", data: BytesLike): Result;
    decodeFunctionResult(functionFragment: "mint", data: BytesLike): Result;
    decodeFunctionResult(functionFragment: "overrideFee", data: BytesLike): Result;
    decodeFunctionResult(functionFragment: "pluginFee", data: BytesLike): Result;
    decodeFunctionResult(functionFragment: "pool", data: BytesLike): Result;
    decodeFunctionResult(functionFragment: "selectorsDisableConfig", data: BytesLike): Result;
    decodeFunctionResult(functionFragment: "setPluginFees", data: BytesLike): Result;
    decodeFunctionResult(functionFragment: "setSelectorDisable", data: BytesLike): Result;
    decodeFunctionResult(functionFragment: "swap", data: BytesLike): Result;
}
export declare namespace AfterFlashEvent {
    type InputTuple = [
        sender: AddressLike,
        recipient: AddressLike,
        amount0: BigNumberish,
        amount1: BigNumberish,
        paid0: BigNumberish,
        paid1: BigNumberish,
        data: BytesLike
    ];
    type OutputTuple = [
        sender: string,
        recipient: string,
        amount0: bigint,
        amount1: bigint,
        paid0: bigint,
        paid1: bigint,
        data: string
    ];
    interface OutputObject {
        sender: string;
        recipient: string;
        amount0: bigint;
        amount1: bigint;
        paid0: bigint;
        paid1: bigint;
        data: string;
    }
    type Event = TypedContractEvent<InputTuple, OutputTuple, OutputObject>;
    type Filter = TypedDeferredTopicFilter<Event>;
    type Log = TypedEventLog<Event>;
    type LogDescription = TypedLogDescription<Event>;
}
export declare namespace AfterInitializeEvent {
    type InputTuple = [
        sender: AddressLike,
        sqrtPriceX96: BigNumberish,
        tick: BigNumberish
    ];
    type OutputTuple = [
        sender: string,
        sqrtPriceX96: bigint,
        tick: bigint
    ];
    interface OutputObject {
        sender: string;
        sqrtPriceX96: bigint;
        tick: bigint;
    }
    type Event = TypedContractEvent<InputTuple, OutputTuple, OutputObject>;
    type Filter = TypedDeferredTopicFilter<Event>;
    type Log = TypedEventLog<Event>;
    type LogDescription = TypedLogDescription<Event>;
}
export declare namespace AfterModifyPositionEvent {
    type InputTuple = [
        sender: AddressLike,
        recipient: AddressLike,
        bottomTick: BigNumberish,
        topTick: BigNumberish,
        desiredLiquidityDelta: BigNumberish,
        amount0: BigNumberish,
        amount1: BigNumberish,
        data: BytesLike
    ];
    type OutputTuple = [
        sender: string,
        recipient: string,
        bottomTick: bigint,
        topTick: bigint,
        desiredLiquidityDelta: bigint,
        amount0: bigint,
        amount1: bigint,
        data: string
    ];
    interface OutputObject {
        sender: string;
        recipient: string;
        bottomTick: bigint;
        topTick: bigint;
        desiredLiquidityDelta: bigint;
        amount0: bigint;
        amount1: bigint;
        data: string;
    }
    type Event = TypedContractEvent<InputTuple, OutputTuple, OutputObject>;
    type Filter = TypedDeferredTopicFilter<Event>;
    type Log = TypedEventLog<Event>;
    type LogDescription = TypedLogDescription<Event>;
}
export declare namespace AfterSwapEvent {
    type InputTuple = [
        sender: AddressLike,
        recipient: AddressLike,
        zeroToOne: boolean,
        amountRequired: BigNumberish,
        limitSqrtPrice: BigNumberish,
        amount0: BigNumberish,
        amount1: BigNumberish,
        data: BytesLike
    ];
    type OutputTuple = [
        sender: string,
        recipient: string,
        zeroToOne: boolean,
        amountRequired: bigint,
        limitSqrtPrice: bigint,
        amount0: bigint,
        amount1: bigint,
        data: string
    ];
    interface OutputObject {
        sender: string;
        recipient: string;
        zeroToOne: boolean;
        amountRequired: bigint;
        limitSqrtPrice: bigint;
        amount0: bigint;
        amount1: bigint;
        data: string;
    }
    type Event = TypedContractEvent<InputTuple, OutputTuple, OutputObject>;
    type Filter = TypedDeferredTopicFilter<Event>;
    type Log = TypedEventLog<Event>;
    type LogDescription = TypedLogDescription<Event>;
}
export declare namespace BeforeFlashEvent {
    type InputTuple = [
        sender: AddressLike,
        recipient: AddressLike,
        amount0: BigNumberish,
        amount1: BigNumberish,
        data: BytesLike
    ];
    type OutputTuple = [
        sender: string,
        recipient: string,
        amount0: bigint,
        amount1: bigint,
        data: string
    ];
    interface OutputObject {
        sender: string;
        recipient: string;
        amount0: bigint;
        amount1: bigint;
        data: string;
    }
    type Event = TypedContractEvent<InputTuple, OutputTuple, OutputObject>;
    type Filter = TypedDeferredTopicFilter<Event>;
    type Log = TypedEventLog<Event>;
    type LogDescription = TypedLogDescription<Event>;
}
export declare namespace BeforeInitializeEvent {
    type InputTuple = [sender: AddressLike, sqrtPriceX96: BigNumberish];
    type OutputTuple = [sender: string, sqrtPriceX96: bigint];
    interface OutputObject {
        sender: string;
        sqrtPriceX96: bigint;
    }
    type Event = TypedContractEvent<InputTuple, OutputTuple, OutputObject>;
    type Filter = TypedDeferredTopicFilter<Event>;
    type Log = TypedEventLog<Event>;
    type LogDescription = TypedLogDescription<Event>;
}
export declare namespace BeforeModifyPositionEvent {
    type InputTuple = [
        sender: AddressLike,
        recipient: AddressLike,
        bottomTick: BigNumberish,
        topTick: BigNumberish,
        desiredLiquidityDelta: BigNumberish,
        data: BytesLike
    ];
    type OutputTuple = [
        sender: string,
        recipient: string,
        bottomTick: bigint,
        topTick: bigint,
        desiredLiquidityDelta: bigint,
        data: string
    ];
    interface OutputObject {
        sender: string;
        recipient: string;
        bottomTick: bigint;
        topTick: bigint;
        desiredLiquidityDelta: bigint;
        data: string;
    }
    type Event = TypedContractEvent<InputTuple, OutputTuple, OutputObject>;
    type Filter = TypedDeferredTopicFilter<Event>;
    type Log = TypedEventLog<Event>;
    type LogDescription = TypedLogDescription<Event>;
}
export declare namespace BeforeSwapEvent {
    type InputTuple = [
        sender: AddressLike,
        recipient: AddressLike,
        zeroToOne: boolean,
        amountRequired: BigNumberish,
        limitSqrtPrice: BigNumberish,
        withPaymentInAdvance: boolean,
        data: BytesLike
    ];
    type OutputTuple = [
        sender: string,
        recipient: string,
        zeroToOne: boolean,
        amountRequired: bigint,
        limitSqrtPrice: bigint,
        withPaymentInAdvance: boolean,
        data: string
    ];
    interface OutputObject {
        sender: string;
        recipient: string;
        zeroToOne: boolean;
        amountRequired: bigint;
        limitSqrtPrice: bigint;
        withPaymentInAdvance: boolean;
        data: string;
    }
    type Event = TypedContractEvent<InputTuple, OutputTuple, OutputObject>;
    type Filter = TypedDeferredTopicFilter<Event>;
    type Log = TypedEventLog<Event>;
    type LogDescription = TypedLogDescription<Event>;
}
export interface MockPoolPlugin extends BaseContract {
    connect(runner?: ContractRunner | null): MockPoolPlugin;
    waitForDeployment(): Promise<this>;
    interface: MockPoolPluginInterface;
    queryFilter<TCEvent extends TypedContractEvent>(event: TCEvent, fromBlockOrBlockhash?: string | number | undefined, toBlock?: string | number | undefined): Promise<Array<TypedEventLog<TCEvent>>>;
    queryFilter<TCEvent extends TypedContractEvent>(filter: TypedDeferredTopicFilter<TCEvent>, fromBlockOrBlockhash?: string | number | undefined, toBlock?: string | number | undefined): Promise<Array<TypedEventLog<TCEvent>>>;
    on<TCEvent extends TypedContractEvent>(event: TCEvent, listener: TypedListener<TCEvent>): Promise<this>;
    on<TCEvent extends TypedContractEvent>(filter: TypedDeferredTopicFilter<TCEvent>, listener: TypedListener<TCEvent>): Promise<this>;
    once<TCEvent extends TypedContractEvent>(event: TCEvent, listener: TypedListener<TCEvent>): Promise<this>;
    once<TCEvent extends TypedContractEvent>(filter: TypedDeferredTopicFilter<TCEvent>, listener: TypedListener<TCEvent>): Promise<this>;
    listeners<TCEvent extends TypedContractEvent>(event: TCEvent): Promise<Array<TypedListener<TCEvent>>>;
    listeners(eventName?: string): Promise<Array<Listener>>;
    removeAllListeners<TCEvent extends TypedContractEvent>(event?: TCEvent): Promise<this>;
    afterFlash: TypedContractMethod<[
        sender: AddressLike,
        recipient: AddressLike,
        amount0: BigNumberish,
        amount1: BigNumberish,
        paid0: BigNumberish,
        paid1: BigNumberish,
        data: BytesLike
    ], [
        string
    ], "nonpayable">;
    afterInitialize: TypedContractMethod<[
        sender: AddressLike,
        sqrtPriceX96: BigNumberish,
        tick: BigNumberish
    ], [
        string
    ], "nonpayable">;
    afterModifyPosition: TypedContractMethod<[
        sender: AddressLike,
        recipient: AddressLike,
        bottomTick: BigNumberish,
        topTick: BigNumberish,
        desiredLiquidityDelta: BigNumberish,
        amount0: BigNumberish,
        amount1: BigNumberish,
        data: BytesLike
    ], [
        string
    ], "nonpayable">;
    afterSwap: TypedContractMethod<[
        sender: AddressLike,
        recipient: AddressLike,
        zeroToOne: boolean,
        amountRequired: BigNumberish,
        limitSqrtPrice: BigNumberish,
        amount0: BigNumberish,
        amount1: BigNumberish,
        data: BytesLike
    ], [
        string
    ], "nonpayable">;
    algebraMintCallback: TypedContractMethod<[
        amount0Owed: BigNumberish,
        amount1Owed: BigNumberish,
        arg2: BytesLike
    ], [
        void
    ], "nonpayable">;
    algebraSwapCallback: TypedContractMethod<[
        amount0Delta: BigNumberish,
        amount1Delta: BigNumberish,
        arg2: BytesLike
    ], [
        void
    ], "nonpayable">;
    beforeFlash: TypedContractMethod<[
        sender: AddressLike,
        recipient: AddressLike,
        amount0: BigNumberish,
        amount1: BigNumberish,
        data: BytesLike
    ], [
        string
    ], "nonpayable">;
    beforeInitialize: TypedContractMethod<[
        sender: AddressLike,
        sqrtPriceX96: BigNumberish
    ], [
        string
    ], "nonpayable">;
    beforeModifyPosition: TypedContractMethod<[
        sender: AddressLike,
        recipient: AddressLike,
        bottomTick: BigNumberish,
        topTick: BigNumberish,
        desiredLiquidityDelta: BigNumberish,
        data: BytesLike
    ], [
        [string, bigint]
    ], "nonpayable">;
    beforeSwap: TypedContractMethod<[
        sender: AddressLike,
        recipient: AddressLike,
        zeroToOne: boolean,
        amountRequired: BigNumberish,
        limitSqrtPrice: BigNumberish,
        withPaymentInAdvance: boolean,
        data: BytesLike
    ], [
        [string, bigint, bigint]
    ], "nonpayable">;
    defaultPluginConfig: TypedContractMethod<[], [bigint], "view">;
    disablePluginFeeHandle: TypedContractMethod<[], [void], "nonpayable">;
    getCurrentFee: TypedContractMethod<[], [bigint], "view">;
    handlePluginFee: TypedContractMethod<[
        arg0: BigNumberish,
        arg1: BigNumberish
    ], [
        string
    ], "view">;
    isDisabled: TypedContractMethod<[], [boolean], "view">;
    mint: TypedContractMethod<[], [void], "nonpayable">;
    overrideFee: TypedContractMethod<[], [bigint], "view">;
    pluginFee: TypedContractMethod<[], [bigint], "view">;
    pool: TypedContractMethod<[], [string], "view">;
    selectorsDisableConfig: TypedContractMethod<[], [bigint], "view">;
    setPluginFees: TypedContractMethod<[
        _overrideFee: BigNumberish,
        _pluginFee: BigNumberish
    ], [
        void
    ], "nonpayable">;
    setSelectorDisable: TypedContractMethod<[
        newSelectorsDisableConfig: BigNumberish
    ], [
        void
    ], "nonpayable">;
    swap: TypedContractMethod<[], [void], "nonpayable">;
    getFunction<T extends ContractMethod = ContractMethod>(key: string | FunctionFragment): T;
    getFunction(nameOrSignature: "afterFlash"): TypedContractMethod<[
        sender: AddressLike,
        recipient: AddressLike,
        amount0: BigNumberish,
        amount1: BigNumberish,
        paid0: BigNumberish,
        paid1: BigNumberish,
        data: BytesLike
    ], [
        string
    ], "nonpayable">;
    getFunction(nameOrSignature: "afterInitialize"): TypedContractMethod<[
        sender: AddressLike,
        sqrtPriceX96: BigNumberish,
        tick: BigNumberish
    ], [
        string
    ], "nonpayable">;
    getFunction(nameOrSignature: "afterModifyPosition"): TypedContractMethod<[
        sender: AddressLike,
        recipient: AddressLike,
        bottomTick: BigNumberish,
        topTick: BigNumberish,
        desiredLiquidityDelta: BigNumberish,
        amount0: BigNumberish,
        amount1: BigNumberish,
        data: BytesLike
    ], [
        string
    ], "nonpayable">;
    getFunction(nameOrSignature: "afterSwap"): TypedContractMethod<[
        sender: AddressLike,
        recipient: AddressLike,
        zeroToOne: boolean,
        amountRequired: BigNumberish,
        limitSqrtPrice: BigNumberish,
        amount0: BigNumberish,
        amount1: BigNumberish,
        data: BytesLike
    ], [
        string
    ], "nonpayable">;
    getFunction(nameOrSignature: "algebraMintCallback"): TypedContractMethod<[
        amount0Owed: BigNumberish,
        amount1Owed: BigNumberish,
        arg2: BytesLike
    ], [
        void
    ], "nonpayable">;
    getFunction(nameOrSignature: "algebraSwapCallback"): TypedContractMethod<[
        amount0Delta: BigNumberish,
        amount1Delta: BigNumberish,
        arg2: BytesLike
    ], [
        void
    ], "nonpayable">;
    getFunction(nameOrSignature: "beforeFlash"): TypedContractMethod<[
        sender: AddressLike,
        recipient: AddressLike,
        amount0: BigNumberish,
        amount1: BigNumberish,
        data: BytesLike
    ], [
        string
    ], "nonpayable">;
    getFunction(nameOrSignature: "beforeInitialize"): TypedContractMethod<[
        sender: AddressLike,
        sqrtPriceX96: BigNumberish
    ], [
        string
    ], "nonpayable">;
    getFunction(nameOrSignature: "beforeModifyPosition"): TypedContractMethod<[
        sender: AddressLike,
        recipient: AddressLike,
        bottomTick: BigNumberish,
        topTick: BigNumberish,
        desiredLiquidityDelta: BigNumberish,
        data: BytesLike
    ], [
        [string, bigint]
    ], "nonpayable">;
    getFunction(nameOrSignature: "beforeSwap"): TypedContractMethod<[
        sender: AddressLike,
        recipient: AddressLike,
        zeroToOne: boolean,
        amountRequired: BigNumberish,
        limitSqrtPrice: BigNumberish,
        withPaymentInAdvance: boolean,
        data: BytesLike
    ], [
        [string, bigint, bigint]
    ], "nonpayable">;
    getFunction(nameOrSignature: "defaultPluginConfig"): TypedContractMethod<[], [bigint], "view">;
    getFunction(nameOrSignature: "disablePluginFeeHandle"): TypedContractMethod<[], [void], "nonpayable">;
    getFunction(nameOrSignature: "getCurrentFee"): TypedContractMethod<[], [bigint], "view">;
    getFunction(nameOrSignature: "handlePluginFee"): TypedContractMethod<[
        arg0: BigNumberish,
        arg1: BigNumberish
    ], [
        string
    ], "view">;
    getFunction(nameOrSignature: "isDisabled"): TypedContractMethod<[], [boolean], "view">;
    getFunction(nameOrSignature: "mint"): TypedContractMethod<[], [void], "nonpayable">;
    getFunction(nameOrSignature: "overrideFee"): TypedContractMethod<[], [bigint], "view">;
    getFunction(nameOrSignature: "pluginFee"): TypedContractMethod<[], [bigint], "view">;
    getFunction(nameOrSignature: "pool"): TypedContractMethod<[], [string], "view">;
    getFunction(nameOrSignature: "selectorsDisableConfig"): TypedContractMethod<[], [bigint], "view">;
    getFunction(nameOrSignature: "setPluginFees"): TypedContractMethod<[
        _overrideFee: BigNumberish,
        _pluginFee: BigNumberish
    ], [
        void
    ], "nonpayable">;
    getFunction(nameOrSignature: "setSelectorDisable"): TypedContractMethod<[
        newSelectorsDisableConfig: BigNumberish
    ], [
        void
    ], "nonpayable">;
    getFunction(nameOrSignature: "swap"): TypedContractMethod<[], [void], "nonpayable">;
    getEvent(key: "AfterFlash"): TypedContractEvent<AfterFlashEvent.InputTuple, AfterFlashEvent.OutputTuple, AfterFlashEvent.OutputObject>;
    getEvent(key: "AfterInitialize"): TypedContractEvent<AfterInitializeEvent.InputTuple, AfterInitializeEvent.OutputTuple, AfterInitializeEvent.OutputObject>;
    getEvent(key: "AfterModifyPosition"): TypedContractEvent<AfterModifyPositionEvent.InputTuple, AfterModifyPositionEvent.OutputTuple, AfterModifyPositionEvent.OutputObject>;
    getEvent(key: "AfterSwap"): TypedContractEvent<AfterSwapEvent.InputTuple, AfterSwapEvent.OutputTuple, AfterSwapEvent.OutputObject>;
    getEvent(key: "BeforeFlash"): TypedContractEvent<BeforeFlashEvent.InputTuple, BeforeFlashEvent.OutputTuple, BeforeFlashEvent.OutputObject>;
    getEvent(key: "BeforeInitialize"): TypedContractEvent<BeforeInitializeEvent.InputTuple, BeforeInitializeEvent.OutputTuple, BeforeInitializeEvent.OutputObject>;
    getEvent(key: "BeforeModifyPosition"): TypedContractEvent<BeforeModifyPositionEvent.InputTuple, BeforeModifyPositionEvent.OutputTuple, BeforeModifyPositionEvent.OutputObject>;
    getEvent(key: "BeforeSwap"): TypedContractEvent<BeforeSwapEvent.InputTuple, BeforeSwapEvent.OutputTuple, BeforeSwapEvent.OutputObject>;
    filters: {
        "AfterFlash(address,address,uint256,uint256,uint256,uint256,bytes)": TypedContractEvent<AfterFlashEvent.InputTuple, AfterFlashEvent.OutputTuple, AfterFlashEvent.OutputObject>;
        AfterFlash: TypedContractEvent<AfterFlashEvent.InputTuple, AfterFlashEvent.OutputTuple, AfterFlashEvent.OutputObject>;
        "AfterInitialize(address,uint160,int24)": TypedContractEvent<AfterInitializeEvent.InputTuple, AfterInitializeEvent.OutputTuple, AfterInitializeEvent.OutputObject>;
        AfterInitialize: TypedContractEvent<AfterInitializeEvent.InputTuple, AfterInitializeEvent.OutputTuple, AfterInitializeEvent.OutputObject>;
        "AfterModifyPosition(address,address,int24,int24,int128,uint256,uint256,bytes)": TypedContractEvent<AfterModifyPositionEvent.InputTuple, AfterModifyPositionEvent.OutputTuple, AfterModifyPositionEvent.OutputObject>;
        AfterModifyPosition: TypedContractEvent<AfterModifyPositionEvent.InputTuple, AfterModifyPositionEvent.OutputTuple, AfterModifyPositionEvent.OutputObject>;
        "AfterSwap(address,address,bool,int256,uint160,int256,int256,bytes)": TypedContractEvent<AfterSwapEvent.InputTuple, AfterSwapEvent.OutputTuple, AfterSwapEvent.OutputObject>;
        AfterSwap: TypedContractEvent<AfterSwapEvent.InputTuple, AfterSwapEvent.OutputTuple, AfterSwapEvent.OutputObject>;
        "BeforeFlash(address,address,uint256,uint256,bytes)": TypedContractEvent<BeforeFlashEvent.InputTuple, BeforeFlashEvent.OutputTuple, BeforeFlashEvent.OutputObject>;
        BeforeFlash: TypedContractEvent<BeforeFlashEvent.InputTuple, BeforeFlashEvent.OutputTuple, BeforeFlashEvent.OutputObject>;
        "BeforeInitialize(address,uint160)": TypedContractEvent<BeforeInitializeEvent.InputTuple, BeforeInitializeEvent.OutputTuple, BeforeInitializeEvent.OutputObject>;
        BeforeInitialize: TypedContractEvent<BeforeInitializeEvent.InputTuple, BeforeInitializeEvent.OutputTuple, BeforeInitializeEvent.OutputObject>;
        "BeforeModifyPosition(address,address,int24,int24,int128,bytes)": TypedContractEvent<BeforeModifyPositionEvent.InputTuple, BeforeModifyPositionEvent.OutputTuple, BeforeModifyPositionEvent.OutputObject>;
        BeforeModifyPosition: TypedContractEvent<BeforeModifyPositionEvent.InputTuple, BeforeModifyPositionEvent.OutputTuple, BeforeModifyPositionEvent.OutputObject>;
        "BeforeSwap(address,address,bool,int256,uint160,bool,bytes)": TypedContractEvent<BeforeSwapEvent.InputTuple, BeforeSwapEvent.OutputTuple, BeforeSwapEvent.OutputObject>;
        BeforeSwap: TypedContractEvent<BeforeSwapEvent.InputTuple, BeforeSwapEvent.OutputTuple, BeforeSwapEvent.OutputObject>;
    };
}
